# 【MySQL】InnoDB中一条更新语句的执行流程



## SQL语句执行流程

一条`SQL`语句的执行，需要经过连接器、分析器、优化器、执行器和存储引擎等模块。

连接器管理着`MySQL`和客户端的连接，分析器将`SQL`语句分析成语法树，优化器会选择合适的执行计划，执行器根据执行计划来调用存储引擎提供的接口。

`SQL`语句的总体执行流程都是一样，但不同类型的语句，执行器做出的操作会有所不同。


## Buffer Pool

`Buffer Pool`是`InnoDB`存储引擎内部的一块内存组件，用于缓存各种数据。

更新数据时，会先检查对应行是否在`Buffer Pool`缓存中。如果不在，就从磁盘读入缓存。

如果`Buufer Pool`中有了所需数据，`InnoDB`会对该行加写锁，从而避免其他事务并发修改。


## undo log

`undo log`是回滚日志，通过该日志可以将数据回滚到指定版本，事务回滚和一致性视图都应用到了它。

更新数据时，`InnoDB`会将旧的数据信息写入`undo log`。


## 脏数据

写完`undo log`后，`InnoDB`会更新`Buffer Pool`中的记录。

这时，内存和磁盘中的数据是不一致的，所以称内存中的数据是脏数据，需要后续写入磁盘。

`MySQL`有一个后台线程，该线程会在某些时间点，将`Buffer Pool`中的脏数据刷新到磁盘中。


## redo log

`redo log`是`InnoDB`特有的日志，用于记录数据页的修改信息。通常情况下，该日志会被存放在名为`redo log buffer`的内存缓冲区中。

事务提交前，`InnoDB`会将修改信息写入`redo log`，并在`redo log`中添加`prepare`标记，表示准备提交事务。

如果在脏数据刷新到磁盘之前，`MySQL`崩溃了，此时内存中的数据会丢失。有了`redo log`，`MySQL`重启后就能实现数据恢复。

当然，服务崩溃后`redo log buffer`中的`redo log`也会被清除。因此，提交事务时需要将`redo log`写入磁盘。

参数`innodb_flush_log_at_trx_commit`控制着`redo log`的刷盘策略。该参数有3个值：

- 0：提交事务时，不会把日志写入磁盘，而是每隔一秒进行写入。

- 1：提交事务时，会将日志写入磁盘。

- 2：提交事务时，只会将日志写入操作系统的文件缓存，操作系统崩溃时该缓存会丢失。


## bin log

`bin log`是`server`层的日志，与存储引擎无关，记录的是逻辑性的日志，比如“将满足条件的记录更新为指定值”。

提交事务之前，除了会写`redo log`，还会写`bin log`。

`bin log`也有一个刷盘策略，由参数`sync_binlog`控制：

- 参数为0时，每次提交事务，都只是将日志写入操作系统的文件缓存中。

- 参数为1时，每次提交事务都会将日志写入磁盘。

- 参数为n时，表示每提交n个事务才写入一次磁盘，其余时间只写入文件缓存。


## 事务提交

事务提交后，会在`redo log`中写入`commit`标记。

事务准备提交时，会先写`redo log`，并标记为`prepare`状态。然后写`bin log`，再提交事务，最后将`redo log`改为`commit`状态。该流程就是“两阶段提交”。

在主备架构中，`bin log`会被用于进行主备库的数据同步。如果`bin log`已经写入，则备库就会执行对应事务。“两阶段提交”的设计目的，是为了保证数据一致性。

如果写了`redo log`并标记为`repare`状态，崩溃重启后，`MySQL`会根据`redo log`中的`XID`去`bin log`进行查找。如果找到对应日志，就应用`redo log`进行数据恢复，否则丢弃该日志。

如果写了`redo log`并标记为`commit`状态，崩溃重启后，`MySQL`会直接利用该日志进行数据恢复。

至此，一条更新语句就执行结束了。


