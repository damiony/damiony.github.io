[{"categories":["操作系统"],"content":"什么是内存 内存是存放数据的硬件，程序执行前，需要先放到内存中才能被CPU处理。 内存由一个个存储单元组成。 地址从0开始，每个地址对应一个存储单元。 如果按字节编址，则每个存储单元大小为1个字节。 如果按字编址，则每个存储单元的大小为一个字，字的大小视不同计算机的情况而言。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:1:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"程序执行过程 1.若干源代码文件 编译 -\u003e 2. 汇编文件（使用汇编语言） 汇编 -\u003e 3.若干目标模块（机器指令、通常使用逻辑地址） 链接 -\u003e 4.装入模块，如`.exe`（通常使用逻辑地址） 装入 -\u003e 5.内存（物理地址) 代码会被编译汇编成机器能识别的指令，这些指令会告诉CPU去内存的哪个地址存/取数据。 但是，在生成机器指令时，通常并不知道进程数据会被放到什么位置。 所以生成的机器指令中，通常使用的是逻辑地址。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:2:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"为什么需要区分内核空间和用户空间 CPU的所有指令中，有些指令很危险，如果错用会导致系统崩溃。 CPU将指令分为特权指令，和非特权指令。 CPU将特权等级分为4个等级：Ring0 ~ Ring3。 当进程运行在Ring3级别时，被称为运行在用户态。 当进程运行在Ring0级别时，被称为运行在内核态。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:3:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"逻辑地址 VS 物理地址 只要知道进程在内存中的起始地址，和进程数据的相对地址，就能求出进程数据的绝对地址。 相对地址就是逻辑地址，绝对地址就是物理地址。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:4:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"装入方式 绝对装入 静态重定位 动态重定位 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:5:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"1. 绝对装入 事先就知道程序会放到内存中的哪个位置，生成的目标模块中使用的是绝对地址。 装入程序按照装入模块中的地址，将程序和数据放入内存。 只适用于单道程序环境。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:5:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"2. 静态重定位 又称可重定位装入。 生成的装入模块，地址从0开始，使用的是逻辑地址。装入时，再将逻辑地址变换为物理地址。 特点： 装入内存时，必须分配其要求的全部内存空间。 如果没有足够的内存空间，就不能装入该程序作业。 一旦进入内存后，运行期间不能再移动，也不能再申请内存空间。 适用于多道批处理系统。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:5:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"3. 动态重定位 又称动态运行时装入。 链接生成的装入模块，地址从0开始，使用的是逻辑地址。装入内存后，并不会马上把逻辑地址转换为物理地址，而是在程序真正执行时，才进行地址转换。 这种方式依靠重定位寄存器（基址寄存器），用来存放装入模块的起始地址。 特点： 允许程序在内存中发生移动。 程序可分配到不连续的存储区。 程序运行前只需要装入部分代码即可，然后根据需要动态申请分配内存。 便于程序段的共享。 可以向用户提供一个比存储空间大的地址空间。 适用于现代操作系统。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:5:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"链接方式 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:6:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"1. 静态链接 程序运行前，将目标模块及它们所需的库函数，链接成一个可执行文件（装入模块）。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:6:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"2. 装入时动态链接 将目标模块装入内存是，边装入边链接。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:6:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"3. 运行时动态链接 在程序执行过程中，需要某目标模块时，才对它进行链接。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:6:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"内存管理 操作系统主要负责： 内存空间的分配与回收。 从逻辑上对内存进行扩充。 逻辑地址与物理地址的转换（地址重定向）。 提供内存保护功能。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:7:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"内存保护 保证各进程在自己的内存空间内运行，不会越界访问。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:8:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"1. 上下限寄存器 CPU可以设置上、下限寄存器，存放进程的上、下限地址。 进程的指令访问某个地址时，CPU检查是否越界。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:8:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"2. 重定位寄存器/界地址寄存器 可以采用“重定位寄存器”和“界地址寄存器”进行越界检查。 重定位寄存器（又称基址寄存器）存放进程的起始物理地址。 界地址寄存器（又称限长寄存器）存放进程的最大逻辑地址。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:8:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"覆盖 解决程序大小超过物理内存总和的问题。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:9:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"思想： 内存分为“一个固定区和若干个覆盖区”。 常驻内存的段，放在“固定区”，调入后就不再调出。 不常用的段，放在“覆盖区”，用到时调入内存，用不到时调出内存。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:9:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"实现 按照自身逻辑结构，让不可能同时被访问的程序段，共享同一个覆盖区。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:9:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"特点 必须由程序员声明覆盖结构，操作系统自动完成覆盖。 增加了用户编程负担。 只用于早期的操作系统中 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:9:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"交换 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:10:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"思想 内存空间紧张时，系统将内存中某些进程暂时换出外存。 将外存某些已经具备运行条件的进程换入内存 总而言之，就是进程在内存和磁盘间动态调度 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:10:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"中级调度 又称内存调度。 决定将某个处于挂起状态的进程重新调入内存。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:10:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"挂起状态 又称挂起态suspend。 暂时换出外存等待的进程状态，称为挂起状态。 挂起状态分为：就绪挂起、阻塞挂起。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:10:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"被换出进程保存位置 磁盘空间一般分为“文件区”和“对换区”。 文件区： 主要存放文件 主要追求存储空间的利用率 采用离散分配方式进行管理 对换区： 只占磁盘空间的小部分 被换出进程数据存放在对换区 主要追求换入换出速度 采用连续分配方式管理 对换区的I/O速度快于文件区。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:10:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"交换时机 进程运行数较多，且内存吃紧时进行交换，负荷降低后就暂停。 如经常发生缺页，说明内存紧张，可换出一些进程。 如果缺页率明显下降，可暂停换出。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:10:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"换出哪些进程 阻塞进程 优先级低的进程 有时还会考虑进程在内存中的驻留时间，太短则不换出 PCB会常驻内存 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:10:6","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"内部碎片和外部碎片 内部碎片：在分配给某进程的内存区域中，如果有些部分没有用上，这部分就是内部碎片。 外部碎片：指内存中的某些空闲分区，由于太小而难以利用。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:11:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"连续分配和非连续分配 连续分配：为用户进程分配的必须是一个连续的内存空间。 内存连续分配方式有：单一连续分配方式、固定分区分配方式、动态分区分配方式。 非连续分配：为用户进程分配的可以是分散的内存空间。 非连续分配方式有：基本分页存储管理、基本分段存储管理、段页式存储管理。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:12:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"单一连续分配 内存分为系统区和用户区。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:13:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"系统区 位于内存的低地址部分，用于存放操作系统相关数据 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:13:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"用户区 位于高地址部分，用于存放用户进程相关数据 内存中只能有一道用户程序，独占整个用户空间 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:13:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"优点 实现简单 无外部碎片 可以采用覆盖技术扩充内存 不一定需要内存保护 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:13:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 只能用于单用户、单任务操作系统 有内部碎片 存储器利用率极低 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:13:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"固定分区分配 将整个用户空间，分成若干个固定大小的分区，在每个分区中只装入一道作业。 分为两种方式：分区大小相等、分区大小不等。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:14:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"分区说明表 为了实现各个分区的分配与回收，需要建立“分区说明表”。 每个表项的内容为：分区号、分区大小、起始地址、状态（分配/未分配）。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:14:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"优点 实现简单 无外部碎片 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:14:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 程序太大时，无分区满足条件，此时得用覆盖技术来解决 会产生内部碎片，内存利用率低 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:14:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"动态分区分配 又称可变分区分配。 不会预先划分内存分区，而是当进程装入内存时，根据进程大小动态建立分区，并使分区大小正好适合进程需要。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:15:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"记录内存情况 两种常用数据结构记录内存使用情况： 空闲分区表（类似分区说明表） 空闲分区链 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:15:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"动态分区分配算法 从空闲分区表（或空闲分区链）中，选出一个分区分配给新进程，这种算法称为动态分区分配算法。 常见的分区分配算法有： 首次适应算法 最佳适应算法 最坏适应算法 邻近适应算法 首次适应算法： 效果最佳。 思想：从低地址开始查找，找到第一个满足大小的空闲分区。 实现：空闲分区以地址递增的方式排列。每次分配时，顺序查找空闲分区链（或表），直到找到第一个满足条件的分区。 优点：开销小，分区回收后一般不需要重新排序。 最佳适应算法： 思想：优先使用更小的空闲区 实现：空闲分区按照容量递增的方式排列。每次分配时，顺序查找第一个大小满足要求的空闲分区。 优点：会留下很多大分区。 缺点：会产生很多外部碎片。 最坏适应算法： 思想：优先使用最大的连续空闲区 实现：空闲分区按容量递减次序排列。每次分配时，顺序查找第一个大小满足要求的空闲分区。 优点：能减少小碎片数量。 缺点：大进程没有分区可用。 邻近适应算法： 思想：每次查找都从上次查找结束的位置开始。 实现：空闲区按地址递增的顺序排列成一个循环链表。每次分配时，从上次查找结束的位置开始，找到第一个大小满足要求的空闲分区。 优点：检索时不需要从低地址开始，算法开销小。 缺点：高地址的大分区，被使用的可能性很大，从而导致最后无大分区可用。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:15:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"紧凑技术 如果内存中空闲空间碎片的总和满足进程的要求，但是进程需要的是一整块连续的内存空间，这时可以使用紧凑技术，解决外部碎片。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:15:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 会产生很多外部碎片 利用紧凑技术处理外部碎片时，时间代价很高 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:15:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"非连续分配管理方式 常见的非连续分配管理方式为： 基本分页存储管理 基本分段存储管理 段页式存储管理 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:16:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"基本分页存储管理 由“固定分区分配”方式改进。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"思想 基本思想为： 把内存分为大小相等的小分区，再按照分区大小，将用户进程的地址空间，拆分成与页框大小相等的区域。 操作系统以页框为单位，为每个进程分配内存空间。进程的页面和内存的页框有一一对应的关系。 内存中的每个分区，称为页框、页帧、内存块、或者物理块。 每个分区有一个编号，称为页框号、页帧号、内存块号、或者物理块号，页框号从0开始。 用户进程的每个区域，称为页、或者页面。页面的编号称为页号，每个页号从0开始。 注意： 页框不能太大，否则会产生过大的内部碎片。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页表 用于获得进程的每个页面在内存中存放的位置。 一个进程对应一张页表。 进程每一页对应一个页表项。 页表项包含页号和内存块号两个信息，页号是隐含的。 每个页表项的长度都是相同的。 各页表项，会按顺序连续存放在内存中。 根据页表在内存的起始地址，和页表项长度，就可找到各个页号对应页表项的地址 为了方便查询，通常会让一个页表占更多字节，使得每个页面恰好可以装下整数个页表项。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"逻辑地址到物理地址的转换 转换过程： 确定逻辑地址对应的页号。 确定页号对应页面在内存中的起始地址。 计算逻辑地址在页面内的偏移量。 物理地址 = 页面始址 + 页内偏移量 一般计算公式： 页号 = 逻辑地址 / 页面长度 （取整） 页内偏移量 = 逻辑地址 % 页面长度 （取余） 为了计算方便，页面大小一般设置为2的整数幂。 如果每个页面大小为2^kB，用二进制表示逻辑地址，则末尾k位为页内偏移量，其余部分为页号。 如果页面大小为2的整数次幂，则只需把页表中记录的物理块号拼接上页内偏移量，就能得到物理地址。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页表寄存器 页表寄存器PTR，存放页表在内存中的起始地址F和页表长度。 进程未执行时，页表的起始地址和页表长度，放在进程控制块PCB中。 进程被调度时，内核会将上述两个值放入页表寄存器。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址转换的具体过程 根据逻辑地址计算出页号、页内偏移量。 比较页号和页表长度，判断是否产生越界中断，页号大于等于页表长度则越界。 查询页表，找到页号对应页表项，确定页面存放的内存块号。 用内存块号和页内偏移量，得到物理地址。 访问物理内存单元。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 每次访问逻辑地址的时候，都需要查询内存中的页表，且每次查到的结果可能都是同一个页表项。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:6","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"具有快表的地址变换 时间局部性： 如果执行了程序中某条指令，该指令可能很快会被再次执行。 如果某个数据被访问过，不久之后该数据可能被再次访问。 空间局部性： 程序访问了某个存储单元，不久之后其附近的存储单元也可能被访问。 快表： 又称联想寄存器，是一种访问速度比内存快很多的高速缓冲存储器。用来存放当前访问的若干页表项。 访问内存中的页表项之前，会先查询块表。如果查询命中，则可以直接访问物理地址。 慢表： 内存中的页表项常称为慢表。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:7","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"单级页表的问题 单级页表存在的问题： 页表必须连续存放，因此当页表很大，需要占用很多个连续的页框。可以采用多级页表解决。 没有必要让整个页表常驻内存，因为进程在一段时间内，可能只访问某几个特定的页面。可以采用虚拟存储技术解决。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:17:8","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"基本分段存储管理 按照程序自身的逻辑关系，将进程地址空间分为若干个段，每个段都有一个段名，每段从0开始编址。编译程序会将段名转换为段号。 以段为单位进行分配，每个段在内存中占据连续空间，但是各段之间可以不相邻。 分段系统的逻辑地址：段号 + 段内地址（段内偏移量） 段号位数，决定了每个进程最多可以分为几个段。 段内地址位数，决定了每个段的最大长度是多少。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:18:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段表 段表：每个进程拥有的一张段映射表，用于在物理内存中查找各个逻辑段的存放位置。 每个段对应一个段表项，记录了基址（段在内存中的起始位置）和段长。 各个段表项的长度是相同的，比如，操作系统可规定为6个字节。 短号是隐含的，不占用存储空间。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:18:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段表寄存器 包含：段表始址 + 段表长度 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:18:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址转换过程 根据逻辑地址，得到段号、段内地址。 判断段号是否越界，如果段号大于等于段表长度，则产生越界中断。 查询段表，找到对应的段表项。 检查段内地址是否超过段长，超过则产生越界中断。 计算得到物理地址，物理地址 = 段基址 + 段内地址。 访问目标内存单元。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:18:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"块表 分段也可以引入块表机制，和分页类似，不再赘述。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:18:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"分段和分页的对比 页是信息的物理单位，对用户是不可见的；段是信息的逻辑单位，分段对用户是可见的，用户编程时需要显示的给出段名。 分页的内存空间利用率高，不会产生外部碎片，只会产生少量内部碎片；分段会产生外部碎片。 分段比分页更容易实现信息的共享和保护。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:18:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段页式管理 思想：先将进程按逻辑块分段，再将各段分页。 逻辑地址结构为：段号、页号、页内地址（页内偏移量） 段号的位数，决定了每个进程最多可以分成几个段 页号位数，决定了每个段最大有多少页 页内偏移量，决定了页面大小、内存块大小 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:19:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段表和页表 每个段对应一个段表项 每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。 段表项长度相等，段号是隐含的 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:19:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址转换过程 根据逻辑地址，得到段号、页号、页内偏移量 判断段号是否越界，如果段号大于等于段表长度，则越界中断 查询段表，找到对应的段表项 检查页号是否越界，如果页号大于等于页表长度，则越界中断 根据页表存放块号、页号查询页表，找到页表项 根据内存块号、页内偏移量找到最终的物理地址 访问内存单元 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:19:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"虚拟内存 虚拟存储技术主要用于解决传统内存管理的局限性。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:20:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"传统存储管理 包括连续分配管理和非连续分配管理。 一次性： 作业必须一次性装入内存后，才能开始执行。 一次性缺陷： 作业很大时，无法运行。 无法实现大量作业同时运行，多道程序并发度降低。 驻留性： 作业被装入内存后，会一直驻留在内存中，直到作业运行结束。 驻留性缺陷： 内存中会驻留大量暂时用不到的数据，浪费内存资源。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:20:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"什么是虚拟内存 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存。 在程序执行时，如果所需信息不在内存中，操作系统负责将其从外存调入内存。 若内存空间不足，操作系统负责将内存中暂时用不到的信息换出外存。 在用户看来，会存在一个比实际内存大的内存，这就是虚拟内存。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:20:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"虚拟内存的容量 最大容量： 由计算机的地址结构（CPU寻址范围）确定的。 实际容量： 实际容量 = min(内存和外存容量之和，CPU寻址范围) ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:20:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"虚拟内存的主要特征 多次性：作业运行时，无需一次性装入内存，允许被分成多次调入内存 对换性：在作业运行过程中，允许将作业换入、换出 虚拟性：从逻辑上扩充了内存的容量 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:20:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"实现 虚拟内存的实现，建立在离散分配的内存管理方式基础上： 基本分页存储管理 基本分段存储管理 基本段页式存储管理 虚拟内存的实现： 请求分页存储管理 请求分段存储管理 请求段页式存储管理 操作系统要提供请求调页（或请求调段）功能。 操作系统要提供页面置换（或段置换）功能。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:20:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"请求分页存储管理 操作系统需要： 提供请求调页功能，将缺失页面从外存调入内存 提供页面置换功能，内存不够时，将暂时用不到的页面换出外存 管理方式： 页表机制 缺页中断机构 地址变换机构 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页表 页表项的组成为： 内存块号。如果信息位于外存，该字段为空。 状态位。表示是否已经调入内存。 访问字段。记录最近被访问过几次，或者记录上次访问的事件。 修改位。页面调入内存后，是否被修改过。 外存地址。页面在外存中的存放位置。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺页中断机构 如果要访问的页面不在内存中，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。 缺页中断属于内中断。 此时，缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列。 如果内存中有空闲块，则为进程分配一个空闲块，将所缺失页面装入该块，并修改页表的页表项。 如果内存中没有空闲块，则由页面置换算法，选择一个页面淘汰。如果被淘汰页面被修改过，则还需要写回外存。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址变换机构 根据页表项，检查页面是否在内存中。 若页面不在内存中，请求调页。 若内存空间不够，需要换出页面。 页面调入内存后，修改对应页表项和快表。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"快表 快表中有的页面一定存在内存中。如果某个页面被换出外存，则快表中的表项也要删除。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页面置换算法 最佳置换算法 淘汰将来不再使用、或者最长时间不再访问的页面。 该算法无法实现。 先进先出置换算法 淘汰最早进入内存的页面。 会产生Belady异常，当为进程分配的内存块增多时，缺页次数也会增多。 最近最久未使用置换算法LRU 淘汰最近最久未使用的页面。 页表项记录的是上次被访问以来经历的时间，时间最大的页面被淘汰。 时钟置换算法 循环扫描各个页面，并检查访问位，1表示被访问过。 如果访问位为1，则置为0，如果访问位为0，则淘汰。 若第一轮无页面淘汰，则进行第二轮扫面。 改进型时钟置换算法 循环扫描各个页面，并检查访问位和修改位，1表示访问过，1表示修改过。 第一轮扫描，淘汰第一个(0,0)。 第二轮扫描，淘汰第一个(0,1)，并将扫描过的访问位设为0。 第三轮扫描，淘汰第一个(0,0)。 第四轮扫描，淘汰第一个(0,1)。 只要有一个页面被淘汰，就不再继续后续扫描，所以最多扫描4轮。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页面分配 驻留集 请求分页存储管理中，为进程分配的内存块集合。 固定分配 每个进程的驻留集大小不变。 可变分配 每个进程的驻留集大小可变。 局部置换 只能使用进程自己的内存块进行置换。 全局置换 可以使用操作系统的空闲内存块，以及其它进程的物理块，进行置换。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:6","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["操作系统"],"content":"对换区 对换区采用的是连续存储方式，读写速度更快。 如果对换区足够大，进程数据将直接从文件区复制到对换区，之后的页面调入调出，都是在内存和对换区之间进行。 如果对换区不够大，进程不会修改的数据会从文件区调入，调出时不会写回文件区；会修改的数据，第一次从文件区调入，之后会调出到对换区，下次再从对换区调入。 对于UNIX，第一次使用的页面从文件区调入，调出的页面写回对换区，下次从对换区调入。 ","date":"2021-07-05","objectID":"/nei-cun-guan-li/:21:7","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/nei-cun-guan-li/"},{"categories":["MySQL"],"content":"预读机制 预读机制是相对于Innodb存储引擎而言的。 所谓预读机制，就是在加载数据页时，可能会将相邻数据页一起预先加载到buffer pool中，之后读取时就可以直接从内存获取，不必从磁盘读入。 使用Innodb的预读机制，可以减少磁盘IO次数，提高读写性能。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:1:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"预读模式 Innodb一共提供了两种预读模式： 线性预读：判断当前extend中的数据是否被连续访问，从而决定是否把下一个extend从磁盘中读出来，加载到buffer pool。 随机预读：判断当前extend中读取page的个数，从而决定是否把当前extend的数据加载到buffer pool中。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:2:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"线性预读 MySQL5.5之后，默认使用的是线性预读模式，与之有关的配置为innodb_read_ahead_threshold，这个参数表示，当前extend中，如果有超过innodb_read_ahead_threshold个page被连续访问，就预先加载下一个extend的数据。 innodb_read_ahead_threshold的默认参数是56，最大为64，最小为0。如果为0，表示关闭线性预读。即使关闭了线性预读，只要随机预读没有显式打开，就不会使用它。 innodb组织数据的顺序为tablespace, segment, extend, page, row，因为extend固定为1Mb，page默认为16Kb，所以一个extend能容纳64个page，所以innodb_read_ahead_threshold最大为64。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:3:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"预读原理 连续访问，是根据page的最新一次访问时间来判断的。 如果当前page是extend的第一个，则看后面的63个page，如果访问时间连续递减的个数，大于等于innodb_read_ahead_threshold，就加载上一个extend。 如果当前page是extend的最后一个，则看前面的63个page，如果访问时间连续递增的个数，大于等于innodb_read_ahead_threshold，就加载下一个extend。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:3:1","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"随机预读 MySQL5.5之后，随机预读是默认关闭的。 与随机预读有关的配置为innodb_random_read_ahead。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:4:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["操作系统"],"content":"磁盘的结构 磁盘。 一个磁盘由多个盘片叠加而成。 盘片表面由磁性物质组成，可以用来记录二进制数据。 盘面 盘片涂上磁性物质的那一面称为盘面，一个盘片可以有两个盘面。 每个盘面都有一个编号，从0开始。 磁道。 磁盘的磁面被划分成很多个圈，一个圈就是一个磁道。 扇区。 一个磁道被划分为多个扇区，每个扇区存放的数据量相同。 最内侧磁道的扇区，数据密度最大。 磁头。 每个盘面对应一个磁头。 磁臂。 所有磁头都是连在同一个磁臂上的。 柱面。 所有盘面中相对位置相同的磁道组成了柱面。 ","date":"2021-06-06","objectID":"/ci-pan/:1:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"磁盘的物理地址 ","date":"2021-06-06","objectID":"/ci-pan/:2:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"地址结构 对于每一个磁盘块，使用**（柱面号， 盘面号，扇区号）**的地址形式来表示。 ","date":"2021-06-06","objectID":"/ci-pan/:2:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"地址结构设计原理 如果采用**（盘面号，柱面号，扇区号）**的地址形式，一个盘面磁道读写完，就需要启动磁头臂，将磁头移入下一个柱面。 如果采用**（柱面号，盘面号，扇区号）**的地址形式，一个盘面磁道读写完，不需要移动磁头臂，只需要激活写一个盘面的磁头即可。 ","date":"2021-06-06","objectID":"/ci-pan/:2:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"在磁盘中读/写数据 根据柱面号，移动磁臂，将磁头指向指定柱面。 根据盘面号，激活指定盘面的磁头。 当指定扇区从磁头下划过时，就能完成数据读/写。 ","date":"2021-06-06","objectID":"/ci-pan/:2:3","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"磁盘分类 活动头磁盘：磁头可以移动。 固定头磁盘：磁头不可移动，每个磁道有一个磁头。 可换片磁盘：盘片可以更换。 固定盘磁盘：盘片不可更换。 ","date":"2021-06-06","objectID":"/ci-pan/:3:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"一次磁盘读写花费的时间 寻找时间（寻道时间）。 在读写数据前，将磁头移动到指定磁道所花的时间。包括两部分：启动磁头臂的时间 + 移动磁头的时间。 延迟时间。 旋转磁盘使磁头定位到指定扇区所用的时间。平均延迟时间为：平均延迟时间 = (1/2)*(1/r)，1/2表示平均要转动半圈。r表示每分钟转多少圈。 传输时间。 读写数据所用时间。 总时间为上述三个时间的总和。 ","date":"2021-06-06","objectID":"/ci-pan/:4:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"磁盘调度算法 不同的磁盘调度算法所需的寻道时间不同。 常见的磁盘调度算法为： 先来先服务算法。 最短寻找时间优先。 扫描算法。 Look调度算法。 循环扫描算法。 C-Look调度算法。 ","date":"2021-06-06","objectID":"/ci-pan/:5:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"1. 先来先服务算法 根据进程请求访问磁盘的先后顺序进行调度。 优点：公平；如果请求的磁道比较集中，性能还可以。 缺点：如果请求访问的磁道分散，则寻道时间长，性能很差。 ","date":"2021-06-06","objectID":"/ci-pan/:5:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"2. 最短寻找时间优先 优先处理与当前磁头最近的磁道。可以保证每次寻道时间最短，但是不能保证总寻道时间最短。 优点：性能较好，平均寻道时间短。 缺点：可能产生饥饿。 ","date":"2021-06-06","objectID":"/ci-pan/:5:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"3. 扫描算法 也叫电梯算法，磁头只有移动到最外侧磁道的时候，才能往内移动，只有移动到最内侧的时候，才能往外移动。 优点：性能较好，平均寻道时间较短，不会产生饥饿现象。 缺点：对各个磁道的响应不平均；可能会产生不必要的移动。 ","date":"2021-06-06","objectID":"/ci-pan/:5:3","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"4. Look调度算法 类似于扫描算法，但是如果在磁头移动方向上，已经没有请求了，就立即改变磁头移动方向。 优点：寻道时间比扫描算法跟短。 ","date":"2021-06-06","objectID":"/ci-pan/:5:4","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"5. 循环扫描算法 规定磁头朝一个方向移动时才处理访问请求，移动到尽头后直接返回到起始端，该过程不处理请求。 优点：每个磁道的响应都很平均，寻道时间比扫描算法更短。 缺点：会产生不必要的移动。 ","date":"2021-06-06","objectID":"/ci-pan/:5:5","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"6. C-Look调度算法 类似于循环扫描算法。但是，如果移动方向上没有请求了，就立即让磁头返回，并且只返回到需要访问的磁道位置。 优点：寻道时间进一步缩短。 ","date":"2021-06-06","objectID":"/ci-pan/:5:6","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"优化延迟时间 磁头读写一个扇区后，需要一小段时间做其他处理，然后才能继续操作其他扇区，但是磁盘会继续旋转，此时就会错过下个扇区。 如果逻辑相邻的扇区，在物理上也相邻，读写下个扇区时，就需要磁盘多转一轮，从而导致延迟时间变长。 根据上述原理，有两种减少延迟时间的办法：交替编号和错位命名。 ","date":"2021-06-06","objectID":"/ci-pan/:6:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"1. 交替编号 让逻辑相邻的扇区在物理上不相邻，如（0，4，1，5，2，6，3，7）。 ","date":"2021-06-06","objectID":"/ci-pan/:6:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"2. 错位命名 让相邻盘面的扇区编号错位。如上个盘面的0对应下个盘面的7。 ","date":"2021-06-06","objectID":"/ci-pan/:6:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"磁盘格式化 低级格式化：又称物理格式化，将磁盘的各个磁道划分为扇区。一个扇区由头、数据区域、尾三个部分组成。 将磁盘分区，每个分区由若干个柱面组成。如C盘，D盘。 进行逻辑格式化，创建文件系统。 ","date":"2021-06-06","objectID":"/ci-pan/:7:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"引导块 ","date":"2021-06-06","objectID":"/ci-pan/:8:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"初始化程序 计算机开机时，需要进行一系列初始化工作，这些工作是通过“初始化程序”完成的。 初始化程序可以放在只读存储器ROM中，ROM中的数据在出厂时就写入了，并且不能再修改。 ","date":"2021-06-06","objectID":"/ci-pan/:8:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"启动分区 如果初始化程序放在ROM中，就很难再去更新，所以通常将完整的初始化程序放在磁盘的启动分区上。启动分区位于磁盘固定位置，拥有启动分区的磁盘称为启动磁盘，或者系统磁盘。 ROM只存放很小的“自举装入程序”。开机时，计算机通过运行该程序找到启动分区，然后将完成的初始化程序读入内存，进行初始化。 ","date":"2021-06-06","objectID":"/ci-pan/:8:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/ci-pan/"},{"categories":["操作系统"],"content":"机器指令是什么 机器指令，是CPU能识别和执行的最基本命令。 一条高级语言写的代码，经过编译，可能会生成多条机器指令。而程序运行的本质，就是CPU执行一条一条的机器指令。 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:1:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"特权指令和非特权指令 CPU将机器指令分为了“特权指令”和“非特权指令”。 应用程序只能执行非特权指令，操作系统内核可以执行特权指令。 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:2:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"用户态和核心态 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:3:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"1. 什么是用户态 用户态又称目态。当运行的是应用程序时，称CPU处于用户态，只能执行非特权指令。 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:3:1","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"2. 什么是内核态 内核态又称核心态、管态。当运行的是内核程序时，称CPU处于内核态，可以执行特权指令。 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:3:2","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"3. 用户态和内核态的相互转换 用户态到内核态的转变，由中断信号引发，硬件自动完成转变过程。只要触发中断信号，操作系统就会抢占CPU的使用权。 CPU中存在一个寄存器，叫程序状态寄存器（PSW），它有一个二进制位，1表示处于内核态，0表示处于用户态。 核心态到用户态的转变，由一条修改PSW标志位的特权指令完成，将标志位置为0即表示回到了用户态。 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:3:3","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"系统调用 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:4:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"1. 什么是系统调用 “系统调用”是操作系统提供给应用程序使用的接口，应用程序可以通过系统调用来请求获得操作系统内核的服务。使用系统调用，可以保证系统的稳定性和安全性。 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:4:1","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"2. 库函数 编程语言提供的库函数，有时会将系统调用封装起来，以隐藏一些调用细节，从而使编程更加方便。 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:4:2","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"3. 系统调用的功能 系统调用具备的主要功能为： 设备管理 文件管理 进程控制 进程通信 内存管理 ","date":"2021-05-06","objectID":"/yong-hu-tai-he-nei-he-tai/:4:3","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/yong-hu-tai-he-nei-he-tai/"},{"categories":["Linux"],"content":"在Linux中，查找文件的方法有很多，现在介绍常见的几个工具。 ","date":"2021-03-10","objectID":"/linux-find-files/:0:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"locate 这是较为简单的文件搜索命令。 locate命令通过快速搜索数据库，从而找到路径名与给定字符串相匹配的文件，并输出结果。 ","date":"2021-03-10","objectID":"/linux-find-files/:1:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"命令格式 命令格式如下： locate [options] [pattern] ","date":"2021-03-10","objectID":"/linux-find-files/:1:1","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"options 常见的选项如下： -A: -all，只输出同时匹配所有模式的文件。默认情况下，文件只要匹配某个模式就会被打印。 -V: 打印版本信息。 ","date":"2021-03-10","objectID":"/linux-find-files/:1:2","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"pattern 搜索时，不要求文件和模式完全匹配，即搜索支持通配符。 ","date":"2021-03-10","objectID":"/linux-find-files/:1:3","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"数据库 linux系统中通常会开启一个定时任务，然后每隔一段时间执行一次updatedb程序命令，从而生成新的数据库文件。locate搜索时，会在这个数据库文件中进行查找。 linux系统中的数据库通常位于/var/lib/mlocate/mlocate.db。 locate搜索到的结果，并不一定是当前的最新的文件。如果想获得最新的结果，可以切换到root用户，并执行updatedb。 ","date":"2021-03-10","objectID":"/linux-find-files/:1:4","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"find find命令除了可以根据文件名搜索文件外，还可以根据各种属性进行文件查找，其支持的特性非常丰富。 ","date":"2021-03-10","objectID":"/linux-find-files/:2:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"命令格式 find的命令格式如下： find [options] [path] [expression] 如果省略path，则默认在当前目录下搜索。 ","date":"2021-03-10","objectID":"/linux-find-files/:2:1","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"常见选项参数 常见的选项为： -cmin 后跟参数： n: 匹配n分钟前内容或属性改变的文件或目录。 +n: 超过n分钟。 -n: 不足n分钟。 -cnewer file 内容或属性的修改时间晚于file的文件或目录。 -ctime 后跟参数： n: n*24小时前，内容或属性发生改变的文件或目录。 +n: 超过n*24小时。 -n: 不足n*24小时。 -empty 匹配空文件或空目录。 -group name 匹配属于name组的文件或目录，name可以是组名，或者组ID。 -name pattern 和通配符匹配的文件或目录。 -iname pattern 和-name类似，只是文件或目录不区分大小写。 -inum n 匹配索引节点是n的文件，通常用于查找硬连接。 -mmin 后跟参数： n: 匹配n分钟前内容被修改的文件或目录。 +n: 超过n分钟。 -n: 不足n分钟。 -mtime 后跟参数： n: 匹配n*24小时前内容被修改的文件或目录。 -n: 不足n小时。 +n: 超过n小时。 -newer file 匹配内容的修改时间晚于file的文件或目录。 -nouser 匹配不属于有效用户的文件或目录。当用户被删除时，该命令可以用于删除无用文件。 -nogroup 匹配不属于有效用户组的文件或目录。 -perm mode 与指定权限匹配的文件或目录。 -samefile file 与-inum类似，匹配与file具有相同inode的文件。 -size 后跟参数： n: 匹配大小等于n的文件或目录。 +n: 匹配大小超过n的文件或目录。 -n: 匹配大小不足n的文件或目录。 n的计量单位可以是： b: 512字节的块。 c: 字节，如-size 1c。 w: 两个字节的字。 k: KB。 M: MB。 G: GB。 -type t 匹配t类型的目标。t可以是： b: 块设备文件。 c: 字符设备文件 d: 目录。 f: 普通文件。 l: 符号链接。 -user name 匹配属于name用户的文件或目录，name可以是用户名，或者用户ID。 ","date":"2021-03-10","objectID":"/linux-find-files/:2:2","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"逻辑操作 逻辑操作也是options中的一种。 -and：将多个检验条件以“逻辑与”的关系组合起来，表示“逻辑与”的关系时，可以省略该操作符。简写为-a。 -or：将多个检验条件以“逻辑或”的关系组合起来，简写为-o。 -not：匹配使该操作符之后的条件为假的文件或目录。 ()：默认情况下，find命令从左向右进行运算，而括号()可以改变运算优先级。通常()前需要使用引号或者反斜线，如\\(\\)。 逻辑操作符采用惰性运算，即如果操作符左边的条件能确定最终结果，就不再执行右边的操作。 ","date":"2021-03-10","objectID":"/linux-find-files/:2:3","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"其他选项 find命令还有一些其他的常见选项： -depth：要求find先处理完文件，再处理目录。 -mindeoth levels：从该层级的子目录开始搜索。 -maxdepth levels：搜索的最大子目录层级。 -mount：不去遍历挂载在其他文件系统上的目录。 -noleaf：要求find程序不要以“正在搜索类UNIX文件系统“为假设来优化搜索，在DOS/Windows系统上会用到该选项。 ","date":"2021-03-10","objectID":"/linux-find-files/:2:4","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"pattern 如果省略pattern，则默认在当前目录下搜索。 ","date":"2021-03-10","objectID":"/linux-find-files/:2:5","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"expression 找到文件后，就可以根据expression对文件进行处理了。 find中有一些预定义的动作： -delete：删除匹配文件。 -ls：以标准格式输出匹配文件。 -print：输出匹配文件，默认情况下就是执行该操作。 -quit：一旦匹配成功就退出。 find还可以根据需要自定义动作，自定义方法为： -exec [commands] {} [commands] ; # {} 表示被匹配的文件 # ; 需要使用引号或者反斜线来进行转义 # -ok 作用类似于-exec，只是执行命令前会询问用户 上述方法会对每个匹配文件执行一遍自定义命令，如果只想对所有匹配文件执行一次命令，可以使用下述方法： -exec [commands] {} [commands] + # 或者 find [options] [path] [expression] | xargs commands ","date":"2021-03-10","objectID":"/linux-find-files/:2:6","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"whereis whereis用来查找满足条件的二进制文件、帮助文件和源代码文件。 ","date":"2021-03-10","objectID":"/linux-find-files/:3:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"具体用法 用法为： whereis [options] 文件 ","date":"2021-03-10","objectID":"/linux-find-files/:3:1","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"常见选项 -b：只搜索二进制文件。 -B \u003c目录\u003e：指定二进制文件搜索路径。 -m：只搜索man帮助文档。 -M \u003c目录\u003e：指定帮助文档搜索路径。 -s：只搜索源代码文件。 -S \u003c目录\u003e：指定源代码文件搜索路径。 -l：输出有效查找路径。 ","date":"2021-03-10","objectID":"/linux-find-files/:3:2","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"文件分类方式 whereis有一套自己的文件搜索方式，它规定了二进制文件、帮助文档或者源代码文件的搜索目录。 使用whereis -l即可查看具体搜索路径。 ","date":"2021-03-10","objectID":"/linux-find-files/:3:3","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"which which用于在PATH路径中查找可执行程序，并输出具体路径。 如： which ls # /usr/bin/ls ","date":"2021-03-10","objectID":"/linux-find-files/:4:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-find-files/"},{"categories":["Linux"],"content":"什么是gawk gawk是Unix中原始awk程序的GNU版本，可以将gawk看成是一种编程语言，并用它处理数据。 gawk的执行流程和sed类似，首先从标准输入stdin或者文件中读取数据，每次读取一行，并针对该行数据执行脚本命令，然后继续读取下一行并重复前面的操作。 ","date":"2021-02-10","objectID":"/linux-gawk/:1:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"gawk命令格式 gawk命令格式为： gawk options program file ","date":"2021-02-10","objectID":"/linux-gawk/:2:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. options 常见的options为： -F fs 指定每行数据的字段分隔符，如-F;表示以;为字段分隔符。 默认的字段分隔符是空白字符（空格或者制表符）。 -f file gawk程序可以预先写在文件中，-f用于从指定文件读取程序。 -v var=value 为gawk程序定义变量。 ","date":"2021-02-10","objectID":"/linux-gawk/:2:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. program gawk的脚本命令必须放在花括号{}中，如： gawk '{print \"hello world\"}' 程序命令可以有多条，如果多条命令位于同一行，需要用;分开。如： gawk '{print \"hello\"; print \"world\"}' 多条命令也可以位于多行，此时，多条命令之间不需要分隔符。如： gawk '{ print \"hello\" print \"world\" }' 在对数据进行处理前，可以执行指定命令，这些命令放在BEGIN命令块中。如： gawk 'BEGIN{print \"Title\"}' 数据处理结束后，也可以执行指定命令，这些命令放在END命令块中。如： gawk 'END{print \"End of File\"}' 如果只指定了BEGIN命令块或者END命令块，缺少数据处理命令，则不会对输入数据做任何操作。 ","date":"2021-02-10","objectID":"/linux-gawk/:2:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. file 如果gawk命令行中没有指定file，则从标准输入读取数据，否则就从指定文件读取数据。 如：执行命令gawk '{print \"hello world\"}'后，程序会从stdin接收数据，并打印hello world。此时，可以使用Ctrl + d组合键来终止程序，该组合键会发送EOF字符。 ","date":"2021-02-10","objectID":"/linux-gawk/:2:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"变量 ","date":"2021-02-10","objectID":"/linux-gawk/:3:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. 数据字段变量 每行的数据字段都会对应一个变量，字段是根据字段分隔符来划分的。 $0：代表整行文本。 $1：代表第一个字段。 $2：代表第二个字段。 $n：代表第n个字段。 ","date":"2021-02-10","objectID":"/linux-gawk/:3:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. 内建变量 假设data.txt是一个文本文件。 FIELDWIDTHS 该命令后面会跟上一串数字，如\"3 2 1\"，用来定义每个数据字段的宽度。如： gawk 'BEGIN{FIELDWIDTHS=\"3 2 1\"} {print $1, $2, $3}' data.txt 使用了FIELDWIDTHS后，字段分隔符会被忽略。 FS 指定输入数据的字段分隔符。如： gawk 'BEGIN{FS=\":\"} {print $1, $2, $3}' data.txt RS 指定输入数据的行分隔符。如： # 指定空白行为行分隔符 gawk 'BEGIN{RS=\"\"} {print $0}' data.txt OFS 指定输出数据的字段分隔符。如： gawk 'BEGIN{OFS=\";\"} {print $1, $2, $3}' data.txt ORS 指定输出数据的行分隔符。如： gawk 'BEGIN{ORS=\",\"} {print $0}' data.txt ARGC 存放的是当前命令行参数的个数。如： gawk '{print ARGC}' data.txt data.txt # 输出是3，脚本命令和选项不参与计数 ARGV 由命令行参数组成的数组。如： gawk '{print ARGC, ARGV[0], ARGV[1]}' data.txt # 2 gawk data.txt ARGIND 表示当前文件在ARGV中的位置。如： gawk '{print ARGIND}' data.txt data.txt # 1 2 ENVIRON 由当前shell环境变量组成的关联数组。如： # 输出HOME目录 gawk '{print ENVIRON[\"HOME\"]}' data.txt FILENAME 当前文件的文件名。如： gawk '{print FILENAME}' data.txt # data.txt NF 当前行的字段总数。如： gawk '{print NF, $NF}' data.txt FNR 当前文件已读取的数据行数，遇到新的文件时，会重新从1开始计数。如： gawk '{print FNR}' data.txt data.txt # 1 1 NR 已读取的总数据行数，遇到新文件时，会进行累计，而不是重新计数。如： gawk '{print NR}' data.txt data.txt # 1 2 ","date":"2021-02-10","objectID":"/linux-gawk/:3:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. 自定义变量 变量名由字母、数字、下划线组成，但是不能以数字开头。 自定义变量的定义方式由多种： 在程序脚本中定义变量。如： gawk 'BEGIN{test=\"test line\"; print test; test=1; print test}' # test line # 1 在命令行中定义变量，且变量定义位于程序脚本之后。如： gawk '{print $n}' n=1 data.txt 这种方式定义的变量，不能在BEGIN命令块中使用。 在命令行中定义变量，且变量定义位于程序脚本之前。此时需要使用-v选项。如： gawk -v n=2 'BEGIN{print n}' ","date":"2021-02-10","objectID":"/linux-gawk/:3:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"数组 gawk编程语言使用关联数组来实现数组功能。 关联数组的索引值不再必须是连续的数字，而是可以使用任意文本字符串。 ","date":"2021-02-10","objectID":"/linux-gawk/:4:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. 数组定义 定义方式为： arr[index] = value 索引查找方式为： arr[index] ","date":"2021-02-10","objectID":"/linux-gawk/:4:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. 遍历数组 数组遍历的语法为： for (idx in array) { statements } 如果statements只有一行，则可以省略外层的花括号，如： for (idx in array) statements 数组遍历的结果是没有固定顺序的。 ","date":"2021-02-10","objectID":"/linux-gawk/:4:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. 删除数组中的变量 删除语法为： delete array[index] ","date":"2021-02-10","objectID":"/linux-gawk/:4:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"算数运算符 gawk支持下列算数运算符： +：加。 -：减。 *：乘。 /：除。 %：取余。 ^或者**：乘方。 ++x：x加1，然后返回x。 x++：先返回x，然后x加一。 --x：x减一，然后返回x。 x--：先返回x，然后x减一。 ","date":"2021-02-10","objectID":"/linux-gawk/:5:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"模式 在gawk程序脚本中，可以使用不同类型的匹配模式，来过滤数据行。 BEGIN和END可以看成是两个特殊模式。 ","date":"2021-02-10","objectID":"/linux-gawk/:6:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. 正则表达式 可以使用正则表达式，来对数据行进行匹配。如： gawk '/root/{print $1}' /etc/passwd 该命令会匹配包含root的数据行。 还可以使用匹配操作符~，来对某个特定字段进行匹配，如： gawk '$1 ~ /^root/{print $0}' /etc/passwd 该命令会匹配第一个字段以root开头的数据行。 还可以使用!~来排除匹配行。如： gawk '$1 !~ /^root/{print $0}' /etc/passwd 该命令会过滤第一个字段以root开头的数据行。 ","date":"2021-02-10","objectID":"/linux-gawk/:6:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. 数学比较表达式 可以使用的数学比较表达式有： x == y x \u003c= y x \u003c y x \u003e= y x \u003e y 比较双方，既可以为数字，也可以是任意字符串。 ","date":"2021-02-10","objectID":"/linux-gawk/:6:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"流程控制语句 gawk支持多种流程控制语句： if...else...、 while...、 do...while...、 for循环 ","date":"2021-02-10","objectID":"/linux-gawk/:7:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. if…else… 语法格式为： if (condition1) { statement1 } else if (condition2) { statement2 } else { statement3 } 如果statement只有一行命令，则可以省略外层花括号。 还可以将上述命令写成一行。此时，在省略花括号的情况下，必须用分号分隔每个if语句。 ","date":"2021-02-10","objectID":"/linux-gawk/:7:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. while… 语法格式为： while (condition) { statements } 可以使用break或者continue跳出循环。 ","date":"2021-02-10","objectID":"/linux-gawk/:7:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. do…while… 语法格式为： do { statements } while (condition) ","date":"2021-02-10","objectID":"/linux-gawk/:7:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"4. for循环 gawk支持c语言风格的for循环。语法格式为： for (variable assignment; condition; iteration process) { statements } ","date":"2021-02-10","objectID":"/linux-gawk/:7:4","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"printf gawk可以使用printf进行格式化打印。 printf的命令格式为： printf \"format string\", var1, var2... format string是格式化字符，其中包含文本字符和占位符。 占位符格式为：%[modifier]control-letter，modifier是修饰符，control-letter是控制字符。 control-letter列表如下： c：以ASCII形式显示。如： gawk 'BEGIN{printf \"%c\\n\", 65}' # A d：显示整数值。如： gawk 'BEGIN{printf \"%d\\n\", 65}' # 65 i：显示整数值，和d一样。如： gawk 'BEGIN{printf \"%i\\n\", 65}' e：以科学记数法形式显示一个数。如： gawk 'BEGIN{printf \"%.2e\\n\", 100000}' # 1.00e+05 f：显示浮点数。如： gawk 'BEGIN{printf \"%f\\n\", 3.141}' # 3.141000 g：用科学记数法或浮点数显示（选择较短的格式）。如： gawk 'BEGIN{printf \"%g\\n\", 0.0000001}' # 1e-07 o：显示为八进制。如： gawk 'BEGIN{printf \"%o\\n\", 10}' # 12 s：打印一个字符串。 gawk 'BEGIN{printf \"%s\\n\", \"hello world\"}' # hello world x：显示为十六进制。如： gawk 'BEGIN{printf \"%x\\n\", 10}' # a X：显示为十六进制，但是使用大写A~F。 gawk 'BEGIN{printf \"%X\\n\", 10}' # A modifier如下： width：输出字段最小宽度。 prec：指定浮点数的最小宽度和精度。 -：文本设置为左对齐，默认是右对齐。 +：文本设置为右对齐。 #：在八进制数前显示0，在十六进制前显示0x。 ","date":"2021-02-10","objectID":"/linux-gawk/:8:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"结语 gawk还有很多有用的特性，如函数等，暂时不做说明。 ","date":"2021-02-10","objectID":"/linux-gawk/:9:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["操作系统"],"content":"中断 中断是为了实现多道程序并发执行，而引入的一种机制 中断发生时，CPU立即进入核心态 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理 对于不同的中断信号，会进行不同处理 ","date":"2021-02-06","objectID":"/zhong-duan/:1:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/zhong-duan/"},{"categories":["操作系统"],"content":"中断的作用 中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。 如果没有中断，cpu将一直运行应用程序，从而无法执行操作系统内核程序。 中断是用户态进入核心态的唯一途径。 核心态到用户态的切换，是通过执行一个特权指令来完成。该指令将程序状态字PSW的标志位设置为用户态。 ","date":"2021-02-06","objectID":"/zhong-duan/:2:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/zhong-duan/"},{"categories":["操作系统"],"content":"中断分类 广义上的中断分为两类： 内中断：信号来源于CPU内部，与当前执行的指令有关。 外中断：信号来源于CPU外部，与当前执行的指令无关。 狭义上的中断，就是指外中断，而此时内中断会被称为“异常”。 ","date":"2021-02-06","objectID":"/zhong-duan/:3:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/zhong-duan/"},{"categories":["操作系统"],"content":"1. 内中断 也称异常、例外。内中断主要有3类： 陷阱、陷入（trap) 由陷入指令引发，此时，应用程序主动将CPU使用权交给操作系统内核。 系统调用就是通过陷入指令实现。 故障（fault) 由错误条件引起，可能会被内核程序修复。 内核程序修复故障后，会讲CPU使用权交还给应用程序。 如：缺页故障。 终止（abort) 由致命错误引起，内核程序通常会直接终止应用程序，不会将CPU使用权归还给应用程序。 如：整数除0。 ","date":"2021-02-06","objectID":"/zhong-duan/:3:1","tags":["操作系统"],"title":"【操作系统】中断","uri":"/zhong-duan/"},{"categories":["操作系统"],"content":"2. 外中断 每一条指令执行结束，CPU都会检查是否有外部中断信号，如果有，就执行中断处理程序。 常见的外中断，有时钟中断，IO中断请求。 ","date":"2021-02-06","objectID":"/zhong-duan/:3:2","tags":["操作系统"],"title":"【操作系统】中断","uri":"/zhong-duan/"},{"categories":["操作系统"],"content":"中断运行原理 不同的中断信号，需要用不同的中断处理程序来处理。 中断处理程序，一定是内核程序，需要运行在“内核态”。 当CPU检测到中断信号后，会查询中断向量表，找到相应的中断处理程序在内存中的存放位置。中断向量表是由中断信号类型、和中断处理程序指针组成。 ","date":"2021-02-06","objectID":"/zhong-duan/:4:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/zhong-duan/"},{"categories":["操作系统"],"content":"进程基本概念 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:1:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 进程的定义 进程的定义方式有多种，常见的几种定义如下： 进程是程序的一次执行过程。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:1:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 进程的组成 进程由三部分组成： 进程控制块PCB。 程序段。 数据段。 系统根据PCB感知进程的存在，PCB是进程存在的唯一标志。PCB的组成部分通常为： 进程标识符PID。每个进程都有唯一的标识符。 进程当前状态。作为进程调度程序分配CPU的依据。 进程队列指针。指向PCB队列中，下一个PCB的地址。 程序和数据地址。进程程序段和数据段的地址。 进程优先级。 CPU现场保护区。保存CPU的现场信息，如指令寄存器、状态寄存器、通用寄存器等。 通信信息。进程执行过程中，与别的进程发生的信息交换情况。 家族联系。进程可以创建子进程，从而形成一个进程家族树。 占有资源清单。记录了所需资源和已分配资源。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:1:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程的特点 动态性： 进程是程序在处理器上的一次执行过程，因而是动态的。 并发性： 多个进程可以同时存在于内存，在一段时间内同时运行。 独立性： 进程是一个能独立运行的基本单位。也是资源分配和调度的独立单位。 异步性： 进程以独立的、不可预知的速度向前推进。 结构性： 每个进程都是由程序段、数据段和一个进程控制块组成。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:1:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 进程和程序的区别 进程是动态的，程序是静态的。程序是有序代码的集合，进程是程序的执行。 进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可长久保存。 进程和程序的组成不同。进程包括程序、数据和进程控制块（即进程状态信息）。 通过多次执行，一个程序可以产生多个进程；通过调用关系，一个进程可以执行多个程序。 进程可以创建其他进程，程序不能形成新的程序。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:1:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 什么是进程实体 程序段、数据段和进程控制块PCB，三部分组成了进程实体，也叫进程映像。 进程实体是静态的。进程是动态的，进程是进程实体的运行过程。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:1:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 常见寄存器 程序状态寄存器PSW。 程序计数器PC。存放下一条指令的地址。 指令寄存器IR。存放当前正在执行的指令。 通用寄存器。可存放计算的中间结果。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:1:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"进程状态 进程具备5种基本状态： 运行态 就绪态 阻塞态 创建态 终止态 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:2:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 运行态 占有CPU，并在CPU上运行。 单核环境中，同时只有一个进程处于运行态。 双核环境中，同时可以有两个进程处于运行态。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:2:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 就绪态 已经具备运行条件，但由于没有CPU，暂时不能运行。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:2:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 阻塞态 用系统调用请求系统资源时，或者等待某一事件发生时，暂时不能运行。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:2:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 创建态 又称新建态。 进程正在被创建。 操作系统会为进程分配资源、初始化PCB。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:2:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 终止态 又称结束态。 进程正在从系统中撤销。 操作系统会回收进程拥有的资源，并且撤销PCB。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:2:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 进程状态转换 进程初始处于创建态。 就绪态 -\u003e 运行态：进程被调度。 运行态 -\u003e 就绪态：时间片到，或CPU被其它高优先级进程抢占。 运行态 -\u003e 阻塞态：通过“系统调用”等待系统资源分配、或等待某事件发生（主动）。 阻塞态 -\u003e 就绪态：资源分配到位，等待的事件发生（被动）。 创建态 -\u003e 就绪态：系统完成创建。 运行态 -\u003e 终止态：运行结束，或发生不可修复错误。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:2:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"进程控制 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 什么是进程控制 进程控制，是指对系统中的所有进程实施有效的管理。包含进程创建、进程撤销、以及进程状态转换等功能。 进程控制依靠原语来实现。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 原语 原语是一种特殊的程序。它的执行具有原子性，即执行期间不允许被中断。 原子性的实现，需要依靠“关中断指令”和“开中断指令”。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程创建原语 申请空白PCB 为进程分配所需资源 初始化PCB 将PCB插入就绪队列 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 进程撤销原语 找到终止进程的PCB。 若进程正在运行，则立即剥夺CPU，将CPU分配给其他进程。 终止其所有子进程。 将该进程资源归还给父进程或操作系统。 删除PCB。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 进程阻塞原语 找到进程对应PCB。 保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程运行。 将PCB插入相应事件的等待列表。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 进程唤醒原语 从事件等待队列中找到PCB。 将PCB从等待队列移除，设置进程为就绪态。 将PCB插入就绪队列，等待被调度。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"7. 进程切换原语 进程切换是指，从运行态到就绪态，或者从就绪态到运行态。 将运行环境存入PCB。 PCB移入相应队列。 选择另一个进程执行，并更新其PCB。 根据PCB恢复进程所需的运行环境。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:3:7","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"进程通信 各进程拥有的内存地址空间相互独立。 为了安全，一个进程不能直接访问另一个进程的地址空间，从而诞生了各种进程通信的方法。 常见的进程通信方法有： 管道 命名管道 共享内存 消息队列 套接字 信号 信号量 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:4:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 管道 包括管道和命名管道。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:4:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 共享内存 Unix操作系统（包括linux）中有Posix内存共享库：shmem。 实现原理是以虚拟文件系统的形式，从内存中划分出一块区域，供两个进程共同使用。 速度快，但是程序实现复杂。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:4:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 消息队列 有本地消息队列，如mqueue。或者基于网络请求实现的消息队列，如kafka，rabbitmq等。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:4:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 网络请求 是套接字方法的一种实现，基于TCP/IP协议或者建立在这之上的通信协议。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:4:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 远程调用 是套接字方法的一种实现，RPC的过程为： 客户端调用函数或者方法。 客户端stub将函数调用封装为请求。 客户端socket发送请求，服务端socket接受请求。 执行服务端方法。 返回结果给服务端stub。 服务端stub将结果封装为返回数据。 服务端socket发送返回数据，客户端socket接受返回数据。 客户端socket将数据传递给客户端stub。 客户端stub把返回数据转义成函数返回值。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:4:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"线程 线程是一个基本的CPU执行单位，也是程序执行流的最小单位。 进程是除CPU之外的系统资源的分配单位。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:5:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 线程特点 线程具有如下特点： 在多核CPU中，线程可以占据不同的CPU。 每个线程都有一个线程ID和一个线程控制块TCB。 线程也有就绪、阻塞和运行状态。 线程几乎不拥有系统资源。 同一进程的不同线程共享进程资源。 同一进程的线程切换，不会引起进程切换。 不同进程的线程切换，会引起进程切换。 同一进程内的线程切换，系统开销很小。 进程切换的系统开销较大。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:5:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 用户级线程 用户级线程介绍： 由应用程序通过线程库实现。 所有的线程管理工作都由应用程序负责（包括线程切换）。 用户线程之间的切换在用户态下完成，无需操作系统的干预。 用户线程对用户不透明，对操作系统透明。 用户线程就是用户视角能看到的线程。 优点： 线程管理的系统开销小，效率高。 缺点： 当一个用户级线程被阻塞后，整个进程都会被阻塞，并且多个用户级线程不可在多核处理机上并行运行，并发度不高。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:5:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 内核级线程 内核级线程介绍： 管理工作由操作系统内核完成，如线程调度、切换等。 内核级线程的切换，必须在内核态下才能完成。 内核级线程就是从操作系统内核视角能看到的线程。 内核级线程才是处理器分配的单位。 优点： 当一个线程被阻塞后，别的线程还可以继续执行，并且多线程可以在多核处理机上并行执行。 缺点： 线程切换由操作系统完成，因此线程管理成本高，开销大。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:5:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"多线程模型 在用户级线程和内核级线程并存的系统中，几个用户线程映射到几个内核级线程的问题，称为“多线程模型”问题。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:6:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 多对一模型 多个用户级线程映射到一个内核级线程。 优点： 用户级线程的切换在用户空间即可完成，不需要切换到和心态，线程管理开销小，效率高。 缺陷： 当一个用户线程被阻塞，整个进程都会被阻塞，并发度不高。 多个线程不可在多核处理机上并行运行。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:6:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 一对一模型 一个用户级线程映射到一个内核级线程。 优点： 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。 多线程可在多核处理机上并行执行。 缺点： 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需切换到和心态，线程管理成本高，开销大。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:6:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 多对多模型 n个用户级线程映射到m个内核级线程(n \u003e= m)。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:6:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"调度 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:7:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 三层调度 高级调度 也称作业调度。按照某种规则，从后备队列中，选择合适的作业，将其调入内存，并为其创建进程。 进程状态变化：无-\u003e创建态-\u003e就绪态。 中级调度 也称内存调度。按照某种规则，从挂起队列中，选择合适进程，将其数据调回内存。 为了提高资源利用率，暂时不执行的进程会被调到外存，从而成为“挂起态”。有“就绪挂起”和“阻塞挂起”。 进程状态变化：阻塞挂起-\u003e阻塞态，或者，就绪挂起-\u003e就绪态。 低级调度 也称进程调度。按照某种规则，从就绪队列中，选择合适进程，为其分配处理机。 进程状态变化：就绪态-\u003e运行态。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:7:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 进程调度的时机 主动放弃处理机： 进程正常终止。 进程发生异常而终止。 进程主动请求阻塞。 被动放弃处理机： 分给进程的时间片用完。 有更紧急的事情，如IO中断。 有更高优先级的进程进入就绪队列。 不能调度的时机： 处理中断时。 进程在操作系统内核程序临界区中。 在原子操作过程中。 临界资源： 一个时间段内，只允许一个进程使用的资源。各进程需要互斥的访问临界资源。 临界区： 用来访问临界资源的那段代码。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:7:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程调度的方式 抢占式调度 只允许进程主动放弃CPU。 实现简单，但是无法及时处理紧急任务。 非抢占式调度 可以优先处理更紧急的进程。 也可以让各进程按时间片轮转。 适合于分时操作系统、实时操作系统。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:7:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 进程切换过程 狭义的进程调度，指的是从就绪队列中选中一个要运行的进程。 进程切换，指一个进程让出处理器，由另一个进程占用处理器的过程。 广义的进程调度，包含选择一个进程和进程切换两个步骤。 进程切换过程如下： 保存原来运行进程的数据 恢复新进程的各种数据 缺陷： 进程切换有代价。 调度、切换过于频繁，会使得整个系统效率降低。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:7:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"调度算法 先来先服务 短作业优先 最短剩余时间算法 高响应比优先 时间片轮转调度算法 优先级调度算法 多级反馈队列调度算法 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 先来先服务算法 思想：按照到达的先后顺序进行服务 是否可抢占：非抢占式 优点：公平，实现简单 缺点：排在长作业/进程后面的短作业/进程要等待很久 是否会导致饥饿：不会 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 短作业优先算法 用于进程时，称为短进程优先。 思想：用时最短的最先得到服务 是否可抢占：是非抢占式算法，但是也有抢占式版本（最短剩余时间优先算法） 优点：更短的平均等待时间和平均周转时间 缺点：对短作业有利，对长作业不利，可能产生饥饿现象；运行时间是用户提供，并不一定能做到真正的短作业优先 是否会导致饥饿：会，长作业可能会长时间得不到服务。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 最短剩余时间优先算法 就绪队列改变时、或者一个进程完成时，进行调度。 如果有新进程剩余时间比当前运行进程剩余时间短，则由新进程抢占处理机，当前进程回到就绪队列。 最短剩余时间优先算法，有最少的平均等待时间，和平均周转时间。 有的书中会说，短作业优先有着最少的平均等待时间，和平均周转时间，其实是不严谨的。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 高响应比优先 响应比计算公式： 响应比 = （等待时间 + 要求服务时间）/（要求服务时间） 思想：每次调度时，计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。 是否可抢占：非抢占式 优点：综合考虑了等待时间和运行时间；对于长作业来说，等待时间越长响应比也会越大，从而避免了饥饿问题 是否会导致饥饿：不会 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 时间片轮转算法 思想：按照进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。如果一个时间片内未执行完，则剥夺处理机，重新放入就绪队列末尾。 是否可抢占：抢占式，由时钟中断来通知 优点：公平，响应快，适合分时操作系统 缺点：进程切换会有一定开销，不区分任务紧急程度 是否会导致饥饿：不会 注意：时间片不能太大，也不能太小 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 优先级调度算法 思想：调度时选择优先级最高的作业/进程。 是否可抢占：抢占式和非抢占式都有。非抢占式在进程主动放弃处理器时进行调度；抢占式还在就绪队列发生变化时，发生调度。 优点：用优先级区分紧急程度，可灵活调整对各进程的偏好程度；适用于实时操作系统 缺点：低优先级进程可能一直得不到执行 是否会导致饥饿：会 通常，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好IO繁忙型进程。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"7. 多级反馈队列调度算法 思想： 设置多级就绪队列，优先级从高到低，时间片从小到大； 新进程先进入第一级队列，按照先到先服务原则被分配时间片； 如果时间片用完还未结束，则进入下一级队列，如果位于最后一级，则重新进入该队列尾部； 第K级队列为空时，才会为K+1级队列分配时间片。 被抢占处理机的进程，重新放回该队列队尾。 是否可抢占：抢占式算法。当K级队列进程运行时，如果前几级队列加入了新进程，新进程会抢占处理机，原来的进程放回原队列的末尾。 是否会导致饥饿：会 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:8:7","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"同步和互斥 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:9:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 什么是同步 异步性，并发执行的进程，以各自独立的、不可预知的速度向前推进。 同步，也称直接制约关系，是协调各进程工作次序而产生的制约关系。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:9:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 什么是互斥 互斥，也称间接制约关系，指一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。 临界资源，是一个时间段内只允许一个进程访问的资源，对临界资源的访问必须互斥的进行。 对临界资源的互斥访问，可在逻辑上分为如下四个部分： 进入区：检查是否可以进入临界区，如果可以进入，则设置正在访问临界资源的标志（上锁），以阻止其他进程同时进入临界区。 临界区：用来访问临界资源的代码。 退出区：解除正在访问临界资源的标志（解锁）。 剩余区：做其他处理。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:9:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程互斥原则 空闲让进：临界区空闲时，允许进程进入临界区。 忙则等待：已有进程进入临界区时，其他试图进入临界区的进程必须等待。 有限等待：对请求访问的进程，保证能在有限时间内进入临界区。 让权等待：当进程不能进入临界区，应立即释放处理机。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:9:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 信号量 信号量机制是实现进程互斥、同步的有效方法。 信号量是一个变量（可以是整数，也可以是记录型变量），用来表示系统中某资源的数量。用户进程可以使用操作系统提供的一对原语，来对信号量进行操作。 这对原语为wait原语和signal原语，wait原语和signal原语常简称为P、V操作。 wait原语用于占用资源，signal用于释放资源，资源不够时，wait原语会进行等待。 资源不够时，整型信号量存在“忙等”问题，不满足“让权等待”。 资源不够时，记录型信号量会让进程变为阻塞态，资源足够时，会被唤醒变为就绪态。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:9:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:10:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁、饥饿、死循环 死锁： 并发环境下，各进程互相等待对方手里的资源，导致进程都阻塞，无法向前推进的现象。 如果有死锁现象，至少是两个或以上进程发生死锁。 死锁一定处于阻塞态。 饥饿： 进程长期得不到想要的资源，从而无法向前推进的现象。 可能只有一个进程发生饥饿。 既可以是阻塞态，也可以是就绪态。 死循环 某进程执行过程中一直跳不出某个循环的现象。 可以处于运行态。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:10:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁产生条件 必须同时满足下列四个条件： 互斥条件：只有对互斥资源发生争抢才会导致死锁。 不可剥夺：资源不能被夺走，只能主动释放。 请求和保持：进程持有至少一个资源，但是又提出新的资源请求，该资源又被其他进程持有，于是请求进程被阻塞，持有资源又不会释放。 循环等待：存在进程资源的循环等待链，每一个进程获得的资源同时被下一个进程请求。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:10:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁处理 预防死锁：破坏死锁产生条件。 避免死锁：防止系统进入不安全状态（银行家算法）。 死锁检测和解除：操作系统检测死锁的发生，然后解除死锁。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:10:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"预防死锁 将互斥资源改为允许共享使用。通常难以实现。 释放持有的资源，以后再重新申请；或者强行剥夺其他进程资源。实现复杂。 运行前一次性申请完所需的资源，运行后这些资源就归它所有。资源利用率低。 给资源编号，进程必须按照编号递增的顺序请求资源。资源利用率低且编程麻烦。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:10:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"避免死锁 安全序列：系统如果按照这种序列分配资源，则每个进程都能顺利完成。 安全状态：只要能找到一个安全序列，系统就是安全状态。 银行家算法：进程提出资源申请时，先预判这次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让进程阻塞等待。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:10:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁检测和解除 死锁检测： 用某种数据结构保存资源的请求和分配信息 用某种算法，根据资源信息判断是否进入了死锁状态 解除死锁： 资源剥夺法：将进程挂起到外存，并抢占它的资源。 撤销进程法：撤销死锁进程，并抢占它的资源。 进程回退法：将死锁进程回退到足以避免死锁的地步。 ","date":"2020-12-04","objectID":"/jin-cheng-he-xian-cheng/:10:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"计算机系统的层次结构 计算机系统的层次结构为： 裸机，纯硬件 操作系统 应用程序 用户 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:1:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"计算机硬件 计算机硬件遵循冯.诺依曼模型，由5部分组成： 运算器。 存储器。 控制器。 输入设备。 输出设备。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:2:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统的概念 操作系统，是裸机上的第一层系统，是对硬件功能的首次扩充。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:3:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统的作用 操作系统的基本作用为： 提供了用户与硬件系统之间的接口。 有效控制和管理计算机系统中硬件和软件资源。 合理组织计算机系统的工作流程。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:4:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统特征 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:5:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"1. 并发性 并发和并行，是两个概念。 并发性，指两个或多个事件，在同一时间间隔内发生。宏观上是同时发生，微观上是交替发生。 并行性，指两个或多个事件，在同一时刻同时发生。 单核CPU，同一时刻只能执行一个程序，多个程序只能并发执行。 多核CPU，同一时刻可以执行多个程序，多个程序可以并行执行。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:5:1","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"2. 共享 共享，是指系统中的资源，可供内存中多个并发执行的进程共同使用。 资源共享方式： 互斥共享方式 一个时间段内，只允许一个进程访问共享资源。 同时共享方式 一个时间段内，允许多个进程同时访问共享资源。同时是宏观上的，微观上可能是交替访问。 并发性和共享性，互为存在条件。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:5:2","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"3. 虚拟 虚拟，是指一个物理实体变为若干个逻辑上的对应物。物理实体是实际存在的，逻辑对应物是用户感受到的。 虚拟性以并发性为前提，如果没有并发性，自然不再需要虚拟性。 虚拟技术： 空分复用技术。如虚拟存储器技术。 时分复用技术。如虚拟处理器。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:5:3","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"4. 异步 多个程序并发执行时，会以不可预知的速度向前推进，进程何时执行，进程间执行的顺序，进程执行所用的时间，都是不确定的，这就是异步性。 并发性是异步性的前提。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:5:4","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统基本功能 操作系统的基本功能包括： 处理器管理 存储器管理 设备管理 文件管理 用户接口 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:6:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统发展 操作系统经历了以下发展阶段： 手工操作阶段。 单道批处理系统。缓解了人机速度矛盾，资源利用率较低。 多道批处理系统。多道程序并发执行，资源利用率高。不提供人机交互。 分时操作系统。提供了人机交互功能，不能区分紧急任务。 实时操作系统。能优先处理紧急的任务。 ","date":"2020-11-16","objectID":"/cao-zuo-xi-tong-ji-ben-gai-nian/:7:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/cao-zuo-xi-tong-ji-ben-gai-nian/"},{"categories":["Linux"],"content":"Linux系统中有多个压缩和归档工具，现在介绍常见的几种。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:0:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"gzip gzip用于压缩一个或多个文件，具体用法为： gzip [options] [file...] ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:1:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"options 常见的选项有： -c：将内容输出到标准输出，不会生成新文件，压缩文件也不会被删除。 -d：解压缩。 -f：即使压缩文件已经存在，也强制压缩。 -h：显示帮助信息。 -l：显示压缩文件列表。 -r：递归压缩或者解压缩包含在目录中的文件。 -t：校验压缩文件完整性。 -v：压缩时显示详细信息。 -k：不删除源文件。 -1：--fast，速度最快的压缩等级。 -2 .. -8：压缩等级，压缩速度从快到慢，压缩比从小到大。 -9：--best，压缩比最高的压缩等级。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:1:1","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"解压缩 gzip生成的压缩文件后缀为.gz。可以使用gzip -d、-gunzip和zcat解压缩。 解压缩时，会自动查找.gz后缀的文件，所以在不引起歧义的情况下，可以省略文件后缀。 zcat命令会将结果输出到标准输出，不会生成新的文件，也不会被删除被解压文件。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:1:2","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"bzip2 bzip2同样可以压缩文件。 除了-r选项，gzip支持的功能bzip2也同样支持。 bzip2生成的压缩文件以.bz2为后缀。 可以使用bzip2 -d、bunzip2和bzcat解压缩，bzcat的作用和zcat也是一样的。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:2:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"gzip和bzip2的使用 已经被压缩过的文件，不应该再次被压缩，即使使用的是不同压缩算法。 因为被压缩文件已经不存在冗余信息，如果进行多次压缩，反而会消耗多余的空间来保存压缩信息。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:3:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"zip zip即可以进行压缩，又可以进行归档。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"命令格式 zip的命令格式为： zip [options] [zipfile [file...]] ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:1","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"options zip的选项参数有很多，现在仅介绍几个常见的： -d：删除归档文件内的指定文件。 -db：显示已经处理的字节，和剩余的字节。 -dc：显示已压缩的条目数，和剩余的条目数。 -e：压缩时使用密码。 -g：向已存在的归档文件追加内容。 -q：不打印任何信息。 -r：递归压缩，如果不指定，则只会压缩一个空目录。 -v：压缩时打印信息，或者显示版本号。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:2","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"解压缩 使用unzip即可对zip归档文件进行解压。 如果使用unzip -l，则只会显示zip归档文件内的包含的文件。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:3","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"tar tar是使用最为普遍的归档工具。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"命令格式 tar的命令格式为： tar function [options] object... ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:1","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"function function参数定义了tar命令应该做什么。常见的命令参数如下： -A：将一个tar归档文件，追加到另一个tar归档文件中。 -c：创建归档文件。 -r：追加文件到归档文件莫问。 -t：列出归档文件的内容。 -x：从已有的归档文件中提取文件。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:2","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"options 常见的options有： -f file：输出到file，或者从file输入。 -j：将输出重定向给bzip2，从而进行压缩。 -p：保留所有文件权限。 -v：处理文件时，显示信息。 -z：将输出重定向到gzip，从而进行压缩。 注意：通常情况下，function参数需要放在options之前。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:3","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"sed编辑器 sed可以根据命令来编辑数据流，大致处理流程为： 从输入读取一行数据。 按照命令对数据进行匹配。 按照命令修改匹配到的数据。 将新的数据输出到STDOUT。 读取下一行数据，并重复上述过程。 数据流读取完毕，则程序终止。 sed命令格式： sed [options] script file options可以是： -e script: 将script中的命令，添加到已有的命令列表。 -f file: 将file中指定的命令，添加到已有的命令列表。 -n：不输出每一行的处理结果。 注意： linux中的sed和mac中的sed，在语法上存在一定差异，本文的测试环境为linux bash4.2。 ","date":"2020-10-05","objectID":"/linux_sed/:1:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"options的使用示例 假设有一个data.txt文件： This is line 1. This is line 2. ","date":"2020-10-05","objectID":"/linux_sed/:2:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 常规命令 $ sed 's/line/number/' data.txt this is number 1. this is number 2. s/line/number/是指，将line替换成number。 ","date":"2020-10-05","objectID":"/linux_sed/:2:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 使用-e $ sed -e 's/line/number/' -e 's/this/This/' data.txt This is number 1. This is number 2. ","date":"2020-10-05","objectID":"/linux_sed/:2:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 使用-f $ cat script.sed s/line/number/ s/this/This/ $ sed -f script.sed data.txt This is number 1. This is number 2. ","date":"2020-10-05","objectID":"/linux_sed/:2:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 使用-n 默认情况下，不论数据行是否满足匹配要求，都会将结果输出。 $ sed -n 's/This/That/' data.txt # 不会有任何输出 ","date":"2020-10-05","objectID":"/linux_sed/:2:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"script的基本语法 ","date":"2020-10-05","objectID":"/linux_sed/:3:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 替换s 可以使用s命令来替换文本，还可以指定替换标记： s/pattern/replacement/[flags] 替换标记是可选的，具体有以下几种： 数字：表明替换第几处匹配的地方，从1开始。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/was/2' data.txt this was line 1. this was line 2. g：替换所有匹配的文本。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/*/g' data.txt th* * line 1. th* * line 2. p：输出被修改后的行，本质上是输出模式空间的内容。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/p' data.txt this is *. this is *. this is line 2. $ sed -n 's/line 1/*/p' data.txt this is *. w file：将替换的结果输出到file。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/w result.txt' data.txt this is *. this is line 2. $ cat result.txt this is *. 替换命令的分隔符/可以换成其他自定义字符： $ cat data.txt this is line 1. this is line 2. $ sed 's,line,number,' data.txt this is number 1. this is number 2. ","date":"2020-10-05","objectID":"/linux_sed/:3:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 行寻址 sed默认作用于所有行，如果想指定行号，命令格式为： [address]command 寻址方式有两种。 数字方式。 指定单个行号： $ sed '2s/line/number/' data.txt this is line 1. this is number 2. 指定地址区间： $ sed '1,2s/line/number/' data.txt this is number 1. this is number 2. $表示最后一行： $ sed '1,$s/line/number/' data.txt this is number 1. this is number 2. 文本模式。 $ sed '/line 2/s/line/*/' data.txt this is line 1. this is * 2. 文本模式是对模式空间内的文本进行匹配。 并且，文本模式可以使用正则表达式，正则表达式的具体语法此处不做说明。 ","date":"2020-10-05","objectID":"/linux_sed/:3:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 命令组合 如果想执行多条命令，可以使用分号分隔。 $ sed '1s/line/number/; 1s/is/*/' data.txt th* is number 1. this is line 2. 可以将命令写成多行。 $ sed ' \u003e 1,$s/line/number/ \u003e 1,$s/is/*/ \u003e ' data.txt th* is number 1. th* is number 2. 也可以使用花括号{}将多条命令组合在一起。 $ sed '1,${s/line/number/ ; s/is/*/}' data.txt th* is number 1. th* is number 2. ","date":"2020-10-05","objectID":"/linux_sed/:3:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 删除d 可以使用删除命令d删除指定行，删除时也可以使用行寻址。 $ sed '1d' data.txt this is line 2. 使用区间寻址时，第一个匹配处打开删除功能，第二个匹配处关闭删除功能。 ","date":"2020-10-05","objectID":"/linux_sed/:3:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 插入i 插入命令i会在指定行前增加一个新行。 $ sed '[address]i\\ new line' data.txt 使用插入命令i时，需要保证新行文本和i位于同一行。如果想分成多行书写，需要使用\\作为结尾。 如果省略address，则是在每行前增加新行。 ","date":"2020-10-05","objectID":"/linux_sed/:3:5","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 追加a 追加命令a会在指定行后增加一个新行。 $ sed '[address]a\\ new line' 新行文本的书写规则，同i。 如果省略address，则是在每行后增加新行。 ","date":"2020-10-05","objectID":"/linux_sed/:3:6","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 修改c 修改命令c可以修改整行的数据内容。 $ sed '2c\\ \u003e this is new line 2' data.txt this is line 1. this is new line 2 如果使用区间寻址，c会对整个区间做替换。 如果省略寻址，则对每行数据做修改。 ","date":"2020-10-05","objectID":"/linux_sed/:3:7","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 转换y 转换命令y可以对单个字符做一对一映射转换。 [address]y/chars1/chars2/ chars1和chars2的长度必须一致，chars1中的字符，会被转换为char2中对应的字符。 $ sed 'y/hijk/HIJK/' data.txt tHIs Is lIne 1. tHIs Is lIne 2. y是一个全局命令，即替换所有匹配的字符结果。 ","date":"2020-10-05","objectID":"/linux_sed/:3:8","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 打印命令p 这是小写p。 打印命令p和替换标记p类似，可以打印匹配到的数据行，即打印当前模式空间的所有数据。 $ sed -n '1p' data.txt this is line 1. ","date":"2020-10-05","objectID":"/linux_sed/:3:9","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"10. 打印行号= 命令=可以打印被匹配数据在文本中的行号。 $ sed '/2/=' data.txt this is line 1. 2 this is line 2. ","date":"2020-10-05","objectID":"/linux_sed/:3:10","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"11. 列出l 列出命令l可以打印匹配数据，包括文本字符和不可打印的转义字符。 $ sed -n '1l' data.txt this is line 1.$ # $是被打印的换行符 ","date":"2020-10-05","objectID":"/linux_sed/:3:11","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"12. 写入命令w w命令可以将匹配数据写入文件。 [address]w filename ","date":"2020-10-05","objectID":"/linux_sed/:3:12","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"13. 读取数据r 读取命令r从文件中读取数据，并将文件的所有数据插入到匹配行后面。 [address]r filename ","date":"2020-10-05","objectID":"/linux_sed/:3:13","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed script进阶语法 假设数据文件data.txt为： this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 模式空间和保持空间 sed在执行命令时，会保存待检查的文本。 保存文本时，需要用到两个缓冲区：模式空间和保持空间。 读到的数据保存在模式空间，而保持空间主要起辅助作用。 与缓冲区有关的命令如下： h: 将模式空间复制到保持空间。 H: 将模式空间追加到保持空间。 g: 将保持空间复制到模式空间。 G: 将保持空间追加到模式空间。 x: 交换模式空间和保持空间的内容。 ","date":"2020-10-05","objectID":"/linux_sed/:4:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 单行数据的next命令 单行next命令会将匹配数据的下一行，移到sed的模式空间，移动前会清空模式空间。 单行命令是n。 注意，如果不存在下一行数据，则模式空间会为空。 $ sed -n '/line 4/{n; p}' data.txt this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 多行数据的next命令 多行next命令，会以追加的方式，将匹配行的下一行添加到模式空间。并且，sed会将模式空间中的数据当成一行处理。 多行命令是N。 注意，如果不存在下一行数据，则模式空间会为空。 $ sed -n '/line 3/{N; p}' data.txt this is line 3. this is line 4. 当要匹配的数据在多行中时，这种语法就能很好的发挥作用。 ","date":"2020-10-05","objectID":"/linux_sed/:4:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 多行删除命令D 多行删除命令D，会删除模式空间中的第一行。 注意，d会删除模式空间中的所有数据。 ","date":"2020-10-05","objectID":"/linux_sed/:4:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 多行打印命令P 多行打印命令（大写P）会打印模式空间中的第一行。 注意，小写的p会打印模式空间中的所有数据。 ","date":"2020-10-05","objectID":"/linux_sed/:4:5","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 排除命令 排除命令!用于将后续命令作用于非匹配行。 $ sed -n '1,2!p' data.txt this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:6","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 分支命令 分支命令b可以用来改变命令的执行流程。 [address]b [label] address用于寻址，label制定了跳转位置，如果省略label，则跳转到命令脚本的结尾。 $ sed '3b ; s/this is line/*/' data.txt * 1. * 2. this is line 3. * 4. * 5. sed ' \u003e 3b start \u003e s/this is line/*/ \u003e :start \u003e s/this is line/jump/ \u003e ' data.txt * 1. * 2. jump 3. * 4. * 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:7","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 测试命令 测试命令t会根据替换命令的结果，来决定是否跳转到某个标签。 如果没有指定标签，则跳转到命令结尾。 sed ' \u003e s/line 3/*/ \u003e t \u003e s/this is line/*/ \u003e ' data.txt * 1. * 2. this is *. * 4. * 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:8","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 匹配模式 \u0026符号代表替换命令中与模式匹配的文本。 $ echo \"The cat sleeps in his hat.\" | sed 's/.at/\"\u0026\"/g' The \"cat\" sleeps in his \"hat\". 也可以提取某个被匹配项。 $ echo \"That furry cat is pretty\" | sed 's/furry \\(.at\\)/\\1/' That cat is pretty ","date":"2020-10-05","objectID":"/linux_sed/:4:9","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed 示例 ","date":"2020-10-05","objectID":"/linux_sed/:5:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 反序输出文本 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. # tac命令可以反序输出 $ tac data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. # sed也可以反序输出 $ sed -n '1!G; h; $p' data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. ","date":"2020-10-05","objectID":"/linux_sed/:5:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 加倍行距 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/^$/d;$!G' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 给文件的行编号 $ nl data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 this is line 4. 5 this is line 5. $ cat -n data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. $ sed '=' data.txt | sed 'N; s/\\n/ /' 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 打印末尾行 # 打印最后10行 $ sed ':start; N; 11,$D; b start' data.txt this is line 5. this is line 6. this is line 7. this is line 8. this is line 9. this is line 10. this is line 11. this is line 12. this is line 13. this is line 14. ","date":"2020-10-05","objectID":"/linux_sed/:5:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 删除文本中的连续空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,/^$/!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:5","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 删除开头空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,$!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:6","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 删除结尾空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed ':start; /^\\n*$/{$d; N; b start}' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:7","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"在Linux环境中，查看目录或文件的磁盘空间大小是很常见的需求，使用du命令即可帮助我们达到该目的。 ","date":"2020-07-09","objectID":"/linux-du/:0:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"命令格式 du [选项] [文件或者目录] ","date":"2020-07-09","objectID":"/linux-du/:1:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"选项 常用的可选参数为： -a: --all，列出所有文件和目录的容量大小（默认只列出目录容量的大小）。 -h: 以已读的形式显示。 -B：--block-size=SIZE，指定容量的单位值，size可以是1，k，或者m，如-B1。 -k：--block-size=1k，以KB为单位。 -m：--block-size=1m，以MB为单位。 -c：--total，额外显示总的容量大小。 -s：仅显示总量大小。 --max-depth：显示指定层级的目录。 --exclude=\u003c文件或目录\u003e：忽略指定目录或文件。 ","date":"2020-07-09","objectID":"/linux-du/:2:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"示例 显示当前目录及子目录大小 du 显示指定文件所占空间 du filename 仅显示当前目录所占空间大小 du --max-depth=1 仅显示当前目录总的容量大小 # 使用 -s du -sh # 使用--max-depth du -h --max-depth=0 ","date":"2020-07-09","objectID":"/linux-du/:3:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"du和ls -l 除了可以使用du查看目录或文件大小外，还可以使用ls -l查看文件或目录的大小，但是二者获得的结果有所差异。 ls -l的结果小于du的结果 du是文件占用block的大小，在linux中，一个block的大小为4k。而ls -l是文件的实际大小，所以即使文件只有1bytes，du获得的结果也会是4k。 ls -l的结果大于du的结果 当文件出现空洞的时候会出现这种结果，即磁盘空间被占用，但是里面没有数据。 ","date":"2020-07-09","objectID":"/linux-du/:4:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["MySQL"],"content":"概念 DB 数据库（database)：存储数据的仓库。它保存了一系列有组织的数据。 DBMS 数据库管理系统（database management system）。数据库是通过DBMS创建和操作的容器。 SQL 结构化查询语言（structure query language）:专门用来与数据库通信的语言。 ","date":"2020-06-17","objectID":"/mysql_grammer/:1:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"存储数据的特点 一个数据库可以有多个表，每个表有一个名字。表名具有唯一性。 表具有一些特性，这些特性定义了数据在表中如何存储。 表由列组成，列也称为字段。 表中的数据是按行存储的。 ","date":"2020-06-17","objectID":"/mysql_grammer/:2:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL分类 DDL: 数据定义语言，用来定义数据库对象（库、表、列等）。 DML: 数据操作语言，用来定义数据库记录（增、删、改）。 DCL: 数据控制语言，用来定义访问权限和安全级别。 DQL: 数据查询语言，用来查询记录。 ","date":"2020-06-17","objectID":"/mysql_grammer/:3:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"rpm安装mysql rpm -ivh rpm软件名 ","date":"2020-06-17","objectID":"/mysql_grammer/:4:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"Mysql核心目录 1. 分类 /var/lib/mysql：安装目录 /usr/share/mysql：配置文件 /usr/bin：命令目录（mysqladmin、mysqldump等） /etc/init.d/mysql：启动脚本 2. 配置文件 my-huge.cnf：高端服务器 my-large.cnf：中等规模 my-medium.cnf：一般 my-small.cnf：较小 以上配置文件默认不能识别，mysql5.5默认只能识别 /etc/my.cnf，mysql5.6默认识别 /etc/mysql-default.cnf。 ","date":"2020-06-17","objectID":"/mysql_grammer/:5:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"mysql字符编码 1. 查看语法 showvariableslike'%char%'; 2. 设置编码 修改/etc/my.cnf [mysql] default-character-set=utf8 [client] default-character-set=utf8 [mysqld] character_set_server=utf8 character_set_client=utf8 collation_server=utf8_general_co 修改编码，只对之后创建的数据库生效。 ","date":"2020-06-17","objectID":"/mysql_grammer/:6:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查看表的结构 1. 语法 DESCname; 或者： SHOWCOLUMNSFROMtablename; 或者： SHOWCREATETABLEtablename; ","date":"2020-06-17","objectID":"/mysql_grammer/:7:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查询语句 1. 语法 select查询列表from表名; 2. 执行顺序： from子句 select子句 3. 查询列表： 字段 SELECT`last_name`FROM`employees` 表达式 SELECT100%3; 常量 SELECT100; 函数等 SELECTDATABASE();SELECTVERSION();SELECTUSER(); 4. 起别名 使用as关键字 SELECTUSER()as\"username\"; 使用空格 selectuser()username; 5. mysql中+的作用 如果两个数都是数值型，则直接相加。 如果其中一个操作数为字符型，则将字符型转换成数值型。如果无法转换，则直接当作0处理。 其中一个操作数为null，结果为null。 6. distinct函数 SELECTDISTINCTfieldFROMtablename 7. ifnull函数 语法： ifnull(表达式1,表达式2) 功能： 如果表达式1为null，则显示表达式2，否则显示表达式1。 ","date":"2020-06-17","objectID":"/mysql_grammer/:8:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"条件查询 1. 语法 select查询列表from表名where筛选条件； 2. 执行顺序 from子句。 where子句。 select子句。 3. 筛选条件 按关系表达式筛选：\u003c、\u003e、\u003e=、\u003c=、=、\u003c\u003e，也可以使用 != 但是不建议，ANSI标准中用的是\u003c\u003e。 按逻辑表达式筛选：and、or、not，也可以使用 \u0026\u0026、||、! 但是不建议。 模糊查询：like、in、between ... and ...、is null。 4. 示例 查询部门编号不是 50 ~ 100 之间员工的姓名: selectnamefromemployeeswheredepartment_id\u003c50ordepartment_id\u003e100; 查询姓名中包含字符a的员工。 select*fromemployeeswherenamelike'%a%'; 查询姓名最后一个字符为a的员工。 select*fromemployeeswherenamelike'%a'; 查询姓名第一个字符为a的员工。 select*fromemployeeswherenamelike'a%'; 查询姓名中第三个字符为a的员工。 select*fromemployeeswherenamelike'___a%';# 有三个下划线_ 查询姓名中第二个字符为_的员工信息。 select*fromemployeeswherenamelike'_\\_%';# 或者 # select * from employees where name like '_$_%' escape '$'; 查询部门编号是30/50/90的员工名 selectnamefromemployeeswheredepartmentin(30,50,90); 查询部门编号是30～90之间的员工姓名 selectnamefromemployeeswheredepartmentbetween30and90; 查询部门编号不是30～90之间的员工姓名 selectnamefromemployeeswheredepartmentnotbetween30and90; ","date":"2020-06-17","objectID":"/mysql_grammer/:9:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"排序查询 1. 语法 select查询列表from表名where筛选条件orderby排序列表 2. 执行顺序 from子句 where子句 select子句 order by子句 3. 说明 排序列表可以是单个字段、多个字段、表达式、函数、列数、以及以上的组合。 默认升序asc，降序desc 4. 示例 将员工按照工资降序 select*fromemployeesorderbysalarydesc; 按姓名长度进行升序 selectnamefromemployeesorderbylength(name); 查询员工信息，先按工资升序、再按部门将序 select*fromemployeesorderbysalaryasc,departmentdesc; 按照列数进行排序 select*fromemployeesorderby2desc; ","date":"2020-06-17","objectID":"/mysql_grammer/:10:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"常见函数 1. 分类 字符函数 数学函数 日期函数 流程控制函数 2. 字符函数 concat拼接字符 selectconcat(\"hello\",name)fromuser; LENGTH获取字节长度 selectlength(\"hello,少年\"); CHAR_LENGTH获取字符长度 SELECTCHAR_LENGTH(\"hello,少年\"); SUBSTR截取子串 SELECTSUBSTR('少年你好骚啊',1,2);# SELECT SUBSTR('你好骚啊少年',5); INSTR获取字符第一次出现的索引 SELECTINSTR('孙悟空三打白骨精','白骨精'); TRIM去除前后指定字符，默认去空格 SELECTTRIM(' 空 格 ')asresult; SELECTTRIM('x'FROM'xxx空xxx格xxx')asresult; LPAD/RPAD左填充/右填充 # 左填充满10个字符 SELECTLPAD('木婉清',10,'a');# 右填充满10个字符 SELECTRPAD('木婉清',10,'a'); UPPER/LOWER变大写/变小写 STRCMP比较两个字符大小 SELECTSTRCMP('abc','acb') LEFT/RIGHT截取子串 SELECTLEFT('洪世贤',1); 3. 数学函数 ABS绝对值 SELECTABS(-1.1); CELL向上取整，返回大于等于该参数的最小整数 SELECTCELL(1.09); FLOOR向下取整，返回小于等于该参数的最大整数 SELECTFLOOR(-1.09); ROUND四舍五入 SELECTROUND(1.8765); TRUNCATE截断 SELECTTRUNCATE(1.8765,1);# 位数不够用0补齐 MOD取余，实质上 a % b = a - a/b*b。 SELECTMOD(-10,3);# SELECT -10%3; # SELECT 10%3; # SELECT -10%-3; # SELECT 10%-3; 4. 日期函数 NOW SELECTNOW(); CURDATE SELECTCURDATE(); CURTIME SELECTCURTIME(); DATEDIFF SELECTDATEDIFF('1998-7-16','2019-7-13'); DATE_FORMAT SELECTDATE_FORMAT('1998-7-16','%Y年%M月%d日 %H小时%i分钟%s秒'); STR_TO_DATE SELECTSTR_TO_DATE('3/15 1998','%m/%d %Y'); 5. 流程控制函数 IF函数 SELECTIF(100\u003e9,\"好\",\"坏\"); CASE函数 CASE表达式WHEN值1THEN结果1WHEN值2THEN结果2...ELSE结果nEND 或者 CASEWHEN条件1THEN结果1WHEN条件2THEN结果2...ELSE结果NEND ","date":"2020-06-17","objectID":"/mysql_grammer/:11:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分组函数 1. 说明 往往用于实现将一组数据进行统计计算，最终得到一个值，又称为聚合函数或者统计函数。 2. 列表 sum(字段名): 求和 avg(字段名): 求平均数 max(字段名): 求最大值 min(字段名): 求最小值 count(字段名): 计算非空字段值的个数 3. 补充说明 count(*)用于查询总行数。 count(1)作用类似于count(*)，但是效率较低。 count()搭配distinct做去重统计，如 selectcount(distinctdepartment)fromemployees; 4. 示例 查询员工信息表中，所有员工的工资和、平均工资值、最低工资、最高工资、有工资的个数。 selectsum(salary),avg(salary),min(salary),max(salary),count(salary)fromemployees; ","date":"2020-06-17","objectID":"/mysql_grammer/:12:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分组查询 需要使用group by子句。 1. 语法 select查询列表from表名where筛选条件groupby分组列表having分组后筛选orderby排序列表; 2. 执行顺序 from子句 where子句 group by子句 having子句 select子句 order by子句 3. 说明 查询列表往往是分组函数和被分组的字段。 分组前筛选，基于原始表，使用where，位于group by前面。 分组后筛选，基于分组后的结果集，使用having，位于group by后面。 4. 示例 查询每个工种员工平均工资 selectavg(salary),job_idfromemployeesgroupbyjob_id; ","date":"2020-06-17","objectID":"/mysql_grammer/:13:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"连接查询 1. 说明 又成多表查询，当查询的字段来自于多个表时，就会用到连接查询。 2. sql连接查询分类 年代： sql92标准：mysql仅仅支持内连接 sql99标准：mysql支持内连接+外连接（左外和右外）+交叉连接 功能： 内连接：等值连接、非等值连接、自连接 外连接：左外连接、右外连接、全外连接 交叉连接 ","date":"2020-06-17","objectID":"/mysql_grammer/:14:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql92内连接 1. 语法 select查询列表from表名1别名1,表名2别名2...where连接条件 2. 说明 为了解决多表字段重名，可以为表起别名。 表的顺序无要求。 n表连接，至少需要n-1个连接条件。 3. 示例 等值连接：查询部门编号\u003e100的部门名和所在的城市名。 SELECT`department_name`,`city`FROMdepartmentsd,locationslWHEREd.`location_id`=l.`location_id`ANDd.`department_id`\u003e100; 非等值连接：查询员工的工资和工资级别。 SELECTsalary,grade_levelFROMemployeese,job_gradesgWHEREsalaryBETWEENg.`lowest_sal`ANDg.`highest_sal`; 自连接：查询员工名和上级的名称。 SELECTe.employee_id,e.last_name,m.employee_id,m.last_nameFROMemployeese,employeesmWHEREe.`manager_id`=m.`employee_id`; ","date":"2020-06-17","objectID":"/mysql_grammer/:15:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql99内连接 1. 语法 SELECT查询列表FROM表明1别名[INNER]JOIN表明2别名ON连接条件WHERE筛选条件GROUPBY分组列表HAVING分组后筛选ORDERBY排序列表; 2. 说明 使用关键字JOIN代替了逗号，连接条件和筛选条件进行了分离。 3. 示例 查询员工名和部门名 SELECTlast_name,department_nameFROMemployeeseJOINdepartmentsdONe.department_id=d.department_id; 查询部门编号\u003e100的部门名和所在的城市名 SELECTdepartment_name,cityFROMdepartmentsdJOINlocationslONd.`location_id`=l.`location_id`WHEREd.`department_id`\u003e100; 查询部门中员工个数\u003c10的部门名，并按照员工个数降序 SELECTCOUNT(*)员工个数,d.department_nameFROMemployeeseJOINdepartmentsdONe.`department_id`=d.`department_id`GROUPBYd.`department_id`HAVING员工个数\u003e10ORDERBY员工个数DESC; 查询部门员工的工资级别，并按照级别进行分组 SELECTCOUNT(*)个数,g.gradeFROMemployeeseJOINsal_gragegONe.`salary`BETWEENg.`min_salary`ANDg.`max_salary`GROUPBYg.grade 查询员工名和对应的领导名 SELECTe.`name`,m.`name`FROMemployeeseJOINemployeesmONe.`manager_id`=m.`employee_id` ","date":"2020-06-17","objectID":"/mysql_grammer/:16:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL99外连接 1. 说明 查询结果为主表中所有的记录，如果从表有匹配项，则显示匹配项；如果从表没有匹配项，则显示null。 一般用于查询主表中有但从表中没有的记录。 外连接主从表的顺序不可随意改变。 左连接的主表在左边。 右连接的主表在右边。 2. 语法 select查询列表from表1别名left|right|full[outer]join表2别名on连接条件where筛选条件; ","date":"2020-06-17","objectID":"/mysql_grammer/:17:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"子查询 1. 定义 当一个查询语句中，又嵌套了另一个完整的select语句，则被嵌套的语句称为子查询或内查询。 外面的语句称为主查询或外查询。 2. 说明 子查询不一定必须出现在select子句中，只是这种情况比较常见。 子查询放在条件中，要求必须出现在条件右侧 子查询一般放在小括号中 单行子查询对应了单行操作符：\u003e, \u003c, \u003e=, \u003c=, =, \u003c\u003e 多行子查询对应了多行操作符：any, some, all, in（some和any的用法一致） 3. 分类 按出现位置： select后面：子查询结果必须单行单列（标量子查询） from后面：子查询结果可以多行多列 where或者having后面：子查询的结果必须为单列 4. 示例 查询和Tom同部门的员工姓名和工资 SELECTname,salaryFROMemployeesWHEREdepartment_id=(SELECTdepartment_idFROMemployeesWHEREname='Tome'); 查询部门编号是50的员工个数 SELECT(SELECTCOUNT(*)FROMemployeesWHEREdepartment_id=50)个数; 查询有无名字叫\"TOM\"的员工信息 SELECTEXISTS(SELECT*FROMemployeesWHEREname=\"TOM\")有无; ","date":"2020-06-17","objectID":"/mysql_grammer/:18:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql99交叉连接 1. 语法 select查询列表from表1别名1crossjoin表2别名2where筛选条件; 或者 select查询列表from表1别名,表2别名,...where筛选条件; ","date":"2020-06-17","objectID":"/mysql_grammer/:19:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分页查询 1. 语法 select查询列表from表1别名join表2别名on连接条件where筛选条件groupby分组having分组后筛选orderby排序列表limit起始条目索引，条目数 2. 执行顺序 from -\u003e on -\u003e join -\u003e where -\u003e group by -\u003e having -\u003e select -\u003e order by -\u003e limit 3. 说明 起始条目索引从0开始，缺省则默认为0 4. 示例 查询员工信息表的前5条 SEELCT*FROMemployeesLIMIT5;# 等价于 # SELECT * FROM employees LIMIT 0,5; ","date":"2020-06-17","objectID":"/mysql_grammer/:20:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"联合查询 1. 说明 当查询结果来自于多张表，但多张表之间没有关联，这时可用联合查询，也称union查询。 union自动去重 union all可以支持重复项 多条待联合的查询语句，查询列数必须一致，类型、字段最好一致 2. 语法 select查询列表from表1where筛选条件unionselect查询列表from表2where筛选条件 3. 示例 查询所有国家的年龄\u003e20的用户信息 SELECT*FROMchineseWHEREage\u003e20UNIONSELECT*FROMusaWHEREuage\u003e20; 查询所有国家的用户姓名和年龄 SELECTuname,uageFROMusaUNIONSELECTage,`name`FROMchinese; ","date":"2020-06-17","objectID":"/mysql_grammer/:21:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"DDL语言 1. 说明 DDL: （Data Define Language）数据定义语言，用于对数据库和表的管理和操作。 2. 库管理 创建数据库 CREATEDATABASE库名;# CREATE DATEBASE IF NOT EXISTS 库名; # 如果不存在则创建 删除数据库 DROPDATABASE库名;# DROP DATABASE IF EXISTS 库名; # 如果存在则删除 3. 表管理 创建表 语法： CREATETABLE[IFNOTEXISTS]表名(字段名字段类型[字段约束]，......字段名字段类型[字段约束],字段名字段类型[字段约束]); 示例： CREATETABLEstuinfo(stuidINT,stunameVARCHAR(20),stugenderCHAR,emailVARCHAR(20),ageINT,majoridINT,CONSTRAINTfk_stuinfo_majorFOREIGNKEY(majorid)REFERENCESmajor(id)); 修改表 修改表名： ALTERTABLE原表名RENAMETO新表名; 修改表字段： ALTERTABLE表名ADD|MODIFY|CHANGE|DROPCOLUMN字段名字段类型字段约束; 示例： ALTERTABLEstuinfoRENAMETOstudents; ALTERTABLEstudentsADDCOLUMNdorndateTIMESTAMPNOTNULL; ALTERTABLEstudentsCHANGECOLUMNborndatebirthdayDATETIMENULL; ALTERTABLEstudentsMODIFYCOLUMNbirthdayTIMESTAMP; ALTERTABLEstudentsDROPCOLUMNbirthday; 删除表 DROPTABLEIFEXISTStablename; 复制表 CREATETABLEtablename1LIKEtablename2;# 仅复制表结构 CREATETABLEtablename1SELECT*FROMtablename2;# 复制结构和数据 示例： CREATETABLEempSELECTnameFROMemployeesWHERE1=2; ","date":"2020-06-17","objectID":"/mysql_grammer/:22:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"常用字段类型 1. int 整形：TYNYINT, SMALLINT, INT, BIGINT。 2. double/float 浮点型，例如double(5, 2)表示最多5位，其中有且仅有2位小数，即最大值为999.99 3. decimal 浮点型，表示钱时使用该类型，不会出现精度问题 4. char 固定长度字符串类型；内容范围是0~255字节； char(n)：n参数默认为1，不管实际存储，开辟空间都是n个字符，效率高。 5. varchar 可变长度字符串类型；内容范围为0~65535字节； varchar(n)最大字符个数必选，根据实际存储空间决定开辟空间，效率低。 实际占用空间为：字符实际空间 + 1，且字符实际空间 + 1 \u003c= n。 6. text 字符串类型，通常存储较长文本。 7. blob 字节类型；常用于jpg, mp3, avi。 8. date 日期类型；格式为yyyy-MM-dd 9. time 时间类型；格式为hh:mm:ss 10. timestamp/datetime 时间戳类型；格式为yyyyMMdd hhmmss； timestamp保存范围1900-1-1~xxxx年，占用8字节； datetime保存范围1970-1-1~2038-12-31，占用4字节。 ","date":"2020-06-17","objectID":"/mysql_grammer/:23:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"常见字段约束 1. 说明 用于限制表中字段的数据； 2. 列表 NOT NULL 非空；用于限制该字段为必填项； DEFAULT 默认；如果该字段没有插入值，则显示默认值； PRIMARY KEY 主键；用于限制该字段的值不能重复；设为主键列的字段默认不能为空； ALTERTABLEtbl_nameADDPRIMARYKEY(column_list); UNIQUE 唯一；限制该字段不能重复；该字段可以为空； CHECK 检查；限制该字段值必须满足指定条件；mysql不支持； FOREIGN KEY 外键；限制两个表的关系；外键列的值必须来自主表的关联列；主表关联列和从表关联列类型必须一致，意思一样，名称无要求；主表的关联列要求必须是主键； 定义外键： altertableteblenameaddconstraint外键名foreignkey(列名)references表名（关联列）; 或者： createtableteblename(...constraint外键名foreignkey(列名)references表名(关联列)); 删除外键： altertabletablenamedropforeignkey键名 ","date":"2020-06-17","objectID":"/mysql_grammer/:24:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"设置自增长列 1. 关键字 AUTO_INCREMENT 2. 说明 自增长列必须设置在一个键上，比如主键或唯一键。 自增长列要求数据类型为数值型。 一个表至多有一个自增长列。 ","date":"2020-06-17","objectID":"/mysql_grammer/:25:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"DML DML: (Data Manipulation Language) 数据操作语言 插入数据 修改数据 删除数据 ","date":"2020-06-17","objectID":"/mysql_grammer/:26:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"插入数据 1. 语法 插入单行 insertinto表名(字段名1，字段名2，......)values(值1，值2，......); 插入多行 insertinto表名（字段名1，字段名2，......)values(值1，值2，......),(值1，值2，......)...; 2. 说明 字段和值列表一一对应。 数值型值不用单引号，非数值型值必须使用单引号。 3. 示例 INSERTINTOstuinfo(stuid,stuname,stugender,email,age,majorid)VALUES(1,'TOm','男','tom@gmail.com',12,1); ","date":"2020-06-17","objectID":"/mysql_grammer/:27:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"修改数据 1. 语法 修改单表： update表名set列=新值,列=新值,...where筛选条件; 修改多表，sql92语法： update表名1别名，表名2别名set列=值,...where连接条件and筛选条件; 修改多表，sql99语法： update表1别名inner|left|rightjoin表2别名on连接条件set列=值,...where筛选条件; ","date":"2020-06-17","objectID":"/mysql_grammer/:28:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"删除数据 1. 语法 delete语句： deletefrom表名where筛选条件; truncate语句: truncatetable表名; 2. delete和truncate的区别： delete可以添加where条件，truncate不能添加where条件，一次性清除所有数据。 truncate的效率较高。 如果删除带自增长列的表；使用delete删除后，重新插入数据时，记录从断点处开始；使用truncate删除后，重新插入数据时，记录从1开始。 delete删除数据时，会返回受影响的行数；truncate删除数据时，不会返回受影响的行数。 delete删除数据时，可以支持事务回滚；truncate删除数据时，不支持事务回滚。 ","date":"2020-06-17","objectID":"/mysql_grammer/:29:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"事务 1. 概念： 一个事务是由一条或者多条sql语句构成，这一条或者多条sql语句，要么全部执行成功，要么全部执行失败。 2. 四大特性： 原子性 (atomicity)：事务中所有操作是不可再分割的原子单位。事务中所有操作要么全部执行成功，要么全部执行失败。 一致性 (consistency)：事务执行后，数据库状态与业务规则保持一致。如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。 隔离性 (isolation)：在并发操作中，不同事务之间应该隔离开来，使每个并发中的事务不会相互干扰。 持久性 (durability)：一旦事务提交成功，事务中所有的数据操作都必须被持久化到数据库。即使提交事务后，数据库马上崩溃，在数据库重启时，也能通过某种机制恢复数据。 3. 分类 隐式事务：没有明显的开启和结束标记 显式事务：具有明显的开启和结束标记 步骤：取消隐式事务自动开启的功能 =\u003e 开启事务 =\u003e 编写事务语句 =\u003e 结束事务 4. 示例 #取消事务自动开启 SETautocommit=0;#开启事务 有的客户端不用加这句 STARTTRANSACTION;#更新数据 UPDATEstuinfoSETbalance=balance-5000wherestuid=1;UPDATEstuinfoSETbalance=balabce+5000wherestuid=2;#提交 COMMIT;#或者回滚 #ROLLBACK; ","date":"2020-06-17","objectID":"/mysql_grammer/:30:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"数据库的隔离级别 1. 说明 对于同时运行的多个事务，当这些事务访问数据库中相同的数据时，如果没有采取必要的隔离机制，就会导致各种并发问题： 脏读：对于两个事务T1和T2，T1读取了已经被T2更新但还没有被提交的字段，若之后T2回滚，T1读取的内容就是临时且无效的。 不可重复读：对于两个事务T1和T2，T1读取了一个字段，然后T2更新了该字段，之后T1再次读取同一个字段，获得的值就不同了。 幻读：对于两个事务T1和T2，T1从一个表中根据某些条件读取出一些记录，然后T2向该表插入了符合条件的新纪录，T1再次读取时，就会把新纪录也读出来。 一个事务与其他事务隔离的程度称为隔离级别。不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。 ","date":"2020-06-17","objectID":"/mysql_grammer/:31:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"数据的4种隔离级别 1. 隔离级别说明 读未提交数据(READ UNCOMMITTED)：允许事务读取未被其他事务提交的变更。脏读，不可重复读和幻读的问题都会出现。 读已提交数据(READ COMMITTED)：只允许事务读取已经被其他事务提交的变更。可以避免脏读，但不可重复读和幻读问题仍然会出现。 可重复读(REPEATABLE READ)：确保事务可以多次从一个字段中读取相同的值，但这个事务持续期间，禁止其他事务对这个字段进行更新。可以避免脏读和不可重复读，但幻读的问题仍然存在。 串行化(SERIALIZABLE)：确保事务可以从一个表中读取相同的行，在这个事务持续期间，禁止其他事务对该表执行插入、更新和删除操作，所有并发问题都可以避免，但性能十分低下。 2. Oracle支持的事务隔离级别： READ COMMITED（默认） SERIALIZABLE 3. Mysql支持的事务隔离级别 READ UNCOMMITTED READ COMMITTED REPEATABLE READ（默认） SERIALIZABLE ","date":"2020-06-17","objectID":"/mysql_grammer/:32:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"MySql设置隔离级别 1. 说明 每启动一个mysql客户端程序，就会获得一个单独的连接，每个连接都有一个变量@@tx_isolation表示当前的事务隔离级别。 2. mysql查看当前连接的隔离级别 select@@tx_isolation; 3. mysql修改当前连接的隔离级别 当前连接的隔离级别不会影响到其他连接。 setsessiontransactionisolationlevelreaduncommitted; 4. mysql设置数据库系统全局的隔离级别 需要重新打开mysql会话，设置才会生效。 setglobaltransactionisolationlevelreadcommitted; ","date":"2020-06-17","objectID":"/mysql_grammer/:33:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SAVEPOINT 1. 说明 只能搭配rollback使用 2. 示例 SETautocommit=0;DELETEFROMaccountWHEREid=25;SAVEPOINTa;DELETEFROMaccountWHEREid=28;ROLLBACKTOa; ","date":"2020-06-17","objectID":"/mysql_grammer/:34:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"视图 1. 含义 虚拟表，和普通表一样使用。 mysql5.1版本之后出现的新特性。 行和列的数据，来自定义视图时的查询中使用到的表，并且是在使用视图时动态生成的。 只保存了sql逻辑，不保存查询结果。 2. 应用场景 多个地方用到同样的查询结果。 该查询结果使用的sql语句较复杂。 ","date":"2020-06-17","objectID":"/mysql_grammer/:35:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"创建视图 1. 语法 createview视图名as查询语句; 2. 示例 查询邮箱中包含a字符的员工名、部门名和工种信息。 #创建视图 CREATEVIEWmyv1ASSELECTname,department,titleFROMemployeeseJOINdepartmentsdONe.department_id=d.department_idJOINjobsjONj.job_id=e.job_id;#使用视图 SELECT*FROMmyv1WHEREnameLIKE\"%a%\"; 查询各部门的平均工资级别 #创建视图 CREATEVIEWmyv2ASSELECTAVG(salary)ag,department_idFROMemployeesGROUPBYdepartment_id;#使用 SELECTmyv2.`ag`,g.grade_levelFROMmyv2JOINjob_gradesgONmyv2.`ag`BETWEENg.`lowest_sal`ANDg.`highest_sal`; ","date":"2020-06-17","objectID":"/mysql_grammer/:36:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"修改视图 1. 语法 方式一： createorreplaceview视图名as查询语句; 方式二： alterview视图名as查询语句; ","date":"2020-06-17","objectID":"/mysql_grammer/:37:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"删除视图 1. 语法 dropview视图名，视图名......; ","date":"2020-06-17","objectID":"/mysql_grammer/:38:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查看视图 1. 语法 desc视图名; 或者 showcreateview视图名; ","date":"2020-06-17","objectID":"/mysql_grammer/:39:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"视图内容的更新 1. 插入 同表的插入语法一致。 会更新原始表。 2. 修改 同表的修改语法一致。 会更新原始表。 3. 删除 使用delete语法。 会更新原始表。 4. 说明 视图的可更新性和视图中查询的定义有关系，以下类型的视图不能更新： 包含关键字：分组函数、distinct、group by、having、union、union all 常量视图 select子句中包含子查询 join（某些条件下可更新） from一个不能更新的视图 where子句的子查询引用了from子句中的表 ","date":"2020-06-17","objectID":"/mysql_grammer/:40:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"变量 1. 系统变量 全局变量 会话变量 2. 自定义变量 用户变量 局部变量 ","date":"2020-06-17","objectID":"/mysql_grammer/:41:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"系统变量 1. 含义 变量由系统提供，属于服务器层面。 2. 语法 查看所有的系统变量 showglobal|[session]variables; 查看满足条件的部分系统变量 showglobal|[session]variableslike'%char%'; 查看指定的某个系统变量的值 select@@global.|[session.]系统变量名; 为某个系统变量赋值 setglobal|[session]系统变量名=值; 或者 set@@global.|[session.]系统变量名=值; 3. 注意 如果是全局级别，需要使用global 如果是会话级别，需要加session或者什么都不加 全局变量不能跨重启，即服务器重启后变量值恢复默认 ","date":"2020-06-17","objectID":"/mysql_grammer/:42:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"自定义变量 1. 含义 用户自定义的，不是系统提供的。 2. 用户变量 作用域：当前会话（连接）有效。 声明并初始化： set @变量名=值; 或者 set @变量名:=值; 又或者 select @变量名:=值; 赋值： set@变量名=值;set@变量名:=值;select@变量名:=值; 或者 select字段into@变量名from表; 使用 select@变量名; 3. 局部变量 作用域：仅仅在定义它的begin end中有效 声明： declare变量名类型; 或者 declare变量名类型default值; 赋值： set变量名=值;set变量名:=值;select@变量名:=值; 或者 select字段into变量名from表; 使用： select变量名; 应用： begin中的第一句话。 ","date":"2020-06-17","objectID":"/mysql_grammer/:43:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"存储过程 1. 好处 提高了代码的重用性 简化操作 减少了编译次数，减少了和服务器的连接次数，提高了效率 2. 含义 一组预先编译好的sql语句的集合。 3. 创建 createprocedure过程名(参数列表)begin存储过程体end 注意： 参数列表包含三部分：参数模式、参数名、参数类型 参数模式： IN：输入 OUT：输出 INOUT：输入和输出 如果存储过程体只有一句话，begin、end可以省略。 存储过程体每句都以分号结束。 存储过程体的结尾使用delimiter重新设置。 4. 调用 call存储过程名(实参列表); 5. 删除 DROPPROCEDURE过程名; 6. 查看 SHOWCREATERPROCEDURE过程名 7. 修改 存储过程无法修改。 8. 示例 无参 #定义 DELIMITER$CREATEPROCEDUREmyp1()BEGININSERTINTOadmin(username,`password`)VALUES('john1','0000'),('lily','0000');END$#调用 CALLmyp1()$ IN DELIMITER$CREATEPROCEDUREmyp2(INbeautyNameVARCHAR(20))BEGINSELECTbo.*FROMboysboRIGHTJOINbeautybONbo.id=b.boyfriend_idWHEREb.name=beautyNameEND$ IN #定义 DELIMITER$CREATEPROCEDUREmyp4(INusernameVARCHAR(20),INPASSWORDVARCHAR(20))BEGINDECLAREresultINTDEFAULT0;SELECTCOUNT(*)INTOresultFROMadminWHEREadmin.username=usernameANDadmin.password=PASSWORD;SELECTIF(result\u003e0,'成功','失败');END$#调用 CALLmyp4('张飞','8888')$ OUT #定义 DELIMITER$CREATEPROCEDUREmyp5(INbeautyNameVARCHAR(20),OUTboyNameVARCHAR(20))BEGINSELECTbo.boyNameINTOboyNameFROMboysboINNERJOINbeautybONbo.id=b.boyfriend_idWHEREb.name=beautyName;END$#调用 [SET@bName$]CALLmyp5('小昭',@bName)$SELECT@bName$ INOUT #定义 DELIMITER$CREATEPROCEDUREmyp6(INOUTaINT,INOUTbINT)BEGINSETa=a*2SETb=b*2END$#调用 SET@m=10$SET@n=20$CALLmyp6(@m,@n)$ ","date":"2020-06-17","objectID":"/mysql_grammer/:44:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"函数 函数和好处同存储过程。 1. 说明 有且仅有一个返回。 2. 创建 CREATEFUNCTION函数名（参数列表）RETURNS返回类型BEGIN函数体END 注意： 参数列表包含两部分：参数名 参数类型。 函数体中必须包含return。 函数体仅有一句话，则可以省略begin和end。 使用delimiter语句设置结束标记。 2. 调用 SELECT函数名（参数列表） 3. 查看函数 SHOWCREATEFUNCTION函数名; 4. 删除函数 DROPFUNCTION函数名; 5. 示例 无参有返回 DELIMITER$CREATEFUNCTIONmyf1()RETURNSINTBEGINDECLAREcINTDEFAULT0;SELECTCOUNT(*)INTOcFROMemployees;RETURNc;END$SELECTmyf1()$ 有参有返回 DELIMITER$CREATEFUNCTIONmyf2(empNameVARCHAR(20))RETURNSDOUBLEBEGINSET@sal=0;SELECTsalaryINTO@salFROMemployeesname=empName;RETURN@salEND$SELECTmyf2('tom')$ ","date":"2020-06-17","objectID":"/mysql_grammer/:45:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"流程控制结构 1. 顺序结构 程序从上往下依次执行 2. 分支结构 从多条路径中选择一条去执行 3. 循环结构 在满足一定条件的基础上，重复执行一段代码 ","date":"2020-06-17","objectID":"/mysql_grammer/:46:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"分支结构 1. if函数 IF(表达式1，表达式2，表达式3) 如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值。 2. case结构 CASE变量|表达式|字段WHEN要判断的值THEN返回的值1或语句;WHEN要判断的值THEN返回的值2或语句;...ELSE要返回的值n或语句;END; 或者 CASEWHEN要判断的条件1THEN返回的值1或语句;WHEN要判断的条件2THEN返回的值2或语句;...ELSE要返回的值n或语句;ENDCASE; 3. if结构 if条件1then语句1;elseif条件2then语句2;...else语句n;endif; 应用在begin/end中。 4. 示例 case DELIMITER$CREATEPROCEDUREtest_case(INscoreINT)BEGINCASEWHENscore\u003e=90ANDscore\u003c=100THENSELECT'A';WHENscore\u003e=80THENSELECT'B';WHENscore\u003e=60THENSELECT'C';ELSESELECT'D';ENDCASE;END$ if结构 DELIMITER$CREATEFUNCTIONtest_if(scoreINT)RETURNSCHARBEGINIFscore\u003e=90ANDscore\u003c=100THENRETURN'A';ELSEIFscore\u003e=80THENRETURN'B';ELSERETURN'D';ENDIF;END$ ","date":"2020-06-17","objectID":"/mysql_grammer/:47:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"循环结构 1. 分类 while loop repeat 1. 循环控制语句 iterate 类似于 continue leave 类似于 break 2. 语法 [标签:]while循环条件do循环体;endwhile[标签]; [标签:]loop循环体;endloop[标签]; [标签:]repeat循环体;until结束循环的条件endrepeat[标签]; ","date":"2020-06-17","objectID":"/mysql_grammer/:48:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"MySQL语句处理顺序 FROM\u003cleft_table\u003eON\u003cjoin_condition\u003e\u003cjoin_type\u003eJOIN\u003cright_table\u003eWHERE\u003cwhere_condition\u003eGROUPBY\u003cgroup_by_list\u003eHAVING\u003chaving_condition\u003eSELECTDISTINCT\u003cselect_list\u003eORDERBY\u003corder_by_condition\u003eLIMIT\u003climit_number\u003e ","date":"2020-06-17","objectID":"/mysql_grammer/:49:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"join语句汇总 INNER JOIN SELECT\u003cselect_list\u003eFROMtableAINNERJOINtableBONA.key=b.key; LEFT JOIN SELECT\u003cselect_list\u003eFROMtableALEFTJOINtableBONA.key=B.key; RIGHT JOIN SELECT\u003cselect_list\u003eFROMtableARIGHTJOINtableBONA.key=B.key; LEFT JOIN SELECT\u003cselect_list\u003eFROMtableALEFTJOINtableBONA.key=B.keyWHEREB.keyISNULL; RIGHT JOIN SELECT\u003cselect_list\u003eFROMtableARIGHTJOINtableBONA.key=B.keyWHEREA.keyISNULL; FULL OUTER JOIN SELECT\u003cselect_list\u003eFROMtableAFULLOUTERJOINtableBONA.key=B.key; FULL OUTER JOIN SELECT\u003cselect_list\u003eFROMtableAFULLOUTERJOINtableBONA.key=B.keyWHEREA.keyISNULLorB.keyISNULL; ","date":"2020-06-17","objectID":"/mysql_grammer/:50:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"不需要创建索引的情况 表记录太少 频繁更新的字段不适合创建索引。 如果某个数据列包含许多重复内容，建立索引则没有什么实际效果。索引的选择性是指索引列中不同值的数据与表中记录数的比。一个索引的选择性越接近1，这个索引的效率就越高。 ","date":"2020-06-17","objectID":"/mysql_grammer/:51:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"mysql分层和引擎 1. 分层 连接层：提供与客户端连接的服务。 服务层：提供各种用户使用的接口；提供SQL优化器（mysql query optimizer）； 引擎层：提供了数据存储的方式（MyISAM，InnoDB等）； 存储层：存储数据。 2. MyISAM与InnoDB MyISAM不支持主外键；InnoDB支持主外键。 MyISAM不支持事务；InnoDB支持事务。 MyISAM使用表锁，即使操作一条记录也会锁住整个表，不适合高并发操作；InnoDB使用行锁，操作时只锁一行，不对其他行有影响，适合高并发的操作。 MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还缓存真实数据，对内存要求较高，并且内存大小对性能有决定性影响。 MyISAM表空间小；InnoDB表空间大。 MyISAM关注性能；InnoDB关注事务。 MyISAM默认安装；InnoDB默认安装；（安装不代表默认使用）。 3. 数据库引擎 支持哪些引擎： showengines; 正在使用的引擎： showvariableslike'%storage_engine%'; 修改引擎： createtabletb(idint(4)auto_increment,namevarchar(5),deptvarchar(5),primarykey(id))engine=MyISAMauto_increment=1defaultcharset=utf8; ","date":"2020-06-17","objectID":"/mysql_grammer/:52:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"sql优化 1. 需要优化的原因 性能低、执行时间太长、等待时间太长、SQl语句欠佳（连接查询）、索引失效、服务器参数设置不对等。 2. sql 编写过程：select ... from ... join ... on ... where ... group by ... having ... order by ... limit 解析过程：from ... on ... join ... where ... group by ... having ... select ... order by limit ... 3. 优化 主要就是在优化索引。 ","date":"2020-06-17","objectID":"/mysql_grammer/:53:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"索引 1. 说明 相当于书的目录。 是帮助MySQL高效获取数据的数据结构。 即索引是数据结构（树：B树（默认）、Hash树。。。） B树：小的节点放左边，大的节点在右边。一般都是指B+树，数据全部存放在叶节点中。B+树查询任意数据的次数都是n次（B+树的高度）。 2. 索引弊端 索引本身很大，可以存放在内存/硬盘。 索引不是所有情况均适用：少量数据；频繁更新的字段；很少适用的字段等。 索引会降低增删改的效率。 3. 索引好处 提高查询效率（降低IO使用率）。 降低CPU使用率（因为B树索引本身就是一个排好序的结构，因此在对数据排序时可以直接使用）。 4. 分类 主键索引：列值不能重复，且不能为null 单值索引：单列构成的索引。一个表可以有多个单值索引。 唯一索引：构成唯一索引的列数据不能重复。 复合索引：多个列构成的索引。 ","date":"2020-06-17","objectID":"/mysql_grammer/:54:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"创建索引 1. 方式一 create索引类型索引名on表（字段） 示例： 单值 createindexdept_indexontbl(dept); 唯一 createuniqueindexname_indexontbl(name); 复合 createindexdept_name_indexontbl(dept,name); 2. 方式二 altertable表名add索引类型索引名(字段) 示例： 单值 altertabletbladdindexdept_index(dept); 唯一 altertabletbladduniqueindexname_index(name); 多值 altertabletbladdindexdept_name_index(dept,name); 3. 注意 如果一个字段是 primary key，则该字段默认就是主键索引。 ","date":"2020-06-17","objectID":"/mysql_grammer/:55:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"删除索引 dropindex索引名on表名; 示例： dropindexname_indexontbl; ","date":"2020-06-17","objectID":"/mysql_grammer/:56:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"查看索引 showindexfrom表名; 或者 showindexfrom表名\\G ","date":"2020-06-17","objectID":"/mysql_grammer/:57:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL性能问题 1. 说明 主要是通过分析SQL执行计划，分析性能。 注意，SQL查询优化器会干扰我们的优化。 ","date":"2020-06-17","objectID":"/mysql_grammer/:58:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL执行计划 1. 语法 explain+SQL语句 ","date":"2020-06-17","objectID":"/mysql_grammer/:59:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"执行计划分析 1. 表的执行顺序，因数量的改变而改变 原因：笛卡尔积。 数据量小的表，优先查询。 1. id id相同，从上往下顺序执行。 id不同，id值越大越优先查询（原因：在嵌套子查询时，先查内层，再查外层）。 id值有相同，又有不同，id值越大越优先，id值相同从上往下顺序执行。 2. select_type Primary：包含子查询SQL中的主查询（最外层）。 Subquery：包含子查询SQL中的子查询（非最外层）。 Simple：简单查询（不包含子查询、union）。 derived：衍生查询（使用到了临时表）；如在from子查询中只有一张表；又或者在from子查询中，如果有table1 union table2，则table1就是derived，table2就是union。 union：说明见上例。 union result：告知哪些表之间存在union查询。 3. table 4. type System \u003e const \u003e eq_ref \u003e ref \u003e range \u003e index \u003e all 其中：system，const只是理想情况，实际能达到 ref \u003e range。 优化前提：有索引。 system（忽略） 只有一条数据的系统表；或衍生表只有一条数据的主查询。 const 仅仅能查到一条数据的SQL，用于primary key或者unique索引（类型与索引类型有关）。 eq_ref 唯一性索引；对于每个索引键的查询，返回匹配的唯一行数据（有且只有1个，不能为0）；常见于唯一索引和主键索引。 ref 非唯一性索引，对于每个索引键的查询，返回匹配的所有行。 range 检索指定范围的行。 index 查询全部索引表中的数据。 all 查询表中的所有数据。 5. Possible_keys 可能用到的索引，是一种预测。 6. key 实际用到的索引。 7. key_len 索引的长度。 用于判断复合索引是否被完全使用。 对于utf8，一个字符占3个字节。 如果索引字段可以为null，则会使用1个字节用于标识。 如果索引字段为varchar，使用2个字节标识可变长度。 8. ref 注意与type中的ref值区分。 作用：指明当前表所参照的字段。 如：select ... where a.c = b.x; 9. rows 被索引优化查询的数据个数（实际通过索引而查询到的数据个数）。 10. extra using filesort 性能消耗大；需要“额外”一次排序（查询）。常见于order by语句中。 示例1： explainselect*fromtestwherea1=''orderbya2; 小结：对于单索引，如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort。 示例2：（注意存在a1, a2, a3, a4四个字段） altertabletestaddindexidx_a1_a2_a3(a1,a2,a3);explainselect*fromtestwherea1=''orderbya3;# using filesort explainselect*fromtestwherea2=''orderbya3;# using filesort explainselect*fromtestwherea1=''orderbya2; 小结：对于复合索引，where和order by按照复合索引的顺序使用，不要跨列或无序使用。 using temporary 性能损耗大，用到了临时表。一般出现在group by语句中。 示例： explainselect*fromtestwherea1in(1,2,3)groupbya1;explainselect*fromtestwherea1in(1,2,3)groupbya2;# using temporary using index 性能提升，常见于索引覆盖。 只要使用到的列，全部都在索引中，就称为”索引覆盖“。 不读取原文件，只从索引文件中获取数据（不需要回表查询）。 索引覆盖会对possible_keys和key造成影响：如果没有where，则索引只出现在key中；如果有where，则索引可能出现在key和possible_keys中。 using where 回表查询时，会出现using where。 impossible where where子句永远为false。 using join buffer mysql引擎使用了连接缓存。 ","date":"2020-06-17","objectID":"/mysql_grammer/:60:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"SQL优化 SQL优化是一种概率层面的优化。 服务层有SQL优化器，可能会影响我们的优化。 ","date":"2020-06-17","objectID":"/mysql_grammer/:61:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"单表优化 最佳左前缀，保持索引的定义和使用的顺序一致性 索引要逐步优化 将含in的范围查询，放到where的最后，防止失效 ","date":"2020-06-17","objectID":"/mysql_grammer/:62:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"双表优化 小表驱动大表 一般情况下，左外连接，给右表加索引；右外连接，给左表加索引。 ","date":"2020-06-17","objectID":"/mysql_grammer/:63:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"三表优化 小表驱动大表。 索引建立在经常查询的字段上。 ","date":"2020-06-17","objectID":"/mysql_grammer/:64:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"避免索引失效的一些原则 复合索引，不要跨列或无序使用（最佳左前缀）。 复合索引，尽量使用全索引匹配。 不要在索引上进行任何操作（计算，函数，类型转换），否则索引失效。 复合索引不能使用”不等于“，否则自身以及右侧所有全部失效。 复合索引中如果有\u003e，自身和右侧全失效。 一般而言，范围查询之后的索引失效。 尽量使用覆盖索引。 like尽量以“常量”开头，不要以\"%“开头，否则索引失效。 尽量不要使用类型转换。 尽量不要使用or，否则索引失效。 ","date":"2020-06-17","objectID":"/mysql_grammer/:65:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"其他的一些优化方法 order by using filesort有两种算法：单路排序、双路排序。 双路排序扫描两次磁盘：从磁盘读取排序字段；读取其他字段。 单路排序扫描一次磁盘：读取全部字段（不一定真的是单次，有可能是多次IO）。 Mysql4.1之前默认使用双路排序；mysql4.1之前默认使用单路排序。 设置buffer的容量大小：set max_length_for_sort_data = 1024，单位byte。 如果max_length_for_sort_data值太低，mysql会自动从 单路切换成双路。 避免使用select * ... 复合索引不要跨列使用。 保证排序字段的排序一致性。 ","date":"2020-06-17","objectID":"/mysql_grammer/:66:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"慢查询 mysql提供的一种日志记录，用于记录mysql响应超过阀值的语句，默认10秒。 默认是关闭的；建议调优时打开，最终部署时关闭。 检查是否打开了慢查询日志： showvariableslike'%slow_query_log%'; 临时开启： setglobalslow_query_log=1; mysql服务器重启后会失效。 永久开启： #/etc/my.cnf追加 [mysqld] slow_query_log=1 slow_query_log_file=/var/lib/mysql/local-slow.log 慢查询阀值： showvariableslike\"%log_query_time%\"; 设置慢查询阀值： setgloballomg_query_time=5; 重新登陆后生效。 永久设置阀值： #在/etc/my.cnf追加 [mysqld] long_query_time=3 查询超过阀值的sql： showglovalstatuslike'%slow_queries%'; ","date":"2020-06-17","objectID":"/mysql_grammer/:67:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"mysqldumpslow 用于查看慢SQL。 ","date":"2020-06-17","objectID":"/mysql_grammer/:68:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"海量数据分析 1. profiles 查看开启状态 showvariableslike'%profiling%'; 打开 setprofiling=on; 查看profiling打开之后，全部sql查询语句所花时间，不够精确 showprofiles; 2. 精确分析 showprofileallforquery上一步查询的query_id; 或者 showprofilecpu,blockioforquery上一步查询的query_id; 3. 全局查询日志 记录开启之后的全部sql语句，仅仅在调优、开发过程中打开。 showvariableslike'%general_log%';# 查看状态 #记录在表中 setglobalgeneral_log=1;# 开启 setgloballog_output='table';# sql记录在表中 #或者记录在文件中 setglobalgeneral_log=1;# 开启 setgloballog_output='file';# 或者sql记录在文件中 setglobalgeneral_log_file='/tmp/general.log';# 或者sql记录在文件中 ","date":"2020-06-17","objectID":"/mysql_grammer/:69:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"锁机制 解决因资源共享，造成的并发问题。 分类 按照操作类型： 读锁（共享锁）：对同一个数据，多个读操作可以同时进行，互不干扰。 写锁（互斥锁）：如果当前写操作没有完毕，则无法进行其他的读、写。 按照操作范围： 表锁：一次性对一张表整体加锁。MyISAM使用表锁。开销小，加锁快，无死锁。但锁的范围大，容易发生锁冲突，并发度低。 行锁：一次性对一条数据加锁。InnoDB使用行锁。开销大，加锁慢，容易死锁。所得范围较小，不容易发生锁冲突，并发度高，很小概率发生高并发问题（脏读、幻读、不可重复读）。 页锁： ","date":"2020-06-17","objectID":"/mysql_grammer/:70:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"表锁 给表加锁 locktable表1read/write,表2read/write,...; 查看加锁的表 showopentables; 释放锁 unlocktables; 加读锁的机制 如果一个会话对A表加了read锁，则该会话可以对A表进行读操作、不能进行写操作；不能对其它表进行读写操作。其它会话可以对A表进行读操作、进行写操作得等待锁释放；对其他表可以进行读写操作。 加写锁的机制 某个会话对表加写锁，之后可以对这张表进行任何操作，但是不能操作其它表。 其他会话对加写锁的表，进行增删改查时得等待锁释放。 MySQL表级锁的锁模式 MyISAM在执行查询语句前，会自动给涉及到的所有表加读锁；在执行更新操作前，会自动给涉及的表加写锁。 对MyISAM表的读操作，不会阻塞其他进程（会话）对同一表的读请求，会阻塞对同一表的写请求。 对MyISAm表的写操作，会阻塞其他进程（会话）对同一表的读和写操作，只有当锁释放时，才会进行其它进程的读写操作。 分析表锁定 查看表锁定状态 showopentables;# 1代表加了锁 分析表锁定的严重程度 showstatuslike'table%'; table_lock_immediate：可能获取到的锁数。 tale_locks_waited：需要等待的表锁数，该值越大，锁竞争越大。 当table_locks_immediate / table_locks_waited \u003e 5000，建议采用InnoDB引擎。 ","date":"2020-06-17","objectID":"/mysql_grammer/:71:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"行锁 InnoDB默认采用行锁。 研究前提：关闭了自动commit 关闭语句： set autocommit=0 start transection begin 总结： 如果”会话1“对“某条数据a”进行了DML操作，则其他会话需要等待“会话1”对“数据a”提交事务。 行锁通过事务解锁。 不同会话对不同行数据进行操作，互不影响。 查询数据不会加锁。 可以通过for update对query语句进行加锁。 注意事项： 如果没有索引，行锁会转换为表锁，需要通过commit进行解锁。 行锁的一种特殊情况： 间隙锁：值在范围内，但却不存在。 如：update ... where id \u003e 1 and id \u003c 9;，如果id=7的数据不存在，则该行数据存在间隙锁。 如果有where，则实际加锁的范围是where后面的范围（不是实际的值）。 缺点： 比表锁性能损耗大。 优点： 并发能力强，效率高。 行锁分析 查看行锁状态 showstatuslike'%innodb_row_lock%' Innodb_row_locl_current_waits：当前正在等待锁的数量。 Innodb_row_lock_time：等待总时长，从系统启动到现在，一共等待的时间。 Innodb_row_lock_time_avg：平均等待时长，从系统启动到现在的平均等待时间。 Innodb_row_lock_time_max：最大等待时长，从系统启动到现在的最大等待时间。 Innodb_row_lock_waits：从系统启动到现在，等待的次数。 ","date":"2020-06-17","objectID":"/mysql_grammer/:72:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["MySQL"],"content":"主从复制 优点 负载均衡 失败迁移 原理 master将改变的数据记录在本地的二进制日志中（binary log）；该过程称为“二进制日志事件”。 slave将master的binary log拷贝到relay log（中继日志文件）中。 slave将数据从relay log读取到自己的数据库中，称为中继日志事件。 特点 异步 串行话 有延迟 ","date":"2020-06-17","objectID":"/mysql_grammer/:73:0","tags":["MySQL"],"title":"【MySQL】基本语法","uri":"/mysql_grammer/"},{"categories":["Linux"],"content":"常见快捷键 Linux中有如下常见快捷键： ^c：终止前台运行的程序 ^z：将前台运行的程序挂起到后台 ^d：退出 等价于exit ^l：清屏 ^a | ^home：光标移到命令行的最前端 ^e | ^end：光标移到命令行的后端 ^u：删除光标前的所有字符 ^k：删除光标后的所有字符 ^r：搜索历史命令 ","date":"2020-04-30","objectID":"/linux-common-commands/:1:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"grep ","date":"2020-04-30","objectID":"/linux-common-commands/:2:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"语法 grep 选项 '关键字' 文件名 ","date":"2020-04-30","objectID":"/linux-common-commands/:2:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"常见选项 -i: 不区分大小写 -v: 查找不包含指定内容的行 -w: 按单词搜索 -o: 打印匹配关键字 -c: 统计匹配到的次数 -n: 显示行号 -r: 逐层遍历目录查找 -A: 显示匹配行及后面多少行 -B: 显示匹配行及前方多少行 -C: 显示匹配行及前后多少行 -l: 只列出匹配的文件名 -L: 列出不匹配的文件名 -e: 使用正则表达式 -E: 使用扩展正则表达式 ^key: 以关键字开头 key$: 以关键字结尾 ^$: 匹配空行 --color=auto: 将找到的内容，加上颜色显示 ","date":"2020-04-30","objectID":"/linux-common-commands/:2:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"举例 去除空行: grep -v '^$' [files...] ","date":"2020-04-30","objectID":"/linux-common-commands/:2:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"wc 统计文本的行数、单词数、字符数、字节数。 ","date":"2020-04-30","objectID":"/linux-common-commands/:3:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"语法 wc 选项 文件 ","date":"2020-04-30","objectID":"/linux-common-commands/:3:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"常用选项 -c：统计字节数 -w：统计单词数 -l：统计行数 -m：统计字符数 ","date":"2020-04-30","objectID":"/linux-common-commands/:3:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"输出结果 输出结果不受选项顺序的影响。 如果选项全选，输出顺序为： 行数 单词数 字符数 字节数 文件名 如果选项缺省，输出顺序为： 行数 单词数 字节数 文件名 ","date":"2020-04-30","objectID":"/linux-common-commands/:3:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"示例 统计文件内容行数： wc -l filename ","date":"2020-04-30","objectID":"/linux-common-commands/:3:4","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"cut 列截取工具，用于文本列的截取。 ","date":"2020-04-30","objectID":"/linux-common-commands/:4:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"语法 cut 选项 文件名 ","date":"2020-04-30","objectID":"/linux-common-commands/:4:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"常用选项 -b：以字节为单位，进行分割，然后输出指定范围的内容 -c：以字符为单位，进行分割、然后输出指定范围的内容 -d：自定义分割符，默认为制表符\\t，需要和-f同时使用 -f：可与-d同时使用，指定截取的区域(列) 指定范围： N：指定第N个字节、字符或者字段 N-：从N开始到结束 N-M：从N到M，包含M -M：从开始到M，包含M ","date":"2020-04-30","objectID":"/linux-common-commands/:4:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"示例 以空格为分隔符，获取第2，第3，第4和第6个字段 cut -d \" \" -f 2-4,6 filename 以字节为分割单位，获取第2，第3，第4和第6个字段 cut -b 2-4,6 filename 以字符为分割单位，获取第2，第3，第4和第6个字段 cut -c 2-4,6 filename ","date":"2020-04-30","objectID":"/linux-common-commands/:4:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"sort 将文件的每一行作为一个单位，从首字符向后，依次按照unicode码值进行比较，最后将结果升序输出。 ","date":"2020-04-30","objectID":"/linux-common-commands/:5:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"语法 sort 选项 源文件 [-o 输出文件] ","date":"2020-04-30","objectID":"/linux-common-commands/:5:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"选项 -u：去除重复行 -r：降序排列，默认升序 -o：将排序结果输出到文件中，类似于重定向符号\u003e -n：以数字排序，默认是按字符排序 -t：分隔符 -k：第n列 -b：忽略前导空格 -R：随机排序，每次运行结果均不同 ","date":"2020-04-30","objectID":"/linux-common-commands/:5:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"示例： 去除排序结果的重复行： # apple =\u003e apple # orange =\u003e banana # apple =\u003e orange # banana =\u003e sort -u filename 根据第2列的数值，进行排序 # apple:12 =\u003e orange:2 # orange:2 =\u003e apple:12 # apple:12 =\u003e apple:12 # banana:23 =\u003e banana:23 sort -t \":\" -k 2 -n filename ","date":"2020-04-30","objectID":"/linux-common-commands/:5:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"uniq 去除并删除文中出现的连续行，一般与sort命令结合使用。即为了使uniq起作用，所有的重复行必须是相邻的。 ","date":"2020-04-30","objectID":"/linux-common-commands/:6:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"选项 -u：--unique仅显示出现一次的行。 -i：忽略大小写。 -c：统计重复行次数 -d：只显示重复行 ","date":"2020-04-30","objectID":"/linux-common-commands/:6:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"示例 统计各行出现的次数 sort filename | uniq -c 在文中找出重复行 sort filename | uniq -d ","date":"2020-04-30","objectID":"/linux-common-commands/:6:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"tee 从标准输入读取，并且写入到标准输出和文件。 ","date":"2020-04-30","objectID":"/linux-common-commands/:7:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"选项 -a：追加重定向，默认是覆盖。 -i：忽略中断信号。 ","date":"2020-04-30","objectID":"/linux-common-commands/:7:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"示例 将输入同时保存到file1和file2 tee file1 file2 ","date":"2020-04-30","objectID":"/linux-common-commands/:7:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"diff 用于逐行比较文件的不同。 diff描述两个文件不同的方式，是告诉我们怎么改变第一个文件之后，与第二个文件匹配。 ","date":"2020-04-30","objectID":"/linux-common-commands/:8:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"语法 diff [选项] 文件1 文件2 ","date":"2020-04-30","objectID":"/linux-common-commands/:8:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"选项 -b：不检查空格 -B：不检查空白行 -i：不检查大小写 -w：忽略所有的空格 --normal：正常格式显示（默认） -c：上下文格式显示 -u：合并格式显示 -N：将不存在的文件当作空文件 -q：比较两个目录不同时，默认情况下，会显示同名文件具体的差异内容。如果使用了-q参数，则只会显示文件的差异。 ","date":"2020-04-30","objectID":"/linux-common-commands/:8:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"显示格式 正常模式显示 diff f1.txt f2.txt 5c5 # 第一个文件的第5行需要改变(c=change)才能和第二个文件的第5行匹配(a, addition; d, deletion) ... 3d3 # 第一个文件的第3行删除(d=delete)后才能和第二个文件的第3行匹配 ... 6a6,7 # 第一个文件的第6行增加(a=add)内容后，才能和第二个文件的第6到7行匹配 ... 上下文模式显示 diff -c f1.txt f2.txt *** f1.txt 2020-09-15 11:17:10.636634400 +0800 # 第一个文件信息 --- f2.txt 2020-09-15 11:20:17.862629200 +0800 # 第二个文件信息 *************** # 分隔符 *** 1,6 *** # 以***开头表示file1文件，1，6表示1到6行 ! aaa # !表示改行需要修改才与第二个文件匹配 - hello world # -表示需要删除改行才与第二个文件匹配 ... --- 1,7 --- # 以---开头表示file2文件，1，7表示1到7行 ! aaa # 表示第一个文件需要修改才能与第二个文件匹配 ! hello # 表示第一个文件需要修改才能与第二个文件匹配 ... + 333 # 表示第一个文件需要加上该行才能与第二个文件匹配 + world # 表示第一个文件需要加上该行才能与第二个文件匹配 ... 合并格式显示 diff -u f1.txt f2.txt --- f1.txt 2020-09-15 11:17:10.636634400 +0800 # 变动前文件 +++ f2.txt 2020-09-15 11:20:17.862629200 +0800 # 变动后文件 @@ -2,9 +2,9 @@ # 第一个文件的2到9行 第二个文件的2到9行 two three four -five # 删除第一个文件的行 +fifteen # 第二个文件新增的行 six seven eight nine -ten +TEN ","date":"2020-04-30","objectID":"/linux-common-commands/:8:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"sshpass 非交互式密码验证工具。 ","date":"2020-04-30","objectID":"/linux-common-commands/:9:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"安装 RedHat/Centos安装： yum install sshpass Debian/Ubuntu安装： sudo apt-get install sshpass 源码安装： -\u003e wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tar.gz -\u003e tar -xvf sshpass.tar.gz -\u003e cd sshpass-1.06 -\u003e ./configure -\u003e sudo make install ","date":"2020-04-30","objectID":"/linux-common-commands/:9:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"常用参数 -f：使用文件内容作为密码 -p：通过参数提供密码 -e：通过环境变量SSHPASS提供密码 ","date":"2020-04-30","objectID":"/linux-common-commands/:9:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"示例 登录服务器，并且查看文件系统磁盘使用情况： sshpass -p 'my_pass_here' ssh username@host 'df -h' ","date":"2020-04-30","objectID":"/linux-common-commands/:9:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"paste 用于合并文件行。 ","date":"2020-04-30","objectID":"/linux-common-commands/:10:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"选项 -d：自定义分隔符，默认是tab。 -s：文件内容按行排布，默认按列排布。 ","date":"2020-04-30","objectID":"/linux-common-commands/:10:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"tr 用于字符替换和删除。 ","date":"2020-04-30","objectID":"/linux-common-commands/:11:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"用法 用法一：命令的执行结果交给tr处理。 commands | tr \"string1\" \"string2\" string1和string2的字符一一对应替换。 如果string1比string2长，则string2的最后一个字符会对应多个string1中的字符。 如果string1比string2短，则string2多余部分被丢弃。 用法二：tr处理的内容来自文件，需要使用标准输入符号 tr \"string1\" \"string2\" \u003c filename string1和string2的具体用法同上。 用法三：匹配string进行相应操作，如删除操作 tr options \"string\" \u003c filename 常用选项： -d：删除字符串中所有输入的字符。 -s：删除所有重复出现的字符，只保留第一个，即将重复出现的字符压缩为一个字符。 ","date":"2020-04-30","objectID":"/linux-common-commands/:11:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-common-commands/"},{"categories":["Linux"],"content":"df说明 df命令可以查看整个磁盘空间的占用情况，但是不能查看某个目录的大小。 ","date":"2020-03-09","objectID":"/linux-df/:1:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Linux"],"content":"命令格式 df [options] ","date":"2020-03-09","objectID":"/linux-df/:2:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Linux"],"content":"options options是可选的，常见的参数如下： -h：以容易理解的格式输出文件系统的分区情况，如1kB、1MB、1GB。 -H：和-h很像，但是以1000为单位，而不是1024。 -k：以kB为单位输出。 -m：以MB为单位输出。 -a：列出所有文件系统分区，包括大小为0的分区。 -T：显示文件系统类型。 对于-hm或者-hk，h后面的m和k不会生效。 对于-mh或者-kh，h不会生效。 -H同理。 ","date":"2020-03-09","objectID":"/linux-df/:3:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Linux"],"content":"使用示例 查看系统分区 df -h 查看文件系统类型 df -T ","date":"2020-03-09","objectID":"/linux-df/:4:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Golang"],"content":"定义 Buffer是一个可变长的字节缓冲区，具备读写的方法。Buffer的零值是一个空的缓冲区。 type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at \u0026buf[off], write at \u0026buf[len(buf)] lastRead readOp // last read operation, so that Unread* can work correctly. } ","date":"2020-03-08","objectID":"/golang_buffer_pkg/:1:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"声明 有四种声明方法。 直接定义一个Buffer变量。 var b bytes.Buffer 使用New返回Buffer变量指针。 b := new(bytes.Buffer) 使用[]byte切片初始化。 b := bytes.NewBuffer([]byte(\"hello\")) 使用string初始化。 b := bytes.NewBufferString(\"hello\") ","date":"2020-03-08","objectID":"/golang_buffer_pkg/:2:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"写数据 Buffer提供了5种写数据的方法。 将[]byte切片写入尾部。 func (b *Buffer) Write(p []byte) (n int, err error) 将string写入尾部。 func (b *Buffer) WriteString(s string) (n int, err error) 将字符写入尾部。 func (b *Buffer) WriteByte(c byte) error 将rune写入尾部。 func (b *Buffer) WriteRune(r rune) (n int, err error) 将接口对象写入尾部。 func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) ","date":"2020-03-08","objectID":"/golang_buffer_pkg/:3:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"读数据 Buffer提供了7种读数据的方法。 读取n个字符。 func (b *Buffer) Next(n int) []byte 将数据读入[]byte。 func (b *Buffer) Read(p []byte) (n int, err error) 读取第一个byte。 func (b *Buffer) ReadByte() (byte, error) 读取第一个UTF8编码字符。 func (b *Buffer) ReadRune() (r rune, size int, err error) 读取分隔符前的内容，并且返回切片。 func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) 读取分隔符前的内容，并且返回字符串。 func (b *Buffer) ReadString(delim byte) (line string, err error) 将内容输出到接口对象。 func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) ","date":"2020-03-08","objectID":"/golang_buffer_pkg/:4:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"其他方法 返回字节切片。 func (b *Buffer) Bytes() []byte 返回字节切片容量。 func (b *Buffer) Cap() int 为容量增加n个字节。 func (b *Buffer) Grow(n int) 返回缓冲区长度。 func (b *Buffer) Len() int 清空数据。 func (b *Buffer) Reset() 字符串化。 func (b *Buffer) String() string 丢弃前n个未读字节以外的数据。 func (b *Buffer) Truncate(n int) 将最后一次成功读取的字节，设为未读取状态。 func (b *Buffer) UnreadByte() error 将最后一次读取的rune字符，设为未读取状态。 func (b *Buffer) UnreadRune() error ","date":"2020-03-08","objectID":"/golang_buffer_pkg/:5:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang_buffer_pkg/"},{"categories":["Golang"],"content":"bufio包介绍 bufio包可以从文件或标准输入读取数据，还可以向文件中写入数据。 读取数据时，先将数据读入缓冲区，然后再从缓冲区中读取。写入数据时，先把数据写入缓冲区，然后在某个时间节点，一次性地将数据写入文件。 通过缓冲区，能有效减少读写磁盘的次数。 ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:1:0","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"使用 下面仅介绍一些常见用法。 ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:2:0","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"1. 读取数据 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) b := make([]byte, 64) n, err := buf.Read(b) if err != nil { log.Fatal(err) } fmt.Println(buf.Buffered()) fmt.Println(string(b[:n])) } ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:2:1","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"2. 按行读取 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 按行读取 for { bs1, _, err := buf.ReadLine() if err == io.EOF { break } fmt.Println(string(bs1)) } } ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:2:2","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"3. 读取多个字节 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 指定每次读取的分割符 for { bs2, err := buf.ReadBytes('\\n') if err == io.EOF { break } fmt.Print(string(bs2)) } } ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:2:3","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"4. 读取字符串 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) for { str, err := buf.ReadString('\\n') if err != nil { break } fmt.Print(str) } } ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:2:4","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"5. 从标准输入读取 func main() { // 读取输入 buf := bufio.NewReader(os.Stdin) for { s2, _, err := buf.ReadLine() fmt.Println(string(s2)) fmt.Println(err) if string(s2) == \"q\" { break } } } ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:2:5","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"6. 写入数据到文件 func main() { // 写入数据 file, err := os.OpenFile(\"./data1.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } buf2 := bufio.NewWriter(file) n, err := buf2.WriteString(\"今夜特别漫长\\n\") if err != nil { log.Fatal(err) } // 将缓冲区数据刷入磁盘文件 buf2.Flush() fmt.Println(n) } ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:2:6","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"源码解析 ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:3:0","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"1. bufio.NewReader 用于生成一个读缓冲区。 方法的具体定义为： func NewReader(rd io.Reader) *Reader { return NewReaderSize(rd, defaultBufSize) } 传入的参数rd需要实现io.Reader接口，通过os.Open或者os.OpenFile返回的*File对象就实现了这个接口。 *Reader结构体中包含buf字段，这是一个字节切片，用做缓冲区来存放数据。 defaultBufSize用于定义buf的长度和容量，默认4096个字节。 ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:3:1","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"2. bufio.Read 方法的声明为： func (b *Reader) Read(p []byte) (n int, err error) 当p的长度为0时，不读取数据。 当缓冲区为空，且p的长度大于等于缓冲区长度时，不经过缓冲区，直接从文件中读取数据。 当缓冲区为空，且p的长度小于缓冲区长度时，先将数据读入缓冲区，再从缓冲区读取需要的字节。 如果缓冲不为空，直接从缓冲区读取，当p读满了，或者缓冲区读空了，就返回结果。 ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:3:2","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"3. bufio.NewWriter func NewWriter(w io.Writer) *Writer { return NewWriterSize(w, defaultBufSize) } 用于生成一个写缓冲区。逻辑类似于bufio.NewReader，返回一个*Writer结构体地址。 Writer中含有buf字段，用做缓冲区来存放数据，默认长度为4096个字节。 ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:3:3","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"4. bufio.Write func (b *Writer) Write(p []byte) (nn int, err error) 如果写入的数据大于缓冲区可用长度，当缓冲区内无数据时，直接写入文件。 如果写入数据大于缓冲区可用长度，且缓冲区有数据，则先将数据写入缓冲区，再将缓冲区写入文件并清空缓冲区。不断重复该过程，直到剩余数据不大于缓冲区可用长度，然后仅将数据写入缓冲区，结束。 如果写入数据小于等于缓冲区可用长度，则仅仅写入缓冲区。 ","date":"2020-03-06","objectID":"/golang_bufio_pkg/:3:4","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang_bufio_pkg/"},{"categories":["Golang"],"content":"介绍 golang提供了文件相关的各种操作，包括创建、删除、和读写等。 ","date":"2020-03-01","objectID":"/golang_file/:1:0","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"文件基本操作方法 ","date":"2020-03-01","objectID":"/golang_file/:2:0","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"1. 查看文件信息 func main() { // 查看文件信息 fileInfo, err := os.Stat(\"./data.txt\") if err != nil { fmt.Println(err) return } fmt.Println(\"Stat:\", fileInfo.Name()) fmt.Println(\"Stat:\", fileInfo.IsDir()) fmt.Println(\"Stat:\", fileInfo.Size()) fmt.Println(\"Stat:\", fileInfo.Mode()) fmt.Println(\"Stat:\", fileInfo.ModTime()) } ","date":"2020-03-01","objectID":"/golang_file/:2:1","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"2. 路径操作 func main() { // 路径操作 filename1 := \"./file.txt\" fmt.Println(\"IsAbs:\", filepath.IsAbs(filename1)) // 获取绝对路径 fileabs, err := filepath.Abs(filename1) if err != nil { log.Fatal(err) } fmt.Println(fileabs) // 绝对路径的父级目录 fmt.Println(\"Join:\", path.Join(fileabs, \"..\")) } ","date":"2020-03-01","objectID":"/golang_file/:2:2","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"3. 创建一级文件夹 func main() { // 创建一级文件夹 err := os.Mkdir(\"./aa\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2020-03-01","objectID":"/golang_file/:2:3","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"4. 创建多级文件夹 func main() { // 创建多级文件夹 err := os.MkdirAll(\"./bb/cc\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2020-03-01","objectID":"/golang_file/:2:4","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"5. 创建文件 func main() { // 创建文件，权限默认为0666，如果文件存在，会清空数据 file, err := os.Create(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2020-03-01","objectID":"/golang_file/:2:5","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"5. 只读模式打开文件 func main() { // 只读模式打开文件 file, err := os.Open(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2020-03-01","objectID":"/golang_file/:2:6","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"6. 以指定模式打开文件 func main() { // 以指定模式打开文件，如果文件不存在，则以指定权限0666创建文件 file, err := os.OpenFile(\"./file.txt\", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) return } file.Close() } ","date":"2020-03-01","objectID":"/golang_file/:2:7","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"7. 删除空目录或文件 func main() { // 删除空目录 err := os.Remove(\"./aa\") if err != nil { fmt.Println(\"remove:\", err) return } // 删除文件 err = os.Remove(\"./file.txt\") if err != nil { fmt.Println(\"remove:\", err) return } } ","date":"2020-03-01","objectID":"/golang_file/:2:8","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"8. 删除指定目录或文件，即使目录非空 func main() { // 删除所有目录，包括非空目录 err := os.RemoveAll(\"./aa.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } err = os.RemoveAll(\"./data.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } } ","date":"2020-03-01","objectID":"/golang_file/:2:9","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"读取文件内容 除了上述的文件基本操作外，golang还为读文件提供了多种方式。 ","date":"2020-03-01","objectID":"/golang_file/:3:0","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"file.Read func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() b := make([]byte, 128) for { n, err := file.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } } ","date":"2020-03-01","objectID":"/golang_file/:3:1","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"io.ReadFull 1 package main 2 3 import ( 4 \"fmt\" 5 \"io\" 6 \"log\" 7 \"os\" 8 ) 9 10 func main() { 11 file, err := os.Open(\"./data.txt\") 12 if err != nil { 13 log.Fatal(err) 14 } 15 defer file.Close() 16 17 // 读取正好1024个字节，内容不够会报错 18 b := make([]byte, 1024) 19 n, err := io.ReadFull(file, b) 20 if err != nil { 21 log.Fatal(err) 22 } 23 24 fmt.Printf(\"%s\", string(b[:n])) 25 } ","date":"2020-03-01","objectID":"/golang_file/:3:2","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"io.ReadAtLeast func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() // 至少读取8个字节，不够的话会报错 b := make([]byte, 1024) n, err := io.ReadAtLeast(file, b, 8) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } ","date":"2020-03-01","objectID":"/golang_file/:3:3","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewReader bufio提供了多种读取文件的方法，但方法名都是以Read开头。 func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() reader := bufio.NewReader(file) for { str, err := reader.ReadString('\\n') if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", str) } } ","date":"2020-03-01","objectID":"/golang_file/:3:4","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.ReadAll func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(data)) } ","date":"2020-03-01","objectID":"/golang_file/:3:5","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.ReadFile func main() { b, err := ioutil.ReadFile(\"./data.txt\") if err != nil { log.Fatal(err) } fmt.Println(string(b)) } ","date":"2020-03-01","objectID":"/golang_file/:3:6","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewScanner func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } err = scanner.Err() if err != nil { log.Fatal(err) } } ","date":"2020-03-01","objectID":"/golang_file/:3:7","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"写入文件 golang为写文件提供了以下方式。 ","date":"2020-03-01","objectID":"/golang_file/:4:0","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"file.Write func main() { file, err := os.OpenFile(\"./data.txt\", os.O_WRONLY|os.O_CREATE, 0644) if err != nil { log.Fatal(err) } defer file.Close() b := []byte(\"Hello\") n, err := file.Write(b) if err != nil { log.Fatal(err) } fmt.Printf(\"Wrote %d bytes.\\n\", n) } ","date":"2020-03-01","objectID":"/golang_file/:4:1","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"ioutil.WriteFile func main() { err := ioutil.WriteFile(\"./data.txt\", []byte(\"Hello\"), 0644) if err != nil { log.Fatal(err) } } ","date":"2020-03-01","objectID":"/golang_file/:4:2","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"},{"categories":["Golang"],"content":"bufio.NewWriter bufio包中，写入文件的方法较多，但都是以Write开头。 func main() { file, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) if err != nil { log.Fatal(err) } defer file.Close() writer := bufio.NewWriter(file) writer.WriteString(\"Hello world\") writer.Flush() } ","date":"2020-03-01","objectID":"/golang_file/:4:3","tags":["Golang","file"],"title":"【Golang】文件相关操作","uri":"/golang_file/"}]