[{"categories":["MySQL"],"content":"SQL语句执行流程 一条SQL语句的执行，需要经过连接器、分析器、优化器、执行器和存储引擎等模块。 连接器管理着MySQL和客户端的连接，分析器将SQL语句分析成语法树，优化器会选择合适的执行计划，执行器根据执行计划来调用存储引擎提供的接口。 SQL语句的总体执行流程都是一样，但不同类型的语句，执行器做出的操作会有所不同。 ","date":"2021-09-28","objectID":"/mysql-geng-xin-liu-cheng/:1:0","tags":["MySQL"],"title":"【MySQL】InnoDB中一条更新语句的执行流程","uri":"/mysql-geng-xin-liu-cheng/"},{"categories":["MySQL"],"content":"Buffer Pool Buffer Pool是InnoDB存储引擎内部的一块内存组件，用于缓存各种数据。 更新数据时，会先检查对应行是否在Buffer Pool缓存中。如果不在，就从磁盘读入缓存。 如果Buufer Pool中有了所需数据，InnoDB会对该行加写锁，从而避免其他事务并发修改。 ","date":"2021-09-28","objectID":"/mysql-geng-xin-liu-cheng/:2:0","tags":["MySQL"],"title":"【MySQL】InnoDB中一条更新语句的执行流程","uri":"/mysql-geng-xin-liu-cheng/"},{"categories":["MySQL"],"content":"undo log undo log是回滚日志，通过该日志可以将数据回滚到指定版本，事务回滚和一致性视图都应用到了它。 更新数据时，InnoDB会将旧的数据信息写入undo log。 ","date":"2021-09-28","objectID":"/mysql-geng-xin-liu-cheng/:3:0","tags":["MySQL"],"title":"【MySQL】InnoDB中一条更新语句的执行流程","uri":"/mysql-geng-xin-liu-cheng/"},{"categories":["MySQL"],"content":"脏数据 写完undo log后，InnoDB会更新Buffer Pool中的记录。 这时，内存和磁盘中的数据是不一致的，所以称内存中的数据是脏数据，需要后续写入磁盘。 MySQL有一个后台线程，该线程会在某些时间点，将Buffer Pool中的脏数据刷新到磁盘中。 ","date":"2021-09-28","objectID":"/mysql-geng-xin-liu-cheng/:4:0","tags":["MySQL"],"title":"【MySQL】InnoDB中一条更新语句的执行流程","uri":"/mysql-geng-xin-liu-cheng/"},{"categories":["MySQL"],"content":"redo log redo log是InnoDB特有的日志，用于记录数据页的修改信息。通常情况下，该日志会被存放在名为redo log buffer的内存缓冲区中。 事务提交前，InnoDB会将修改信息写入redo log，并在redo log中添加prepare标记，表示准备提交事务。 如果在脏数据刷新到磁盘之前，MySQL崩溃了，此时内存中的数据会丢失。有了redo log，MySQL重启后就能实现数据恢复。 当然，服务崩溃后redo log buffer中的redo log也会被清除。因此，提交事务时需要将redo log写入磁盘。 参数innodb_flush_log_at_trx_commit控制着redo log的刷盘策略。该参数有3个值： 0：提交事务时，不会把日志写入磁盘，而是每隔一秒进行写入。 1：提交事务时，会将日志写入磁盘。 2：提交事务时，只会将日志写入操作系统的文件缓存，操作系统崩溃时该缓存会丢失。 ","date":"2021-09-28","objectID":"/mysql-geng-xin-liu-cheng/:5:0","tags":["MySQL"],"title":"【MySQL】InnoDB中一条更新语句的执行流程","uri":"/mysql-geng-xin-liu-cheng/"},{"categories":["MySQL"],"content":"bin log bin log是server层的日志，与存储引擎无关，记录的是逻辑性的日志，比如“将满足条件的记录更新为指定值”。 提交事务之前，除了会写redo log，还会写bin log。 bin log也有一个刷盘策略，由参数sync_binlog控制： 参数为0时，每次提交事务，都只是将日志写入操作系统的文件缓存中。 参数为1时，每次提交事务都会将日志写入磁盘。 参数为n时，表示每提交n个事务才写入一次磁盘，其余时间只写入文件缓存。 ","date":"2021-09-28","objectID":"/mysql-geng-xin-liu-cheng/:6:0","tags":["MySQL"],"title":"【MySQL】InnoDB中一条更新语句的执行流程","uri":"/mysql-geng-xin-liu-cheng/"},{"categories":["MySQL"],"content":"事务提交 事务提交后，会在redo log中写入commit标记。 事务准备提交时，会先写redo log，并标记为prepare状态。然后写bin log，再提交事务，最后将redo log改为commit状态。该流程就是“两阶段提交”。 在主备架构中，bin log会被用于进行主备库的数据同步。如果bin log已经写入，则备库就会执行对应事务。“两阶段提交”的设计目的，是为了保证数据一致性。 如果写了redo log并标记为repare状态，崩溃重启后，MySQL会根据redo log中的XID去bin log进行查找。如果找到对应日志，就应用redo log进行数据恢复，否则丢弃该日志。 如果写了redo log并标记为commit状态，崩溃重启后，MySQL会直接利用该日志进行数据恢复。 至此，一条更新语句就执行结束了。 ","date":"2021-09-28","objectID":"/mysql-geng-xin-liu-cheng/:7:0","tags":["MySQL"],"title":"【MySQL】InnoDB中一条更新语句的执行流程","uri":"/mysql-geng-xin-liu-cheng/"},{"categories":["MySQL"],"content":"next-key lock next-key lock是行锁和间隙锁的组合，只有在InnoDB的可重复读隔离级别下，才可以使用。 行锁是加在索引上的。如果索引，就对该索引加锁。列上没有索引，就会在主键上加锁。 间隙锁是加在索引之间的锁，用于避免其他事务在某个间隙内插入或修改数据，只有在可重复读隔离级别下才可使用。 next-key lock避免了幻读问题的产生。 ","date":"2021-09-26","objectID":"/mysql-next-key-lock/:1:0","tags":["MySQL"],"title":"【MySQL】next-key lock规则","uri":"/mysql-next-key-lock/"},{"categories":["MySQL"],"content":"加锁规则 加锁的基本单位是next-key lock。 查找过程中，访问到的对象才会加锁，此处的对象是指索引。 对于唯一索引上的等值查询，加锁时，next-key lock退化为行锁。 对于非唯一索引上的等值查询，需要向右遍历，访问到不满足条件的第一个值。给该值加锁时，next-key lock退化为间隙锁。 对于唯一索引上的范围查询，会访问到不满足条件的第一个值为止。如果是MySQL8.0.23版本，next-key lock会退化为间隙锁，其他版本(\u003e= 5.7.24, \u003e= 8.0.13)待测试。 对于非唯一索引上的范围查询，也会访问到不满足条件的第一个值为止。对于MySQL8.0.23版本，next-key lock不会退化为间隙锁。 ","date":"2021-09-26","objectID":"/mysql-next-key-lock/:2:0","tags":["MySQL"],"title":"【MySQL】next-key lock规则","uri":"/mysql-next-key-lock/"},{"categories":["MySQL"],"content":"主键加锁 通常情况下，给索引加锁的同时，也会给主键加行锁（不论索引是行锁还是间隙锁）。 如果使用lock in share mode加锁，并且使用到了覆盖索引，则主键不会被加锁。应当避免这种情况产生。 如果使用for update加锁，并且查询数据存在，则即使使用到了覆盖索引，也会给主键加行锁。 delete语句的规则类似于select ... for update。 ","date":"2021-09-26","objectID":"/mysql-next-key-lock/:3:0","tags":["MySQL"],"title":"【MySQL】next-key lock规则","uri":"/mysql-next-key-lock/"},{"categories":["MySQL"],"content":"limit的影响 如果使用了limit关键字，当查询到的记录数量达到limit要求时，会停止扫描，从而可以减小加锁范围。 ","date":"2021-09-26","objectID":"/mysql-next-key-lock/:4:0","tags":["MySQL"],"title":"【MySQL】next-key lock规则","uri":"/mysql-next-key-lock/"},{"categories":["MySQL"],"content":"主备架构 MySQL的高可用架构是从一主一备的的基础上演化过来的。 所谓的主备架构，即客户端从主节点读写数据，备节点是主节点的备份，和主节点的数据保持同步。进行切换时，备库被切成主库，主库被切成备库。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:1:0","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"readonly 通常情况下，会将备库设置为readonly模式。原因如下： 备库常被用于执行一些分析语句，设为只读可防止误操作。 防止切换过程中出现双写，进而导致主备不一致。 常用readonly状态来判断节点的角色。 注意，readonly配置对超级权限用户无效，进行同步的线程拥有超级权限。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:1:1","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"同步流程 主备同步的流程如下： 备库使用change master命令，设置主库的IP、端口、用户名、密码、binlog文件名和日志偏移量。 在备库执行start slave命令。之后备库会启动两类线程，io_thread和sql_thread。 sql_thread和主库建立连接。 主库校验完用户名和密码后，根据备库指定的binlog文件名和偏移量，从本地读取日志，然后发给备库。 备库拿到binlog后，写到本地中转日志relay log。 sql_thread读取中转日志，然后进行解析执行。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:1:2","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"change master 配置主从复制的时候，需要在从库上执行change master语句，才能和主库保持同步。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:2:0","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"语法 change master语法为： changemastertooption[,option]... ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:2:1","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"常见选项 常见的option参数如下： MASTER_HOST：主库的主机名或者ip。 MASTER_PORT：主库的端口。 MASTER_USER：连接到主库的用户名。 MASTER_PASSWORD：连接到主库的密码。 MASTER_LOG_FILE：指定主库的binlog文件位置。 MASTER_LOG_POS：指定从binlog的该位置开始复制。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:2:2","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"示例 changemastertomaster_host=\"127.0.0.1\",master_port=3306,master_user=\"root\",master_password=\"123456\"; ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:2:3","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"查看 binlog 查看binlog是否开启。 showvariableslike\"log_bin%\"; 查看第一个binlog内容。 showbinlogevents; 查看binlog文件列表。 showbinarylogs; 查看正在使用的binlog。 showmasterstatus; 查看指定binlog内容。 showbinlogeventsin文件名; ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:3:0","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"binlog 格式 binlog有三种格式，statement、row和mixed。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:4:0","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"statement binlog_format设置为statement时，binlog里面记录的是SQL语句本身。 使用statement可能会导致主备数据不一致。因为日志记录的是sql语句，因此主库在执行时使用的索引，可能和备库执行时使用的索引不一样，从而可能会造成数据不一致。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:4:1","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"row row格式的binlog记录的不是语句原文，而是“操作的哪张表”和“对该表进行的操作”。如下示例中的Table_map和Delete_rows就是被记录的event。 |binlog.000040|156|Anonymous_Gtid|1|235|SET@@SESSION.GTID_NEXT='ANONYMOUS'||binlog.000040|235|Query|1|310|BEGIN||binlog.000040|310|Table_map|1|366|table_id:88(test.t1)||binlog.000040|366|Delete_rows|1|406|table_id:88flags:STMT_END_F||binlog.000040|406|Xid|1|437|COMMIT/* xid=14 */| 如果想看到日志的详细内容，可以在终端使用如下命令： mysqlbinlog -vv 日志路径 -start-position=310 --stop-position=437 使用row格式，不会造成主备数据不一致。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:4:2","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"mixed 如果使用statement，可能会导致主备不一致。如果使用row，生成的日志会占用大量的空间，消耗io资源，对语句性能造成影响。 由于上述的种种原因，从而有了mixed格式。 设置成mixed格式时，MySQL会判断语句是否会引起主备不一致。如果可能会，就用row格式，否则用statement格式。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:4:3","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"数据恢复 因操作不当，导致数据出现错误时，还可以使用row格式的binlog将数据恢复到之前的状态。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:4:4","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"binlog 重放 binlog的一个重要使用场景是归档。使用某个时间点的备份，和该时间点之后的binlog日志，可以让数据恢复到指定时刻。 需要注意的是，binlog重放时，不能直接执行statement格式记录的语句，因为有些语句是依赖上下文环境的，如时间等。正确做法是，使用mysqlbinlog工具解析，然后将整个解析结果发给MySQL执行。 示例如下： mysqlbinlog binlog.000040 --start-position=4 | mysql -uroot -p ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:4:5","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"双主架构 在双主架构中，客户端仍旧从单个节点读写数据，另一个节点与该节点保持数据同步，但是节点之间互为主备关系。在这种架构中，如果发生了切换，就不再需要修改主备关系。 如果将参数log_slave_updates设置为on，备库执行完relay log后，会生成bin log。 由于节点之间互为主备，因此可能会产生bin log循环复制的问题。为了解决这个问题，节点的server id必须互不相同。 备库收到bin log并且重放后，会生成新的bin log，新bin log的server id和原来bin log的server id一致。 备库收到主库发来的bin log时，会判断server id是否和自己的相等。如果相等，就表示这个日志是自己生成的，需要丢弃。 ","date":"2021-09-22","objectID":"/mysql-zhu-cong-fu-zhi/:5:0","tags":["MySQL"],"title":"【MySQL】主从复制","uri":"/mysql-zhu-cong-fu-zhi/"},{"categories":["MySQL"],"content":"sort_buffer MySQL会给每个连接线程分配一块内存，称为sort_buffer。order by的所有排序算法，都需要依靠这块内存来完成。 ","date":"2021-09-19","objectID":"/mysql-order-by/:1:0","tags":["MySQL"],"title":"【MySQL】Order By执行流程","uri":"/mysql-order-by/"},{"categories":["MySQL"],"content":"全字段排序 假设有一条查询语句： selectcity,name,agefromtwherecity='杭州'orderbynamelimit1000; 其中，字段city上有普通索引。 通常情况下，order by的执行流程为： 初始化sort_buffer，确定name、city、age三个字段。 从索引city找到满足条件的第一行记录，获取主键id。 从主键索引找到整行，取出name、city、age三个字段，放入sort buffer。 在索引city中继续取下一个记录。 对sort_buffer中的数据按照字段name做快速排序。 取前1000行返回。 ","date":"2021-09-19","objectID":"/mysql-order-by/:2:0","tags":["MySQL"],"title":"【MySQL】Order By执行流程","uri":"/mysql-order-by/"},{"categories":["MySQL"],"content":"rowid 排序 如果单行数据太大，MySQL会采用rowid排序。 参数max_length_for_sort_data用来控制排序数据的长度。如果单行数据长度超过该值，MySQL就认为单行太大，转而使用rowid排序。 还是同样的查询语句： selectcity,name,agefromtwherecity='杭州'orderbynamelimit1000; 同样，字段city上有普通索引。rowid排序的流程为： 初始化sort_buffer，确定name, id两个字段。 从索引city获取第一个满足要求的记录，获取主键id。 从主键索引取出整行，取name、id两个字段，存入sort_buffer。 从索引city取下一个记录。 对sort_buffer按name排序。 取前1000行，按照id的值回原表取city、name和age三个字段返回。 ","date":"2021-09-19","objectID":"/mysql-order-by/:3:0","tags":["MySQL"],"title":"【MySQL】Order By执行流程","uri":"/mysql-order-by/"},{"categories":["MySQL"],"content":"sort_buffer_size 排序操作可能在内存中完成，也可能使用外部排序。这取决于排序所需内存，和参数sort_buffer_size。 参数sort_buffer_size代表着sort_buffer的大小，如果待排序数据量小于该参数，排序就在内存中完成，否则就在临时文件中完成。 外部排序一般使用归并排序算法。 ","date":"2021-09-19","objectID":"/mysql-order-by/:4:0","tags":["MySQL"],"title":"【MySQL】Order By执行流程","uri":"/mysql-order-by/"},{"categories":["MySQL"],"content":"排序算法比较 如果内存够大，MySQL会优先选择全字段排序，因为rowid排序会多次回表，从而导致多次读磁盘。 ","date":"2021-09-19","objectID":"/mysql-order-by/:5:0","tags":["MySQL"],"title":"【MySQL】Order By执行流程","uri":"/mysql-order-by/"},{"categories":["MySQL"],"content":"一致性视图 MySQL中，有两个视图的概念： 一个是view，它是用查询语句定义的虚拟表，在调用时执行查询语句，并且生成结果。 另一个是InnoDB在实现MVCC时用到的一致性读视图，用于支持RC和RR隔离级别。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:1:0","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"对隔离级别的影响 隔离级别是利用一致性视图来实现的： 可重复读隔离级别下，视图是在事务启动时创建的，整个事务存在期间都用这个视图。 读提交级别下，视图是在每个SQL语句开始执行时创建的。 读未提交级别下，直接返回记录上的最新值，没有视图概念。 串行化级别下，通过直接加锁的方式避免并行访问。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:1:1","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"事务启动时机 begin/start transaction并不是一个事务的启动时间，只有执行到它们之后第一个操作InnoDB表的语句时，事务才启动。 对于可重复读隔离级别，一致性视图是在执行第一个快照读语句时创建。也可以使用start transaction with consistent snapshot启动一个事务，同时立即创建一个一致性视图。 如果autocommit=1，则每个语句就是一个事务，InnoDB会隐式执行begin和commit。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:1:2","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"事务ID InnoDB的每个事务有一个唯一的事务ID，叫transaction id。事务开始时申请，严格递增。 每行数据都有多个版本，每个版本有自己的row trx_id。事务更新数据时，会生成新的数据版本，并且把transaction id赋值给这个版本的row trx_id。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:1:3","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"视图数组 视图数组里保存的是，启动了但是还没提交的事务ID。 数组里事务ID最小值称为低水位，系统已经创建过的事务ID最大值称为高水位。 视图数组和高水位，组成了当前事务的一致性视图(read-view)。数据版本的可见性，是基于数据的row trx_id和一致性视图对比得到。 InnoDB就是这样利用所有数据都有多个版本的特性，实现了秒级创建快照的能力。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:1:4","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"数据可见性 对于某个数据版本的row trx_id： 如果等于当前事务的事务ID，当前事务可见。 如果小于低水位，当前事务可见。 如果大于高水位，当前事务不可见。 如果不小于低水位不大于高水位，且不在视图数组中，当前事务可见。 如果不小于低水位不大于高水位，且在视图数组中，不可见。 总结就是，对于一个事务视图： 自己的更新总可见。 版本未提交，不可见。 版本已提交，但是是在视图创建后提交，不可见。 版本已提交，而且是在视图创建前提交，可见。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:1:5","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"MVCC ","date":"2021-09-17","objectID":"/mysql-mvcc/:2:0","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"回滚日志 每条记录更新时，都会记录一条回滚日志。通过回滚日志，可以得到前一个状态的值。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:2:1","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"MVCC 同一条记录在系统中可以存在多个版本，这就是版本并发控制（MVCC）。 不同时刻启动的事务有不同的一致性视图，一致性视图结合回滚日志实现数据的版本并发控制。 通过一致性视图判断当前版本数据是否可见，如果不可见，就使用回滚日志查找它的上一个版本。 当没有事务需要用到这些回滚日志时，即没有比这个回滚日志更早的视图，回滚日志会被清除。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:2:2","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"当前读 当前读总是读取已经提交完成的最新版本，并且会对读取的记录加锁。 更新数据时都是先读后写的，而且只能读当前值，此时的读是当前读。 查询数据时，如果对select语句显式加锁，则也是当前读。加锁逻辑为： lock in share mode加读锁（S锁，共享锁）。 for update加写锁（X锁，排他锁）。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:3:0","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"当前读的实现 当前读是依靠next-key锁来实现的。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:3:1","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"快照读 快照读总是读取记录的可见版本，不用加锁。如简单的select语句即为快照读。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:4:0","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"快照读的实现 快照读依靠MVCC和undo log来实现的。 ","date":"2021-09-17","objectID":"/mysql-mvcc/:4:1","tags":["MySQL"],"title":"【MySQL】版本并发控制MVCC","uri":"/mysql-mvcc/"},{"categories":["MySQL"],"content":"MySQL 基本架构 MySQL主要由以下几个功能模块组成： 连接器。 查询缓存。 分析器。 优化器。 执行器。 存储引擎。 server层： 连接器、查询缓存、分析器、优化器、执行器组成了server层。 该层包含了所有的内置函数，所有的跨存储引擎功能也都在这一层，如存储过程、触发器、视图等。 存储引擎层： 存储引擎模块属于存储引擎层。 该层负责数据的存储和提取，其架构模式是插件式。 可以使用show engines查看引擎信息。MySQL5.5.5之后默认使用InnoDB。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:1:0","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"连接器 连接器，用于管理连接，权限验证。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:2:0","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"创建连接 连接命令一般为： mysql -h$ip -P$port -u$user -p 完成TCP握手后，连接器开始认证身份，此时会用到输入的用户名和密码。 如果用户名或者密码不对，返回\"Access denied for user\"。 如果认证通过，连接器会到权限表获取用户拥有的权限，用于之后所有的权限判断逻辑。 如果该用户的权限被修改，对于已通过认证的连接，拥有的权限不会受影响。只有重新建立连接，才会使用新权限。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:2:1","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"空闲连接 建立连接后，如果没有后续动作，该连接就处于空闲状态。可以使用show processlist查看空闲中的连接。 如果一直保持空闲状态，到一定时间连接器会将这个连接断开，该时间受wait_timeout控制，默认为8小时。 连接断开后，该连接再次发送请求的话，就会收到一个错误提醒。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:2:2","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"长连接和短连接 长连接是指，连接成功后，后续的请求一直使用同一个连接。 短链接是指，连接成功后，只执行完成很少的几次查询，就断开连接，下次查询时再重新建立一个。 建立连接的过程比较复杂，所以应尽量使用长连接。但是在MySQL中，使用长连接也会存在问题。 MySQL执行过程中临时使用到的内存，是管理在连接对象里面的，在连接断开时，资源才会释放。如果长连接一直积累，就会导致内存占用太大，被系统强行杀掉，从而导致MySQL异常重启。 要解决长连接问题，可以考虑两种方案： 定期断开长连接。 MySQL5.7或之后版本，每次执行完一个较大操作，可以使用mysql_reset_connection来初始化连接资源，包括事务回滚、锁释放等。初始化过程中，不会重连和重新验证权限，只会恢复到连接刚刚创建完的状态。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:2:3","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"查询缓存 之前的查询语句和结果，会以key-value对的形式，缓存在内存中。如果查询时能在缓存中找到这个key，那么value会被直接返回。如果找不到，才继续后面的阶段。 返回结果的时候，会做权限验证。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:3:0","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"按需使用 查询缓存的失效非常频繁，一个表只要有更新，这个表上的所有查询缓存都会被清空。对于更新压力大的数据库来说，查询缓存的命中率非常低。 静态表可以使用查询缓存，如系统配置相关表。 MySQL8.0已经删除了查询缓存。其它版本可以通过设置query_cache_type进行控制。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:3:1","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"query_cache_type 该参数有三个不同的值： OFF：关闭查询缓存。 ON：缓存所有结果，除非在select语句中使用SQL_NO_CACHE禁止缓存。 DEMAND：在select语句中使用SQL_CACHE时进行缓存。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:3:2","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"分析器 分析器会进行词法分析、语法分析。 除了检查语法对不对之外，还会检查库名、表名和字段名是否正确。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:4:0","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"优化器 优化器会根据SQL语句，生成多个查询路径树，然后从中选择一个最优解。如有多个索引时，决定使用哪个索引；使用join时，决定各个表的连接顺序等。 使用优化器之前，会调用precheck验证权限。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:5:0","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"执行器 根据表的引擎定义，调用对应的引擎接口，从而完成SQL语句的执行。 执行前，需要判断一下是否有表的执行权限。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:6:0","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"查询的执行流程 现在以查询语句为例，说明执行器的执行流程。 对于无索引数据： 调用接口取这个表的第一行。 如果满足要求就加入结果集，如果不满足就跳过。 直到这个表的最后一行，然后将结果集返回客户端。 对于有索引数据： 取满足条件的第一行，加入结果集。 循环取满足条件的下一行。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:6:1","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"rows_examined 慢查询日志中有一个rows_examined参数，表示语句执行过程中扫描了多少行。 执行器每次调用引擎获取数据时，会对rows_examined进行累加，即该值等于执行器通过引擎接口获取的数据行数。 但是执行器每调用一次接口，引擎内部可能扫描多行。 ","date":"2021-09-17","objectID":"/mysql-ji-ben-jia-gou/:6:2","tags":["MySQL"],"title":"【MySQL】基本架构","uri":"/mysql-ji-ben-jia-gou/"},{"categories":["MySQL"],"content":"Join 原理 常有人说，查询数据时不要使用Join，因为性能很差。然而，你是否好奇过，事实真的是这样吗？ 为了能准确分析出Join语法的执行效率，接下来将会对Join的原理进行讨论。 ","date":"2021-09-17","objectID":"/mysql-join/:1:0","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"Index Nested-Loop Join Index Nested-Loop Join简称为NLJ，算法的具体执行流程为： 从表1中读取一行记录。 取出这行记录的指定字段，去表2进行查找。 从表2中取出满足条件的行，与步骤1取出的行组成结果集。 重复执行上述步骤，直到读取完表1的记录。 上述算法的重要前提是，被驱动表可以使用索引。此时，因为使用到了表2的索引，所以Join的性能较好。 ","date":"2021-09-17","objectID":"/mysql-join/:1:1","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"Simple Nested-Loop Join 该算法的使用前提是，被驱动表无法使用索引。 因为无法使用索引，所以每次去被驱动表做匹配时，都需要进行全表扫描，性能很差。 注意，无索引情况下，MySQL使用的是Block Nested-Loop Join算法。 ","date":"2021-09-17","objectID":"/mysql-join/:1:2","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"Block Nested-Loop Join Block Nested-Loop Join简称BNL，该算法也不会用到被驱动表的索引。 具体的执行流程为： 将表1的数据全部读入join_buffer中。 遍历表2，读取每一行数据。 每从表2中读取一行数据，就去join_buffer中做匹配。如果满足条件，就放入结果集。 BNL与Simple Nested-Loop Join的区别在于，BNL的匹配操作是在内存中完成的，速度更快。 如果join_buffer内存放不下表1的所有数据，则执行流程为： 扫描表1，顺序读取部分数据，放入join_buffer中。 扫描表2，读取每一行数据。 从表2中每读取一行数据，就跟join_buffer做对比。如果满足条件，就放入结果集。 清空join_buffer。 继续扫描表1，然后执行步骤2，直到数据扫描完毕。 join_buffer的大小受参数join_buffer_size控制，默认是256k。该参数设置的越大，可以容纳的表1数据就会越多，被驱动表的扫描次数越少，性能也会越好。 ","date":"2021-09-17","objectID":"/mysql-join/:1:3","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"Join 使用建议 ","date":"2021-09-17","objectID":"/mysql-join/:2:0","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"1. 使用场景 如果能使用到被驱动表的索引，则可以使用Join。 如果不能使用到被驱动表的索引，查询时会扫描过多行数。在这种情况下，尽量不要使用Join。 ","date":"2021-09-17","objectID":"/mysql-join/:2:1","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"驱动表的选择 对于Index Nested-Loop Join，应选择小表做驱动表。 对于Simple Nested-Loop Join，无论哪张表做驱动表，性能都是一样的。 对于Block Nested-Loop Join，如果join_buffer_size足够大，则任何一种选择都没差别，如果不够大，则选择小表做驱动表。 可以根据执行计划的extra字段，来判断join使用的是何种算法。 ","date":"2021-09-17","objectID":"/mysql-join/:2:2","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"如何查找小表 查找小表的步骤如下： 先将所有表按照条件过滤。 然后计算参与join的各个字段的总数据量。 数据量小的就是小表。 ","date":"2021-09-17","objectID":"/mysql-join/:2:3","tags":["MySQL"],"title":"【MySQL】Join原理","uri":"/mysql-join/"},{"categories":["MySQL"],"content":"预读机制 预读机制是相对于Innodb存储引擎而言的。 所谓预读机制，就是在加载数据页时，可能会将相邻数据页一起预先加载到buffer pool中，之后读取时就可以直接从内存获取，不必从磁盘读入。 使用Innodb的预读机制，可以减少磁盘IO次数，提高读写性能。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:1:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"预读模式 Innodb一共提供了两种预读模式： 线性预读：判断当前extend中的数据是否被连续访问，从而决定是否把下一个extend从磁盘中读出来，加载到buffer pool。 随机预读：判断当前extend中被读取的page个数，从而决定是否把当前extend的数据全部加载到buffer pool中。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:2:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"线性预读 MySQL5.5之后，默认使用的是线性预读模式，与之有关的配置为innodb_read_ahead_threshold，这个参数表示，当前extend中，如果有超过innodb_read_ahead_threshold个page被连续访问，就预加载相邻的extend的数据。 innodb_read_ahead_threshold的默认参数是56，最大为64，最小为0。如果为0，表示关闭线性预读。在关闭了线性预读的情况下，如果随机预读没有显式打开，就不会使用随机预读。 innodb组织数据的顺序为tablespace, segment, extend, page, row，因为extend固定为1MB，page默认为16KB，一个extend能容纳64个page，所以innodb_read_ahead_threshold最大为64。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:3:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"预读原理 连续访问，是根据page的最新一次访问时间来判断的。 如果当前page是extend的第一个，则看后面的63个page，如果访问时间连续递减的个数，大于等于innodb_read_ahead_threshold，就加载上一个extend。 如果当前page是extend的最后一个，则看前面的63个page，如果访问时间连续递增的个数，大于等于innodb_read_ahead_threshold，就加载下一个extend。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:3:1","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["MySQL"],"content":"随机预读 MySQL5.5之后，随机预读是默认关闭的。 与随机预读有关的配置为innodb_random_read_ahead。 ","date":"2021-06-13","objectID":"/mysql_innodb_read_ahead/:4:0","tags":["MySQL"],"title":"【MySQL】预读机制","uri":"/mysql_innodb_read_ahead/"},{"categories":["操作系统"],"content":"磁盘的结构 磁盘的组成结构包括：盘片、盘面、磁道、扇区、磁头、磁臂、柱面。 盘片。 一个磁盘由多个盘片叠加而成。 盘片表面由磁性物质组成，可以用来记录二进制数据。 盘面。 盘片涂上磁性物质的那一面称为盘面，一个盘片可以有两个盘面。 每个盘面都有一个编号，从0开始。 磁道。 磁盘的磁面被划分成很多个圈，一个圈就是一个磁道。 扇区。 一个磁道被划分为多个扇区，每个扇区存放的数据量相同。 最内侧磁道的扇区，数据密度最大。 磁头。 每个盘面对应一个磁头。 磁臂。 所有磁头都是连在同一个磁臂上的。 柱面。 所有盘面中相对位置相同的磁道组成了柱面。 ","date":"2021-06-06","objectID":"/os-ci-pan/:1:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"磁盘的物理地址 ","date":"2021-06-06","objectID":"/os-ci-pan/:2:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"地址结构 对于每一个磁盘块，使用**（柱面号， 盘面号，扇区号）**的地址形式来表示。 ","date":"2021-06-06","objectID":"/os-ci-pan/:2:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"地址结构设计原理 如果采用 （盘面号，柱面号，扇区号） 的地址形式，一个盘面磁道读写完，就需要启动磁头臂，将磁头移入下一个柱面。 如果采用 （柱面号，盘面号，扇区号） 的地址形式，一个盘面磁道读写完，不需要移动磁头臂，只需要激活写一个盘面的磁头即可。 ","date":"2021-06-06","objectID":"/os-ci-pan/:2:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"在磁盘中读/写数据 根据柱面号，移动磁臂，将磁头指向指定柱面。 根据盘面号，激活指定盘面的磁头。 当指定扇区从磁头下划过时，就能完成数据读/写。 ","date":"2021-06-06","objectID":"/os-ci-pan/:2:3","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"磁盘分类 活动头磁盘：磁头可以移动。 固定头磁盘：磁头不可移动，每个磁道有一个磁头。 可换片磁盘：盘片可以更换。 固定盘磁盘：盘片不可更换。 ","date":"2021-06-06","objectID":"/os-ci-pan/:3:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"一次磁盘读写花费的时间 寻找时间（寻道时间）。 在读写数据前，将磁头移动到指定磁道所花的时间。包括两部分：启动磁头臂的时间 + 移动磁头的时间。 延迟时间。 旋转磁盘使磁头定位到指定扇区所用的时间。平均延迟时间为：平均延迟时间 = (1/2)*(1/r)，1/2表示平均要转动半圈。r表示每分钟转多少圈。 传输时间。 读写数据所用时间。 总时间为上述三个时间的总和。 ","date":"2021-06-06","objectID":"/os-ci-pan/:4:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"磁盘调度算法 不同的磁盘调度算法所需的寻道时间不同。 常见的磁盘调度算法为： 先来先服务算法。 最短寻找时间优先。 扫描算法。 Look调度算法。 循环扫描算法。 C-Look调度算法。 ","date":"2021-06-06","objectID":"/os-ci-pan/:5:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"1. 先来先服务算法 根据进程请求访问磁盘的先后顺序进行调度。 优点：公平；如果请求的磁道比较集中，性能还可以。 缺点：如果请求访问的磁道分散，则寻道时间长，性能很差。 ","date":"2021-06-06","objectID":"/os-ci-pan/:5:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"2. 最短寻找时间优先 优先处理与当前磁头最近的磁道。可以保证每次寻道时间最短，但是不能保证总寻道时间最短。 优点：性能较好，平均寻道时间短。 缺点：可能产生饥饿。 ","date":"2021-06-06","objectID":"/os-ci-pan/:5:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"3. 扫描算法 也叫电梯算法，磁头只有移动到最外侧磁道的时候，才能往内移动，只有移动到最内侧的时候，才能往外移动。 优点：性能较好，平均寻道时间较短，不会产生饥饿现象。 缺点：对各个磁道的响应不平均；可能会产生不必要的移动。 ","date":"2021-06-06","objectID":"/os-ci-pan/:5:3","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"4. Look 调度算法 类似于扫描算法，但是如果在磁头移动方向上，已经没有请求了，就立即改变磁头移动方向。 优点：寻道时间比扫描算法跟短。 ","date":"2021-06-06","objectID":"/os-ci-pan/:5:4","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"5. 循环扫描算法 规定磁头朝一个方向移动时才处理访问请求，移动到尽头后直接返回到起始端，该过程不处理请求。 优点：每个磁道的响应都很平均，寻道时间比扫描算法更短。 缺点：会产生不必要的移动。 ","date":"2021-06-06","objectID":"/os-ci-pan/:5:5","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"6. C-Look 调度算法 类似于循环扫描算法。但是，如果移动方向上没有请求了，就立即让磁头返回，并且只返回到需要访问的磁道位置。 优点：寻道时间进一步缩短。 ","date":"2021-06-06","objectID":"/os-ci-pan/:5:6","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"优化延迟时间 磁头读写一个扇区后，需要一小段时间做其他处理，然后才能继续操作其他扇区，但是磁盘会继续旋转，此时就会错过下个扇区。 如果逻辑相邻的扇区，在物理上也相邻，读写下个扇区时，就需要磁盘多转一轮，从而导致延迟时间变长。 根据上述原理，有两种减少延迟时间的办法：交替编号和错位命名。 ","date":"2021-06-06","objectID":"/os-ci-pan/:6:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"1. 交替编号 让逻辑相邻的扇区在物理上不相邻，如（0，4，1，5，2，6，3，7）。 ","date":"2021-06-06","objectID":"/os-ci-pan/:6:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"2. 错位命名 让相邻盘面的扇区编号错位。如上个盘面的0对应下个盘面的7。 ","date":"2021-06-06","objectID":"/os-ci-pan/:6:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"磁盘格式化 低级格式化：又称物理格式化，将磁盘的各个磁道划分为扇区。一个扇区由头、数据区域、尾三个部分组成。 将磁盘分区，每个分区由若干个柱面组成。如C盘，D盘。 进行逻辑格式化，创建文件系统。 ","date":"2021-06-06","objectID":"/os-ci-pan/:7:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"引导块 ","date":"2021-06-06","objectID":"/os-ci-pan/:8:0","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"初始化程序 计算机开机时，需要进行一系列初始化工作，这些工作是通过“初始化程序”完成的。 初始化程序可以放在只读存储器ROM中，ROM中的数据在出厂时就写入了，并且不能再修改。 ","date":"2021-06-06","objectID":"/os-ci-pan/:8:1","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"启动分区 如果初始化程序放在ROM中，就很难再去更新，所以通常将完整的初始化程序放在磁盘的启动分区上。启动分区位于磁盘固定位置，拥有启动分区的磁盘称为启动磁盘，或者系统磁盘。 ROM只存放很小的“自举装入程序”。开机时，计算机通过运行该程序找到启动分区，然后将完成的初始化程序读入内存，进行初始化。 ","date":"2021-06-06","objectID":"/os-ci-pan/:8:2","tags":["操作系统"],"title":"【操作系统】磁盘","uri":"/os-ci-pan/"},{"categories":["操作系统"],"content":"机器指令是什么 机器指令，是CPU能识别和执行的最基本命令。 一条高级语言写的代码，经过编译，可能会生成多条机器指令。而程序运行的本质，就是CPU执行一条一条的机器指令。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:1:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"特权指令和非特权指令 CPU将机器指令分为了“特权指令”和“非特权指令”。 应用程序只能执行非特权指令，操作系统内核可以执行特权指令。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:2:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"用户态和核心态 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:3:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"1. 什么是用户态 用户态又称目态。当运行的是应用程序时，称CPU处于用户态，只能执行非特权指令。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:3:1","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"2. 什么是内核态 内核态又称核心态、管态。当运行的是内核程序时，称CPU处于内核态，可以执行特权指令。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:3:2","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"3. 用户态和内核态的相互转换 用户态到内核态的转变，由中断信号引发，硬件自动完成转变过程。只要触发中断信号，操作系统就会抢占CPU的使用权。 CPU中存在一个寄存器，叫程序状态寄存器（PSW），它有一个二进制位，1表示处于内核态，0表示处于用户态。 核心态到用户态的转变，由一条修改PSW标志位的特权指令完成，将标志位置为0即表示回到了用户态。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:3:3","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"系统调用 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:4:0","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"1. 什么是系统调用 “系统调用”是操作系统提供给应用程序使用的接口，应用程序可以通过系统调用来请求获得操作系统内核的服务。使用系统调用，可以保证系统的稳定性和安全性。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:4:1","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"2. 库函数 编程语言提供的库函数，有时会将系统调用封装起来，以隐藏一些调用细节，从而使编程更加方便。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:4:2","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["操作系统"],"content":"3. 系统调用的功能 系统调用具备的主要功能为： 设备管理。 文件管理。 进程控制。 进程通信。 内存管理。 系统调用的存在，使得用户可以使用操作系统内核提供的功能，有效区分了用户态和内核态。 ","date":"2021-05-06","objectID":"/os-yong-hu-tai-he-nei-he-tai/:4:3","tags":["操作系统"],"title":"【操作系统】用户态和内核态","uri":"/os-yong-hu-tai-he-nei-he-tai/"},{"categories":["Linux"],"content":"在Linux中，查找文件的方法有很多，现在介绍常见的几个工具。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:0:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"locate 这是较为简单的文件搜索命令。 locate命令通过快速搜索数据库，从而找到路径名与给定字符串相匹配的文件，并输出结果。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:1:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"命令格式 命令格式如下： locate [options] [pattern] ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:1:1","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"options 常见的选项如下： -A: -all，只输出同时匹配所有模式的文件。默认情况下，文件只要匹配某个模式就会被打印。 -V: 打印版本信息。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:1:2","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"pattern 搜索时，不要求文件和模式完全匹配，即搜索支持通配符。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:1:3","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"数据库 linux系统中通常会开启一个定时任务，然后每隔一段时间执行一次updatedb程序命令，从而生成新的数据库文件。locate搜索时，会在这个数据库文件中进行查找。 linux系统中的数据库通常位于/var/lib/mlocate/mlocate.db。 locate搜索到的结果，并不一定是当前的最新的文件。如果想获得最新的结果，可以切换到root用户，并执行updatedb。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:1:4","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"find find命令除了可以根据文件名搜索文件外，还可以根据各种属性进行文件查找，其支持的特性非常丰富。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:2:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"命令格式 find的命令格式如下： find [path] [options] [expression] 如果省略path，则默认在当前目录下搜索。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:2:1","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"常见选项参数 常见的选项为： -cmin。 后跟参数： n: n分钟前的那个时刻，内容或属性改变的文件或目录。 +n: 超过n分钟。 -n: 不足n分钟。 -cnewer file。 内容或属性的修改时间晚于file的文件或目录。 -ctime 后跟参数： n: n*24小时前的那个时刻，内容或属性发生改变的文件或目录。 +n: 超过n*24小时。 -n: 不足n*24小时。 -empty 匹配空文件或空目录。 -group name 匹配属于name组的文件或目录，name可以是组名，或者组ID。 -name pattern 和通配符匹配的文件或目录。 -iname pattern 和-name类似，只是文件或目录不区分大小写。 -inum n 匹配索引节点是n的文件，通常用于查找硬连接。 -mmin 后跟参数： n: n分钟前的那个时刻，内容被修改的文件或目录。 +n: 超过n分钟。 -n: 不足n分钟。 -mtime 后跟参数： n: n*24小时前的那个时刻，内容被修改的文件或目录。 -n: 不足n小时。 +n: 超过n小时。 -newer file 匹配内容的修改时间晚于file的文件或目录。 -nouser 匹配不属于有效用户的文件或目录。当用户被删除时，该命令可以用于删除无用文件。 -nogroup 匹配不属于有效用户组的文件或目录。 -perm mode 与指定权限匹配的文件或目录。 -samefile file 与-inum类似，匹配与file具有相同inode的文件。 -size 后跟参数： n: 匹配大小等于n的文件或目录。 +n: 匹配大小超过n的文件或目录。 -n: 匹配大小不足n的文件或目录。 n的计量单位可以是： b: 512字节的块。 c: 字节，如-size 1c。 w: 两个字节的字。 k: KB。 M: MB。 G: GB。 -type t 匹配t类型的目标。t可以是： b: 块设备文件。 c: 字符设备文件 d: 目录。 f: 普通文件。 l: 符号链接。 -user name 匹配属于name用户的文件或目录，name可以是用户名，或者用户ID。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:2:2","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"逻辑操作 逻辑操作也是options中的一种。 -and：将多个检验条件以“逻辑与”的关系组合起来，表示“逻辑与”的关系时，可以省略该操作符。简写为-a。 -or：将多个检验条件以“逻辑或”的关系组合起来，简写为-o。 -not：匹配使该操作符之后的条件为假的文件或目录。 ()：默认情况下，find命令从左向右进行运算，而括号()可以改变运算优先级。通常()前需要使用引号或者反斜线，如\\(\\)。 逻辑操作符采用惰性运算，即如果操作符左边的条件能确定最终结果，就不再执行右边的操作。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:2:3","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"其他选项 find命令还有一些其他的常见选项： -depth：要求find先处理完文件，再处理目录。 -mindepth levels：从该层级的子目录开始搜索。 -maxdepth levels：搜索的最大子目录层级。 -mount：不去遍历挂载在其他文件系统上的目录。 -noleaf：要求find程序不要以“正在搜索类UNIX文件系统“为假设来优化搜索，在DOS/Windows系统上会用到该选项。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:2:4","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"path 如果省略path，则默认在当前目录下搜索。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:2:5","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"expression 找到文件后，就可以根据expression对文件进行处理了。 find中有一些预定义的动作： -delete：删除匹配文件。 -ls：以标准格式输出匹配文件。 -print：输出匹配文件，默认情况下就是执行该操作。 -quit：一旦匹配成功就退出。 find还可以根据需要自定义动作，自定义方法为： -exec [commands] {} [commands] ; # {} 表示被匹配的文件 # ; 需要使用引号或者反斜线来进行转义 # -ok 作用类似于-exec，只是执行命令前会询问用户 上述方法会对每个匹配文件执行一遍自定义命令，如果只想对所有匹配文件执行一次命令，可以使用下述方法： -exec [commands] {} [commands] + # 或者 find [options] [path] [expression] | xargs commands ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:2:6","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"whereis whereis用来查找满足条件的二进制文件、帮助文件和源代码文件。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:3:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"具体用法 用法为： whereis [options] 文件 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:3:1","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"常见选项 -b：只搜索二进制文件。 -B \u003c目录\u003e：指定二进制文件搜索路径。 -m：只搜索man帮助文档。 -M \u003c目录\u003e：指定帮助文档搜索路径。 -s：只搜索源代码文件。 -S \u003c目录\u003e：指定源代码文件搜索路径。 -l：输出有效查找路径。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:3:2","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"文件分类方式 whereis有一套自己的文件搜索方式，它规定了二进制文件、帮助文档或者源代码文件的搜索目录。 使用whereis -l即可查看具体搜索路径。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:3:3","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"which which用于在PATH路径中查找可执行程序，并输出具体路径。如： which ls # /usr/bin/ls ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:4:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"总结 以上就是Linux中较为常见的文件搜索工具，各自无优劣之分，可以根据需要选择合适的使用。 ","date":"2021-03-10","objectID":"/linux-wen-jian-sou-suo/:5:0","tags":["Linux"],"title":"【Linux】文件搜索","uri":"/linux-wen-jian-sou-suo/"},{"categories":["Linux"],"content":"什么是 gawk gawk是Unix中原始awk程序的GNU版本，可以将gawk看成是一种编程语言，并用它处理数据。 gawk的执行流程和sed类似，首先从标准输入stdin或者文件中读取数据，每次读取一行，并针对该行数据执行脚本命令，然后继续读取下一行并重复前面的操作。 ","date":"2021-02-10","objectID":"/linux-gawk/:1:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"gawk 命令格式 gawk命令格式为： gawk options program file ","date":"2021-02-10","objectID":"/linux-gawk/:2:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. options 常见的options为： -F fs 指定每行数据的字段分隔符，如-F;表示以;为字段分隔符。 默认的字段分隔符是空白字符（空格或者制表符）。 -f file gawk程序可以预先写在文件中，-f用于从指定文件读取程序。 -v var=value 为gawk程序定义变量。 ","date":"2021-02-10","objectID":"/linux-gawk/:2:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. program gawk的脚本命令必须放在花括号{}中，如： gawk '{print \"hello world\"}' 程序命令可以有多条，如果多条命令位于同一行，需要用;分开。如： gawk '{print \"hello\"; print \"world\"}' 多条命令也可以位于多行，此时，多条命令之间不需要分隔符。如： gawk '{ print \"hello\" print \"world\" }' 在对数据进行处理前，可以执行指定命令，这些命令放在BEGIN命令块中。如： gawk 'BEGIN{print \"Title\"}' 数据处理结束后，也可以执行指定命令，这些命令放在END命令块中。如： gawk 'END{print \"End of File\"}' 如果只指定了BEGIN命令块或者END命令块，缺少数据处理命令，则不会对输入数据做任何操作。 ","date":"2021-02-10","objectID":"/linux-gawk/:2:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. file 如果gawk命令行中没有指定file，则从标准输入读取数据，否则就从指定文件读取数据。 如：执行命令gawk '{print \"hello world\"}'后，程序会从stdin接收数据，并打印hello world。此时，可以使用Ctrl + d组合键来终止程序，该组合键会发送EOF字符。 ","date":"2021-02-10","objectID":"/linux-gawk/:2:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"变量 ","date":"2021-02-10","objectID":"/linux-gawk/:3:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. 数据字段变量 每行的数据字段都会对应一个变量，字段是根据字段分隔符来划分的。 $0：代表整行文本。 $1：代表第一个字段。 $2：代表第二个字段。 $n：代表第n个字段。 ","date":"2021-02-10","objectID":"/linux-gawk/:3:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. 内建变量 假设data.txt是一个文本文件。 FIELDWIDTHS 该命令后面会跟上一串数字，如\"3 2 1\"，用来定义每个数据字段的宽度。如： gawk 'BEGIN{FIELDWIDTHS=\"3 2 1\"} {print $1, $2, $3}' data.txt 使用了FIELDWIDTHS后，字段分隔符会被忽略。 FS 指定输入数据的字段分隔符。如： gawk 'BEGIN{FS=\":\"} {print $1, $2, $3}' data.txt RS 指定输入数据的行分隔符。如： # 指定空白行为行分隔符 gawk 'BEGIN{RS=\"\"} {print $0}' data.txt OFS 指定输出数据的字段分隔符。如： gawk 'BEGIN{OFS=\";\"} {print $1, $2, $3}' data.txt ORS 指定输出数据的行分隔符。如： gawk 'BEGIN{ORS=\",\"} {print $0}' data.txt ARGC 存放的是当前命令行参数的个数。如： gawk '{print ARGC}' data.txt data.txt # 输出是3，脚本命令和选项不参与计数 ARGV 由命令行参数组成的数组。如： gawk '{print ARGC, ARGV[0], ARGV[1]}' data.txt # 2 gawk data.txt ARGIND 表示当前文件在ARGV中的位置。如： gawk '{print ARGIND}' data.txt data.txt # 1 2 ENVIRON 由当前shell环境变量组成的关联数组。如： # 输出HOME目录 gawk '{print ENVIRON[\"HOME\"]}' data.txt FILENAME 当前文件的文件名。如： gawk '{print FILENAME}' data.txt # data.txt NF 当前行的字段总数。如： gawk '{print NF, $NF}' data.txt FNR 当前文件已读取的数据行数，遇到新的文件时，会重新从1开始计数。如： gawk '{print FNR}' data.txt data.txt # 1 1 NR 已读取的总数据行数，遇到新文件时，会进行累计，而不是重新计数。如： gawk '{print NR}' data.txt data.txt # 1 2 ","date":"2021-02-10","objectID":"/linux-gawk/:3:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. 自定义变量 变量名由字母、数字、下划线组成，但是不能以数字开头。 自定义变量的定义方式由多种： 在程序脚本中定义变量。如： gawk 'BEGIN{test=\"test line\"; print test; test=1; print test}' # test line # 1 在命令行中定义变量，且变量定义位于程序脚本之后。如： gawk '{print $n}' n=1 data.txt 这种方式定义的变量，不能在BEGIN命令块中使用。 在命令行中定义变量，且变量定义位于程序脚本之前。此时需要使用-v选项。如： gawk -v n=2 'BEGIN{print n}' ","date":"2021-02-10","objectID":"/linux-gawk/:3:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"数组 gawk编程语言使用关联数组来实现数组功能。 关联数组的索引值不再必须是连续的数字，而是可以使用任意文本字符串。 ","date":"2021-02-10","objectID":"/linux-gawk/:4:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. 数组定义 定义方式为： arr[index] = value 索引查找方式为： arr[index] ","date":"2021-02-10","objectID":"/linux-gawk/:4:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. 遍历数组 数组遍历的语法为： for (idx in array) { statements } 如果statements只有一行，则可以省略外层的花括号，如： for (idx in array) statements 数组遍历的结果是没有固定顺序的。 ","date":"2021-02-10","objectID":"/linux-gawk/:4:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. 删除数组中的变量 删除语法为： delete array[index] ","date":"2021-02-10","objectID":"/linux-gawk/:4:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"算数运算符 gawk支持下列算数运算符： +：加。 -：减。 *：乘。 /：除。 %：取余。 ^或者**：乘方。 ++x：x加1，然后返回x。 x++：先返回x，然后x加一。 --x：x减一，然后返回x。 x--：先返回x，然后x减一。 ","date":"2021-02-10","objectID":"/linux-gawk/:5:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"模式 在gawk程序脚本中，可以使用不同类型的匹配模式，来过滤数据行。 BEGIN和END可以看成是两个特殊模式。 ","date":"2021-02-10","objectID":"/linux-gawk/:6:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. 正则表达式 可以使用正则表达式，来对数据行进行匹配。如： gawk '/root/{print $1}' /etc/passwd 该命令会匹配包含root的数据行。 还可以使用匹配操作符~，来对某个特定字段进行匹配，如： gawk '$1 ~ /^root/{print $0}' /etc/passwd 该命令会匹配第一个字段以root开头的数据行。 还可以使用!~来排除匹配行。如： gawk '$1 !~ /^root/{print $0}' /etc/passwd 该命令会过滤第一个字段以root开头的数据行。 ","date":"2021-02-10","objectID":"/linux-gawk/:6:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. 数学比较表达式 可以使用的数学比较表达式有： x == y x \u003c= y x \u003c y x \u003e= y x \u003e y 比较双方，既可以为数字，也可以是任意字符串。 ","date":"2021-02-10","objectID":"/linux-gawk/:6:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"流程控制语句 gawk支持多种流程控制语句： if...else...、 while...、 do...while...、 for循环 ","date":"2021-02-10","objectID":"/linux-gawk/:7:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"1. if…else… 语法格式为： if (condition1) { statement1 } else if (condition2) { statement2 } else { statement3 } 如果statement只有一行命令，则可以省略外层花括号。 还可以将上述命令写成一行。此时，在省略花括号的情况下，必须用分号分隔每个if语句。 ","date":"2021-02-10","objectID":"/linux-gawk/:7:1","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"2. while… 语法格式为： while (condition) { statements } 可以使用break或者continue跳出循环。 ","date":"2021-02-10","objectID":"/linux-gawk/:7:2","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"3. do…while… 语法格式为： do { statements } while (condition) ","date":"2021-02-10","objectID":"/linux-gawk/:7:3","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"4. for循环 gawk支持c语言风格的for循环。语法格式为： for (variable assignment; condition; iteration process) { statements } ","date":"2021-02-10","objectID":"/linux-gawk/:7:4","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"printf gawk可以使用printf进行格式化打印。 printf的命令格式为： printf \"format string\", var1, var2... format string是格式化字符，其中包含文本字符和占位符。 占位符格式为：%[modifier]control-letter，modifier是修饰符，control-letter是控制字符。 control-letter列表如下： c：以ASCII形式显示。如： gawk 'BEGIN{printf \"%c\\n\", 65}' # A d：显示整数值。如： gawk 'BEGIN{printf \"%d\\n\", 65}' # 65 i：显示整数值，和d一样。如： gawk 'BEGIN{printf \"%i\\n\", 65}' e：以科学记数法形式显示一个数。如： gawk 'BEGIN{printf \"%.2e\\n\", 100000}' # 1.00e+05 f：显示浮点数。如： gawk 'BEGIN{printf \"%f\\n\", 3.141}' # 3.141000 g：用科学记数法或浮点数显示（选择较短的格式）。如： gawk 'BEGIN{printf \"%g\\n\", 0.0000001}' # 1e-07 o：显示为八进制。如： gawk 'BEGIN{printf \"%o\\n\", 10}' # 12 s：打印一个字符串。 gawk 'BEGIN{printf \"%s\\n\", \"hello world\"}' # hello world x：显示为十六进制。如： gawk 'BEGIN{printf \"%x\\n\", 10}' # a X：显示为十六进制，但是使用大写A~F。 gawk 'BEGIN{printf \"%X\\n\", 10}' # A modifier如下： width：输出字段最小宽度。 prec：指定浮点数的最小宽度和精度。 -：文本设置为左对齐，默认是右对齐。 +：文本设置为右对齐。 #：在八进制数前显示0，在十六进制前显示0x。 ","date":"2021-02-10","objectID":"/linux-gawk/:8:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["Linux"],"content":"结语 gawk还有很多有用的特性，如函数等，对此暂时不做说明。 ","date":"2021-02-10","objectID":"/linux-gawk/:9:0","tags":["Linux","gawk","awk"],"title":"【Linux】gawk详解","uri":"/linux-gawk/"},{"categories":["操作系统"],"content":"中断 中断是为了实现多道程序并发执行，而引入的一种机制 中断发生时，CPU立即进入核心态 当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理 对于不同的中断信号，会进行不同处理 ","date":"2021-02-06","objectID":"/os-zhong-duan/:1:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/os-zhong-duan/"},{"categories":["操作系统"],"content":"中断的作用 中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。 如果没有中断，cpu将一直运行应用程序，从而无法执行操作系统内核程序。 中断是用户态进入核心态的唯一途径。 核心态到用户态的切换，是通过执行一个特权指令来完成。该指令将程序状态字PSW的标志位设置为用户态。 ","date":"2021-02-06","objectID":"/os-zhong-duan/:2:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/os-zhong-duan/"},{"categories":["操作系统"],"content":"中断分类 广义上的中断分为两类： 内中断：信号来源于CPU内部，与当前执行的指令有关。 外中断：信号来源于CPU外部，与当前执行的指令无关。 狭义上的中断，就是指外中断，而此时内中断会被称为“异常”。 ","date":"2021-02-06","objectID":"/os-zhong-duan/:3:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/os-zhong-duan/"},{"categories":["操作系统"],"content":"1. 内中断 也称异常、例外。内中断主要有3类： 陷阱、陷入（trap) 由陷入指令引发，此时，应用程序主动将CPU使用权交给操作系统内核。 系统调用就是通过陷入指令实现。 故障（fault) 由错误条件引起，可能会被内核程序修复。 内核程序修复故障后，会讲CPU使用权交还给应用程序。 如：缺页故障。 终止（abort) 由致命错误引起，内核程序通常会直接终止应用程序，不会将CPU使用权归还给应用程序。 如：整数除0。 ","date":"2021-02-06","objectID":"/os-zhong-duan/:3:1","tags":["操作系统"],"title":"【操作系统】中断","uri":"/os-zhong-duan/"},{"categories":["操作系统"],"content":"2. 外中断 每一条指令执行结束，CPU都会检查是否有外部中断信号，如果有，就执行中断处理程序。 常见的外中断，有时钟中断，IO中断请求。 ","date":"2021-02-06","objectID":"/os-zhong-duan/:3:2","tags":["操作系统"],"title":"【操作系统】中断","uri":"/os-zhong-duan/"},{"categories":["操作系统"],"content":"中断运行原理 不同的中断信号，需要用不同的中断处理程序来处理。 中断处理程序，一定是内核程序，需要运行在“内核态”。 当CPU检测到中断信号后，会查询中断向量表，找到相应的中断处理程序在内存中的存放位置。中断向量表是由中断信号类型、和中断处理程序指针组成。 ","date":"2021-02-06","objectID":"/os-zhong-duan/:4:0","tags":["操作系统"],"title":"【操作系统】中断","uri":"/os-zhong-duan/"},{"categories":["操作系统"],"content":"什么是内存 内存是存放数据的硬件，程序执行前，需要先放到内存中才能被CPU处理。 内存由一个个存储单元组成。 地址从0开始，每个地址对应一个存储单元。 如果按字节编址，则每个存储单元大小为1个字节。 如果按字编址，则每个存储单元的大小为一个字，字的大小视不同计算机的情况而言。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:1:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"程序执行过程 1.若干源代码文件 编译 -\u003e 2. 汇编文件（使用汇编语言） 汇编 -\u003e 3.若干目标模块（机器指令、通常使用逻辑地址） 链接 -\u003e 4.装入模块，如`.exe`（通常使用逻辑地址） 装入 -\u003e 5.内存（物理地址) 代码会被编译汇编成机器能识别的指令，这些指令会告诉CPU去内存的哪个地址存/取数据。 但是，在生成机器指令时，通常并不知道进程数据会被放到什么位置。 所以生成的机器指令中，通常使用的是逻辑地址。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:2:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"为什么需要区分内核空间和用户空间 CPU的所有指令中，有些指令很危险，如果错用会导致系统崩溃。 CPU将指令分为特权指令，和非特权指令。 CPU将特权等级分为4个等级：Ring0 ~ Ring3。 当进程运行在Ring3级别时，被称为运行在用户态。 当进程运行在Ring0级别时，被称为运行在内核态。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:3:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"逻辑地址 VS 物理地址 只要知道进程在内存中的起始地址，和进程数据的相对地址，就能求出进程数据的绝对地址。 相对地址就是逻辑地址，绝对地址就是物理地址。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:4:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"装入方式 绝对装入 静态重定位 动态重定位 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:5:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"1. 绝对装入 事先就知道程序会放到内存中的哪个位置，生成的目标模块中使用的是绝对地址。 装入程序按照装入模块中的地址，将程序和数据放入内存。 只适用于单道程序环境。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:5:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"2. 静态重定位 又称可重定位装入。 生成的装入模块，地址从0开始，使用的是逻辑地址。装入时，再将逻辑地址变换为物理地址。 特点： 装入内存时，必须分配其要求的全部内存空间。 如果没有足够的内存空间，就不能装入该程序作业。 一旦进入内存后，运行期间不能再移动，也不能再申请内存空间。 适用于多道批处理系统。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:5:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"3. 动态重定位 又称动态运行时装入。 链接生成的装入模块，地址从0开始，使用的是逻辑地址。装入内存后，并不会马上把逻辑地址转换为物理地址，而是在程序真正执行时，才进行地址转换。 这种方式依靠重定位寄存器（基址寄存器），用来存放装入模块的起始地址。 特点： 允许程序在内存中发生移动。 程序可分配到不连续的存储区。 程序运行前只需要装入部分代码即可，然后根据需要动态申请分配内存。 便于程序段的共享。 可以向用户提供一个比存储空间大的地址空间。 适用于现代操作系统。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:5:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"链接方式 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:6:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"1. 静态链接 程序运行前，将目标模块及它们所需的库函数，链接成一个可执行文件（装入模块）。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:6:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"2. 装入时动态链接 将目标模块装入内存是，边装入边链接。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:6:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"3. 运行时动态链接 在程序执行过程中，需要某目标模块时，才对它进行链接。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:6:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"内存管理 操作系统主要负责： 内存空间的分配与回收。 从逻辑上对内存进行扩充。 逻辑地址与物理地址的转换（地址重定向）。 提供内存保护功能。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:7:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"内存保护 保证各进程在自己的内存空间内运行，不会越界访问。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:8:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"1. 上下限寄存器 CPU可以设置上、下限寄存器，存放进程的上、下限地址。 进程的指令访问某个地址时，CPU检查是否越界。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:8:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"2. 重定位寄存器/界地址寄存器 可以采用“重定位寄存器”和“界地址寄存器”进行越界检查。 重定位寄存器（又称基址寄存器）存放进程的起始物理地址。 界地址寄存器（又称限长寄存器）存放进程的最大逻辑地址。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:8:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"覆盖 解决程序大小超过物理内存总和的问题。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:9:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"思想： 内存分为“一个固定区和若干个覆盖区”。 常驻内存的段，放在“固定区”，调入后就不再调出。 不常用的段，放在“覆盖区”，用到时调入内存，用不到时调出内存。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:9:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"实现 按照自身逻辑结构，让不可能同时被访问的程序段，共享同一个覆盖区。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:9:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"特点 必须由程序员声明覆盖结构，操作系统自动完成覆盖。 增加了用户编程负担。 只用于早期的操作系统中 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:9:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"交换 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:10:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"思想 内存空间紧张时，系统将内存中某些进程暂时换出外存。 将外存某些已经具备运行条件的进程换入内存 总而言之，就是进程在内存和磁盘间动态调度 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:10:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"中级调度 又称内存调度。 决定将某个处于挂起状态的进程重新调入内存。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:10:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"挂起状态 又称挂起态suspend。 暂时换出外存等待的进程状态，称为挂起状态。 挂起状态分为：就绪挂起、阻塞挂起。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:10:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"被换出进程保存位置 磁盘空间一般分为“文件区”和“对换区”。 文件区： 主要存放文件 主要追求存储空间的利用率 采用离散分配方式进行管理 对换区： 只占磁盘空间的小部分 被换出进程数据存放在对换区 主要追求换入换出速度 采用连续分配方式管理 对换区的I/O速度快于文件区。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:10:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"交换时机 进程运行数较多，且内存吃紧时进行交换，负荷降低后就暂停。 如经常发生缺页，说明内存紧张，可换出一些进程。 如果缺页率明显下降，可暂停换出。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:10:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"换出哪些进程 阻塞进程 优先级低的进程 有时还会考虑进程在内存中的驻留时间，太短则不换出 PCB会常驻内存 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:10:6","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"内部碎片和外部碎片 内部碎片：在分配给某进程的内存区域中，如果有些部分没有用上，这部分就是内部碎片。 外部碎片：指内存中的某些空闲分区，由于太小而难以利用。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:11:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"连续分配和非连续分配 连续分配：为用户进程分配的必须是一个连续的内存空间。 内存连续分配方式有：单一连续分配方式、固定分区分配方式、动态分区分配方式。 非连续分配：为用户进程分配的可以是分散的内存空间。 非连续分配方式有：基本分页存储管理、基本分段存储管理、段页式存储管理。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:12:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"单一连续分配 内存分为系统区和用户区。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:13:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"系统区 位于内存的低地址部分，用于存放操作系统相关数据 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:13:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"用户区 位于高地址部分，用于存放用户进程相关数据 内存中只能有一道用户程序，独占整个用户空间 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:13:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"优点 实现简单 无外部碎片 可以采用覆盖技术扩充内存 不一定需要内存保护 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:13:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 只能用于单用户、单任务操作系统 有内部碎片 存储器利用率极低 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:13:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"固定分区分配 将整个用户空间，分成若干个固定大小的分区，在每个分区中只装入一道作业。 分为两种方式：分区大小相等、分区大小不等。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:14:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"分区说明表 为了实现各个分区的分配与回收，需要建立“分区说明表”。 每个表项的内容为：分区号、分区大小、起始地址、状态（分配/未分配）。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:14:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"优点 实现简单 无外部碎片 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:14:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 程序太大时，无分区满足条件，此时得用覆盖技术来解决 会产生内部碎片，内存利用率低 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:14:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"动态分区分配 又称可变分区分配。 不会预先划分内存分区，而是当进程装入内存时，根据进程大小动态建立分区，并使分区大小正好适合进程需要。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:15:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"记录内存情况 两种常用数据结构记录内存使用情况： 空闲分区表（类似分区说明表） 空闲分区链 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:15:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"动态分区分配算法 从空闲分区表（或空闲分区链）中，选出一个分区分配给新进程，这种算法称为动态分区分配算法。 常见的分区分配算法有： 首次适应算法 最佳适应算法 最坏适应算法 邻近适应算法 首次适应算法： 效果最佳。 思想：从低地址开始查找，找到第一个满足大小的空闲分区。 实现：空闲分区以地址递增的方式排列。每次分配时，顺序查找空闲分区链（或表），直到找到第一个满足条件的分区。 优点：开销小，分区回收后一般不需要重新排序。 最佳适应算法： 思想：优先使用更小的空闲区 实现：空闲分区按照容量递增的方式排列。每次分配时，顺序查找第一个大小满足要求的空闲分区。 优点：会留下很多大分区。 缺点：会产生很多外部碎片。 最坏适应算法： 思想：优先使用最大的连续空闲区 实现：空闲分区按容量递减次序排列。每次分配时，顺序查找第一个大小满足要求的空闲分区。 优点：能减少小碎片数量。 缺点：大进程没有分区可用。 邻近适应算法： 思想：每次查找都从上次查找结束的位置开始。 实现：空闲区按地址递增的顺序排列成一个循环链表。每次分配时，从上次查找结束的位置开始，找到第一个大小满足要求的空闲分区。 优点：检索时不需要从低地址开始，算法开销小。 缺点：高地址的大分区，被使用的可能性很大，从而导致最后无大分区可用。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:15:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"紧凑技术 如果内存中空闲空间碎片的总和满足进程的要求，但是进程需要的是一整块连续的内存空间，这时可以使用紧凑技术，解决外部碎片。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:15:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 会产生很多外部碎片 利用紧凑技术处理外部碎片时，时间代价很高 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:15:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"非连续分配管理方式 常见的非连续分配管理方式为： 基本分页存储管理 基本分段存储管理 段页式存储管理 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:16:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"基本分页存储管理 由“固定分区分配”方式改进。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"思想 基本思想为： 把内存分为大小相等的小分区，再按照分区大小，将用户进程的地址空间，拆分成与页框大小相等的区域。 操作系统以页框为单位，为每个进程分配内存空间。进程的页面和内存的页框有一一对应的关系。 内存中的每个分区，称为页框、页帧、内存块、或者物理块。 每个分区有一个编号，称为页框号、页帧号、内存块号、或者物理块号，页框号从0开始。 用户进程的每个区域，称为页、或者页面。页面的编号称为页号，每个页号从0开始。 注意： 页框不能太大，否则会产生过大的内部碎片。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页表 用于获得进程的每个页面在内存中存放的位置。 一个进程对应一张页表。 进程每一页对应一个页表项。 页表项包含页号和内存块号两个信息，页号是隐含的。 每个页表项的长度都是相同的。 各页表项，会按顺序连续存放在内存中。 根据页表在内存的起始地址，和页表项长度，就可找到各个页号对应页表项的地址 为了方便查询，通常会让一个页表占更多字节，使得每个页面恰好可以装下整数个页表项。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"逻辑地址到物理地址的转换 转换过程： 确定逻辑地址对应的页号。 确定页号对应页面在内存中的起始地址。 计算逻辑地址在页面内的偏移量。 物理地址 = 页面始址 + 页内偏移量 一般计算公式： 页号 = 逻辑地址 / 页面长度 （取整） 页内偏移量 = 逻辑地址 % 页面长度 （取余） 为了计算方便，页面大小一般设置为2的整数幂。 如果每个页面大小为2^kB，用二进制表示逻辑地址，则末尾k位为页内偏移量，其余部分为页号。 如果页面大小为2的整数次幂，则只需把页表中记录的物理块号拼接上页内偏移量，就能得到物理地址。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页表寄存器 页表寄存器PTR，存放页表在内存中的起始地址F和页表长度。 进程未执行时，页表的起始地址和页表长度，放在进程控制块PCB中。 进程被调度时，内核会将上述两个值放入页表寄存器。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址转换的具体过程 根据逻辑地址计算出页号、页内偏移量。 比较页号和页表长度，判断是否产生越界中断，页号大于等于页表长度则越界。 查询页表，找到页号对应页表项，确定页面存放的内存块号。 用内存块号和页内偏移量，得到物理地址。 访问物理内存单元。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺点 每次访问逻辑地址的时候，都需要查询内存中的页表，且每次查到的结果可能都是同一个页表项。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:6","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"具有快表的地址变换 时间局部性： 如果执行了程序中某条指令，该指令可能很快会被再次执行。 如果某个数据被访问过，不久之后该数据可能被再次访问。 空间局部性： 程序访问了某个存储单元，不久之后其附近的存储单元也可能被访问。 快表： 又称联想寄存器，是一种访问速度比内存快很多的高速缓冲存储器。用来存放当前访问的若干页表项。 访问内存中的页表项之前，会先查询块表。如果查询命中，则可以直接访问物理地址。 慢表： 内存中的页表项常称为慢表。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:7","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"单级页表的问题 单级页表存在的问题： 页表必须连续存放，因此当页表很大，需要占用很多个连续的页框。可以采用多级页表解决。 没有必要让整个页表常驻内存，因为进程在一段时间内，可能只访问某几个特定的页面。可以采用虚拟存储技术解决。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:17:8","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"基本分段存储管理 按照程序自身的逻辑关系，将进程地址空间分为若干个段，每个段都有一个段名，每段从0开始编址。编译程序会将段名转换为段号。 以段为单位进行分配，每个段在内存中占据连续空间，但是各段之间可以不相邻。 分段系统的逻辑地址：段号 + 段内地址（段内偏移量） 段号位数，决定了每个进程最多可以分为几个段。 段内地址位数，决定了每个段的最大长度是多少。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:18:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段表 段表：每个进程拥有的一张段映射表，用于在物理内存中查找各个逻辑段的存放位置。 每个段对应一个段表项，记录了基址（段在内存中的起始位置）和段长。 各个段表项的长度是相同的，比如，操作系统可规定为6个字节。 短号是隐含的，不占用存储空间。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:18:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段表寄存器 包含：段表始址 + 段表长度 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:18:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址转换过程 根据逻辑地址，得到段号、段内地址。 判断段号是否越界，如果段号大于等于段表长度，则产生越界中断。 查询段表，找到对应的段表项。 检查段内地址是否超过段长，超过则产生越界中断。 计算得到物理地址，物理地址 = 段基址 + 段内地址。 访问目标内存单元。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:18:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"块表 分段也可以引入块表机制，和分页类似，不再赘述。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:18:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"分段和分页的对比 页是信息的物理单位，对用户是不可见的；段是信息的逻辑单位，分段对用户是可见的，用户编程时需要显示的给出段名。 分页的内存空间利用率高，不会产生外部碎片，只会产生少量内部碎片；分段会产生外部碎片。 分段比分页更容易实现信息的共享和保护。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:18:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段页式管理 思想：先将进程按逻辑块分段，再将各段分页。 逻辑地址结构为：段号、页号、页内地址（页内偏移量） 段号的位数，决定了每个进程最多可以分成几个段 页号位数，决定了每个段最大有多少页 页内偏移量，决定了页面大小、内存块大小 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:19:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"段表和页表 每个段对应一个段表项 每个段表项由段号、页表长度、页表存放块号（页表起始地址）组成。 段表项长度相等，段号是隐含的 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:19:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址转换过程 根据逻辑地址，得到段号、页号、页内偏移量 判断段号是否越界，如果段号大于等于段表长度，则越界中断 查询段表，找到对应的段表项 检查页号是否越界，如果页号大于等于页表长度，则越界中断 根据页表存放块号、页号查询页表，找到页表项 根据内存块号、页内偏移量找到最终的物理地址 访问内存单元 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:19:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"虚拟内存 虚拟存储技术主要用于解决传统内存管理的局限性。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:20:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"传统存储管理 包括连续分配管理和非连续分配管理。 一次性： 作业必须一次性装入内存后，才能开始执行。 一次性缺陷： 作业很大时，无法运行。 无法实现大量作业同时运行，多道程序并发度降低。 驻留性： 作业被装入内存后，会一直驻留在内存中，直到作业运行结束。 驻留性缺陷： 内存中会驻留大量暂时用不到的数据，浪费内存资源。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:20:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"什么是虚拟内存 基于局部性原理，在程序装入时，可以将程序中很快会用到的部分装入内存，暂时用不到的部分留在外存。 在程序执行时，如果所需信息不在内存中，操作系统负责将其从外存调入内存。 若内存空间不足，操作系统负责将内存中暂时用不到的信息换出外存。 在用户看来，会存在一个比实际内存大的内存，这就是虚拟内存。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:20:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"虚拟内存的容量 最大容量： 由计算机的地址结构（CPU寻址范围）确定的。 实际容量： 实际容量 = min(内存和外存容量之和，CPU寻址范围) ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:20:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"虚拟内存的主要特征 多次性：作业运行时，无需一次性装入内存，允许被分成多次调入内存 对换性：在作业运行过程中，允许将作业换入、换出 虚拟性：从逻辑上扩充了内存的容量 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:20:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"实现 虚拟内存的实现，建立在离散分配的内存管理方式基础上： 基本分页存储管理 基本分段存储管理 基本段页式存储管理 虚拟内存的实现： 请求分页存储管理 请求分段存储管理 请求段页式存储管理 操作系统要提供请求调页（或请求调段）功能。 操作系统要提供页面置换（或段置换）功能。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:20:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"请求分页存储管理 操作系统需要： 提供请求调页功能，将缺失页面从外存调入内存 提供页面置换功能，内存不够时，将暂时用不到的页面换出外存 管理方式： 页表机制 缺页中断机构 地址变换机构 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:0","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页表 页表项的组成为： 内存块号。如果信息位于外存，该字段为空。 状态位。表示是否已经调入内存。 访问字段。记录最近被访问过几次，或者记录上次访问的事件。 修改位。页面调入内存后，是否被修改过。 外存地址。页面在外存中的存放位置。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:1","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"缺页中断机构 如果要访问的页面不在内存中，便产生一个缺页中断，然后由操作系统的缺页中断处理程序处理中断。 缺页中断属于内中断。 此时，缺页的进程阻塞，放入阻塞队列，调页完成后再将其唤醒，放入就绪队列。 如果内存中有空闲块，则为进程分配一个空闲块，将所缺失页面装入该块，并修改页表的页表项。 如果内存中没有空闲块，则由页面置换算法，选择一个页面淘汰。如果被淘汰页面被修改过，则还需要写回外存。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:2","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"地址变换机构 根据页表项，检查页面是否在内存中。 若页面不在内存中，请求调页。 若内存空间不够，需要换出页面。 页面调入内存后，修改对应页表项和快表。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:3","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"快表 快表中有的页面一定存在内存中。如果某个页面被换出外存，则快表中的表项也要删除。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:4","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页面置换算法 最佳置换算法 淘汰将来不再使用、或者最长时间不再访问的页面。 该算法无法实现。 先进先出置换算法 淘汰最早进入内存的页面。 会产生Belady异常，当为进程分配的内存块增多时，缺页次数也会增多。 最近最久未使用置换算法LRU 淘汰最近最久未使用的页面。 页表项记录的是上次被访问以来经历的时间，时间最大的页面被淘汰。 时钟置换算法 循环扫描各个页面，并检查访问位，1表示被访问过。 如果访问位为1，则置为0，如果访问位为0，则淘汰。 若第一轮无页面淘汰，则进行第二轮扫面。 改进型时钟置换算法 循环扫描各个页面，并检查访问位和修改位，1表示访问过，1表示修改过。 第一轮扫描，淘汰第一个(0,0)。 第二轮扫描，淘汰第一个(0,1)，并将扫描过的访问位设为0。 第三轮扫描，淘汰第一个(0,0)。 第四轮扫描，淘汰第一个(0,1)。 只要有一个页面被淘汰，就不再继续后续扫描，所以最多扫描4轮。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:5","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"页面分配 驻留集 请求分页存储管理中，为进程分配的内存块集合。 固定分配 每个进程的驻留集大小不变。 可变分配 每个进程的驻留集大小可变。 局部置换 只能使用进程自己的内存块进行置换。 全局置换 可以使用操作系统的空闲内存块，以及其它进程的物理块，进行置换。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:6","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"对换区 对换区采用的是连续存储方式，读写速度更快。 如果对换区足够大，进程数据将直接从文件区复制到对换区，之后的页面调入调出，都是在内存和对换区之间进行。 如果对换区不够大，进程不会修改的数据会从文件区调入，调出时不会写回文件区；会修改的数据，第一次从文件区调入，之后会调出到对换区，下次再从对换区调入。 对于UNIX，第一次使用的页面从文件区调入，调出的页面写回对换区，下次从对换区调入。 ","date":"2020-12-15","objectID":"/os-nei-cun-guan-li/:21:7","tags":["操作系统"],"title":"【操作系统】内存管理","uri":"/os-nei-cun-guan-li/"},{"categories":["操作系统"],"content":"进程基本概念 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:1:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 进程的定义 进程的定义方式有多种，常见的几种定义如下： 进程是程序的一次执行过程。 进程是一个程序及其数据在处理机上顺序执行时所发生的活动。 进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:1:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 进程的组成 进程由三部分组成： 进程控制块PCB。 程序段。 数据段。 系统根据PCB感知进程的存在，PCB是进程存在的唯一标志。PCB的组成部分通常为： 进程标识符PID。每个进程都有唯一的标识符。 进程当前状态。作为进程调度程序分配CPU的依据。 进程队列指针。指向PCB队列中，下一个PCB的地址。 程序和数据地址。进程程序段和数据段的地址。 进程优先级。 CPU现场保护区。保存CPU的现场信息，如指令寄存器、状态寄存器、通用寄存器等。 通信信息。进程执行过程中，与别的进程发生的信息交换情况。 家族联系。进程可以创建子进程，从而形成一个进程家族树。 占有资源清单。记录了所需资源和已分配资源。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:1:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程的特点 动态性： 进程是程序在处理器上的一次执行过程，因而是动态的。 并发性： 多个进程可以同时存在于内存，在一段时间内同时运行。 独立性： 进程是一个能独立运行的基本单位。也是资源分配和调度的独立单位。 异步性： 进程以独立的、不可预知的速度向前推进。 结构性： 每个进程都是由程序段、数据段和一个进程控制块组成。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:1:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 进程和程序的区别 进程是动态的，程序是静态的。程序是有序代码的集合，进程是程序的执行。 进程是暂时的，程序是永久的。进程是一个状态变化的过程，程序可长久保存。 进程和程序的组成不同。进程包括程序、数据和进程控制块（即进程状态信息）。 通过多次执行，一个程序可以产生多个进程；通过调用关系，一个进程可以执行多个程序。 进程可以创建其他进程，程序不能形成新的程序。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:1:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 什么是进程实体 程序段、数据段和进程控制块PCB，三部分组成了进程实体，也叫进程映像。 进程实体是静态的。进程是动态的，进程是进程实体的运行过程。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:1:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 常见寄存器 程序状态寄存器PSW。 程序计数器PC。存放下一条指令的地址。 指令寄存器IR。存放当前正在执行的指令。 通用寄存器。可存放计算的中间结果。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:1:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"进程状态 进程具备5种基本状态： 运行态 就绪态 阻塞态 创建态 终止态 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:2:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 运行态 占有CPU，并在CPU上运行。 单核环境中，同时只有一个进程处于运行态。 双核环境中，同时可以有两个进程处于运行态。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:2:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 就绪态 已经具备运行条件，但由于没有CPU，暂时不能运行。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:2:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 阻塞态 用系统调用请求系统资源时，或者等待某一事件发生时，暂时不能运行。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:2:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 创建态 又称新建态。 进程正在被创建。 操作系统会为进程分配资源、初始化PCB。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:2:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 终止态 又称结束态。 进程正在从系统中撤销。 操作系统会回收进程拥有的资源，并且撤销PCB。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:2:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 进程状态转换 进程初始处于创建态。 就绪态 -\u003e 运行态：进程被调度。 运行态 -\u003e 就绪态：时间片到，或CPU被其它高优先级进程抢占。 运行态 -\u003e 阻塞态：通过“系统调用”等待系统资源分配、或等待某事件发生（主动）。 阻塞态 -\u003e 就绪态：资源分配到位，等待的事件发生（被动）。 创建态 -\u003e 就绪态：系统完成创建。 运行态 -\u003e 终止态：运行结束，或发生不可修复错误。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:2:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"进程控制 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 什么是进程控制 进程控制，是指对系统中的所有进程实施有效的管理。包含进程创建、进程撤销、以及进程状态转换等功能。 进程控制依靠原语来实现。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 原语 原语是一种特殊的程序。它的执行具有原子性，即执行期间不允许被中断。 原子性的实现，需要依靠“关中断指令”和“开中断指令”。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程创建原语 申请空白PCB 为进程分配所需资源 初始化PCB 将PCB插入就绪队列 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 进程撤销原语 找到终止进程的PCB。 若进程正在运行，则立即剥夺CPU，将CPU分配给其他进程。 终止其所有子进程。 将该进程资源归还给父进程或操作系统。 删除PCB。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 进程阻塞原语 找到进程对应PCB。 保护进程运行现场，将PCB状态信息设置为阻塞态，暂时停止进程运行。 将PCB插入相应事件的等待列表。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 进程唤醒原语 从事件等待队列中找到PCB。 将PCB从等待队列移除，设置进程为就绪态。 将PCB插入就绪队列，等待被调度。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"7. 进程切换原语 进程切换是指，从运行态到就绪态，或者从就绪态到运行态。 将运行环境存入PCB。 PCB移入相应队列。 选择另一个进程执行，并更新其PCB。 根据PCB恢复进程所需的运行环境。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:3:7","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"进程通信 各进程拥有的内存地址空间相互独立。 为了安全，一个进程不能直接访问另一个进程的地址空间，从而诞生了各种进程通信的方法。 常见的进程通信方法有： 管道 命名管道 共享内存 消息队列 套接字 信号 信号量 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:4:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 管道 包括管道和命名管道。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:4:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 共享内存 Unix操作系统（包括linux）中有Posix内存共享库：shmem。 实现原理是以虚拟文件系统的形式，从内存中划分出一块区域，供两个进程共同使用。 速度快，但是程序实现复杂。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:4:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 消息队列 有本地消息队列，如mqueue。或者基于网络请求实现的消息队列，如kafka，rabbitmq等。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:4:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 网络请求 是套接字方法的一种实现，基于TCP/IP协议或者建立在这之上的通信协议。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:4:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 远程调用 是套接字方法的一种实现，RPC的过程为： 客户端调用函数或者方法。 客户端stub将函数调用封装为请求。 客户端socket发送请求，服务端socket接受请求。 执行服务端方法。 返回结果给服务端stub。 服务端stub将结果封装为返回数据。 服务端socket发送返回数据，客户端socket接受返回数据。 客户端socket将数据传递给客户端stub。 客户端stub把返回数据转义成函数返回值。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:4:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"线程 线程是一个基本的CPU执行单位，也是程序执行流的最小单位。 进程是除CPU之外的系统资源的分配单位。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:5:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 线程特点 线程具有如下特点： 在多核CPU中，线程可以占据不同的CPU。 每个线程都有一个线程ID和一个线程控制块TCB。 线程也有就绪、阻塞和运行状态。 线程几乎不拥有系统资源。 同一进程的不同线程共享进程资源。 同一进程的线程切换，不会引起进程切换。 不同进程的线程切换，会引起进程切换。 同一进程内的线程切换，系统开销很小。 进程切换的系统开销较大。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:5:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 用户级线程 用户级线程介绍： 由应用程序通过线程库实现。 所有的线程管理工作都由应用程序负责（包括线程切换）。 用户线程之间的切换在用户态下完成，无需操作系统的干预。 用户线程对用户不透明，对操作系统透明。 用户线程就是用户视角能看到的线程。 优点： 线程管理的系统开销小，效率高。 缺点： 当一个用户级线程被阻塞后，整个进程都会被阻塞，并且多个用户级线程不可在多核处理机上并行运行，并发度不高。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:5:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 内核级线程 内核级线程介绍： 管理工作由操作系统内核完成，如线程调度、切换等。 内核级线程的切换，必须在内核态下才能完成。 内核级线程就是从操作系统内核视角能看到的线程。 内核级线程才是处理器分配的单位。 优点： 当一个线程被阻塞后，别的线程还可以继续执行，并且多线程可以在多核处理机上并行执行。 缺点： 线程切换由操作系统完成，因此线程管理成本高，开销大。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:5:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"多线程模型 在用户级线程和内核级线程并存的系统中，几个用户线程映射到几个内核级线程的问题，称为“多线程模型”问题。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:6:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 多对一模型 多个用户级线程映射到一个内核级线程。 优点： 用户级线程的切换在用户空间即可完成，不需要切换到和心态，线程管理开销小，效率高。 缺陷： 当一个用户线程被阻塞，整个进程都会被阻塞，并发度不高。 多个线程不可在多核处理机上并行运行。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:6:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 一对一模型 一个用户级线程映射到一个内核级线程。 优点： 当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。 多线程可在多核处理机上并行执行。 缺点： 一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需切换到和心态，线程管理成本高，开销大。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:6:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 多对多模型 n个用户级线程映射到m个内核级线程(n \u003e= m)。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:6:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"调度 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:7:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 三层调度 高级调度 也称作业调度。按照某种规则，从后备队列中，选择合适的作业，将其调入内存，并为其创建进程。 进程状态变化：无-\u003e创建态-\u003e就绪态。 中级调度 也称内存调度。按照某种规则，从挂起队列中，选择合适进程，将其数据调回内存。 为了提高资源利用率，暂时不执行的进程会被调到外存，从而成为“挂起态”。有“就绪挂起”和“阻塞挂起”。 进程状态变化：阻塞挂起-\u003e阻塞态，或者，就绪挂起-\u003e就绪态。 低级调度 也称进程调度。按照某种规则，从就绪队列中，选择合适进程，为其分配处理机。 进程状态变化：就绪态-\u003e运行态。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:7:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 进程调度的时机 主动放弃处理机： 进程正常终止。 进程发生异常而终止。 进程主动请求阻塞。 被动放弃处理机： 分给进程的时间片用完。 有更紧急的事情，如IO中断。 有更高优先级的进程进入就绪队列。 不能调度的时机： 处理中断时。 进程在操作系统内核程序临界区中。 在原子操作过程中。 临界资源： 一个时间段内，只允许一个进程使用的资源。各进程需要互斥的访问临界资源。 临界区： 用来访问临界资源的那段代码。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:7:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程调度的方式 抢占式调度 只允许进程主动放弃CPU。 实现简单，但是无法及时处理紧急任务。 非抢占式调度 可以优先处理更紧急的进程。 也可以让各进程按时间片轮转。 适合于分时操作系统、实时操作系统。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:7:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 进程切换过程 狭义的进程调度，指的是从就绪队列中选中一个要运行的进程。 进程切换，指一个进程让出处理器，由另一个进程占用处理器的过程。 广义的进程调度，包含选择一个进程和进程切换两个步骤。 进程切换过程如下： 保存原来运行进程的数据 恢复新进程的各种数据 缺陷： 进程切换有代价。 调度、切换过于频繁，会使得整个系统效率降低。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:7:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"调度算法 先来先服务 短作业优先 最短剩余时间算法 高响应比优先 时间片轮转调度算法 优先级调度算法 多级反馈队列调度算法 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 先来先服务算法 思想：按照到达的先后顺序进行服务 是否可抢占：非抢占式 优点：公平，实现简单 缺点：排在长作业/进程后面的短作业/进程要等待很久 是否会导致饥饿：不会 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 短作业优先算法 用于进程时，称为短进程优先。 思想：用时最短的最先得到服务 是否可抢占：是非抢占式算法，但是也有抢占式版本（最短剩余时间优先算法） 优点：更短的平均等待时间和平均周转时间 缺点：对短作业有利，对长作业不利，可能产生饥饿现象；运行时间是用户提供，并不一定能做到真正的短作业优先 是否会导致饥饿：会，长作业可能会长时间得不到服务。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 最短剩余时间优先算法 就绪队列改变时、或者一个进程完成时，进行调度。 如果有新进程剩余时间比当前运行进程剩余时间短，则由新进程抢占处理机，当前进程回到就绪队列。 最短剩余时间优先算法，有最少的平均等待时间，和平均周转时间。 有的书中会说，短作业优先有着最少的平均等待时间，和平均周转时间，其实是不严谨的。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 高响应比优先 响应比计算公式： 响应比 = （等待时间 + 要求服务时间）/（要求服务时间） 思想：每次调度时，计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务。 是否可抢占：非抢占式 优点：综合考虑了等待时间和运行时间；对于长作业来说，等待时间越长响应比也会越大，从而避免了饥饿问题 是否会导致饥饿：不会 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"5. 时间片轮转算法 思想：按照进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。如果一个时间片内未执行完，则剥夺处理机，重新放入就绪队列末尾。 是否可抢占：抢占式，由时钟中断来通知 优点：公平，响应快，适合分时操作系统 缺点：进程切换会有一定开销，不区分任务紧急程度 是否会导致饥饿：不会 注意：时间片不能太大，也不能太小 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"6. 优先级调度算法 思想：调度时选择优先级最高的作业/进程。 是否可抢占：抢占式和非抢占式都有。非抢占式在进程主动放弃处理器时进行调度；抢占式还在就绪队列发生变化时，发生调度。 优点：用优先级区分紧急程度，可灵活调整对各进程的偏好程度；适用于实时操作系统 缺点：低优先级进程可能一直得不到执行 是否会导致饥饿：会 通常，系统进程优先级高于用户进程，前台进程优先级高于后台进程，操作系统更偏好IO繁忙型进程。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"7. 多级反馈队列调度算法 思想： 设置多级就绪队列，优先级从高到低，时间片从小到大； 新进程先进入第一级队列，按照先到先服务原则被分配时间片； 如果时间片用完还未结束，则进入下一级队列，如果位于最后一级，则重新进入该队列尾部； 第K级队列为空时，才会为K+1级队列分配时间片。 被抢占处理机的进程，重新放回该队列队尾。 是否可抢占：抢占式算法。当K级队列进程运行时，如果前几级队列加入了新进程，新进程会抢占处理机，原来的进程放回原队列的末尾。 是否会导致饥饿：会 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:8:7","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"同步和互斥 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:9:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"1. 什么是同步 异步性，并发执行的进程，以各自独立的、不可预知的速度向前推进。 同步，也称直接制约关系，是协调各进程工作次序而产生的制约关系。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:9:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"2. 什么是互斥 互斥，也称间接制约关系，指一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。 临界资源，是一个时间段内只允许一个进程访问的资源，对临界资源的访问必须互斥的进行。 对临界资源的互斥访问，可在逻辑上分为如下四个部分： 进入区：检查是否可以进入临界区，如果可以进入，则设置正在访问临界资源的标志（上锁），以阻止其他进程同时进入临界区。 临界区：用来访问临界资源的代码。 退出区：解除正在访问临界资源的标志（解锁）。 剩余区：做其他处理。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:9:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"3. 进程互斥原则 空闲让进：临界区空闲时，允许进程进入临界区。 忙则等待：已有进程进入临界区时，其他试图进入临界区的进程必须等待。 有限等待：对请求访问的进程，保证能在有限时间内进入临界区。 让权等待：当进程不能进入临界区，应立即释放处理机。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:9:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"4. 信号量 信号量机制是实现进程互斥、同步的有效方法。 信号量是一个变量（可以是整数，也可以是记录型变量），用来表示系统中某资源的数量。用户进程可以使用操作系统提供的一对原语，来对信号量进行操作。 这对原语为wait原语和signal原语，wait原语和signal原语常简称为P、V操作。 wait原语用于占用资源，signal用于释放资源，资源不够时，wait原语会进行等待。 资源不够时，整型信号量存在“忙等”问题，不满足“让权等待”。 资源不够时，记录型信号量会让进程变为阻塞态，资源足够时，会被唤醒变为就绪态。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:9:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:10:0","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁、饥饿、死循环 死锁： 并发环境下，各进程互相等待对方手里的资源，导致进程都阻塞，无法向前推进的现象。 如果有死锁现象，至少是两个或以上进程发生死锁。 死锁一定处于阻塞态。 饥饿： 进程长期得不到想要的资源，从而无法向前推进的现象。 可能只有一个进程发生饥饿。 既可以是阻塞态，也可以是就绪态。 死循环 某进程执行过程中一直跳不出某个循环的现象。 可以处于运行态。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:10:1","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁产生条件 必须同时满足下列四个条件： 互斥条件：只有对互斥资源发生争抢才会导致死锁。 不可剥夺：资源不能被夺走，只能主动释放。 请求和保持：进程持有至少一个资源，但是又提出新的资源请求，该资源又被其他进程持有，于是请求进程被阻塞，持有资源又不会释放。 循环等待：存在进程资源的循环等待链，每一个进程获得的资源同时被下一个进程请求。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:10:2","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁处理 预防死锁：破坏死锁产生条件。 避免死锁：防止系统进入不安全状态（银行家算法）。 死锁检测和解除：操作系统检测死锁的发生，然后解除死锁。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:10:3","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"预防死锁 将互斥资源改为允许共享使用。通常难以实现。 释放持有的资源，以后再重新申请；或者强行剥夺其他进程资源。实现复杂。 运行前一次性申请完所需的资源，运行后这些资源就归它所有。资源利用率低。 给资源编号，进程必须按照编号递增的顺序请求资源。资源利用率低且编程麻烦。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:10:4","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"避免死锁 安全序列：系统如果按照这种序列分配资源，则每个进程都能顺利完成。 安全状态：只要能找到一个安全序列，系统就是安全状态。 银行家算法：进程提出资源申请时，先预判这次分配是否会导致系统进入不安全状态。如果会进入不安全状态，就暂时不答应这次请求，让进程阻塞等待。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:10:5","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"死锁检测和解除 死锁检测： 用某种数据结构保存资源的请求和分配信息 用某种算法，根据资源信息判断是否进入了死锁状态 解除死锁： 资源剥夺法：将进程挂起到外存，并抢占它的资源。 撤销进程法：撤销死锁进程，并抢占它的资源。 进程回退法：将死锁进程回退到足以避免死锁的地步。 ","date":"2020-12-04","objectID":"/os-jin-cheng-he-xian-cheng/:10:6","tags":["操作系统"],"title":"【操作系统】进程和线程","uri":"/os-jin-cheng-he-xian-cheng/"},{"categories":["操作系统"],"content":"计算机系统的层次结构 计算机系统的层次结构为： 裸机，纯硬件 操作系统 应用程序 用户 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:1:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"计算机硬件 计算机硬件遵循冯.诺依曼模型，由5部分组成： 运算器。 存储器。 控制器。 输入设备。 输出设备。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:2:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统的概念 操作系统，是裸机上的第一层系统，是对硬件功能的首次扩充。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:3:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统的作用 操作系统的基本作用为： 提供了用户与硬件系统之间的接口。 有效控制和管理计算机系统中硬件和软件资源。 合理组织计算机系统的工作流程。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:4:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统特征 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:5:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"1. 并发性 并发和并行，是两个概念。 并发性，指两个或多个事件，在同一时间间隔内发生。宏观上是同时发生，微观上是交替发生。 并行性，指两个或多个事件，在同一时刻同时发生。 单核CPU，同一时刻只能执行一个程序，多个程序只能并发执行。 多核CPU，同一时刻可以执行多个程序，多个程序可以并行执行。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:5:1","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"2. 共享 共享，是指系统中的资源，可供内存中多个并发执行的进程共同使用。 资源共享方式： 互斥共享方式 一个时间段内，只允许一个进程访问共享资源。 同时共享方式 一个时间段内，允许多个进程同时访问共享资源。同时是宏观上的，微观上可能是交替访问。 并发性和共享性，互为存在条件。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:5:2","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"3. 虚拟 虚拟，是指一个物理实体变为若干个逻辑上的对应物。物理实体是实际存在的，逻辑对应物是用户感受到的。 虚拟性以并发性为前提，如果没有并发性，自然不再需要虚拟性。 虚拟技术： 空分复用技术。如虚拟存储器技术。 时分复用技术。如虚拟处理器。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:5:3","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"4. 异步 多个程序并发执行时，会以不可预知的速度向前推进，进程何时执行，进程间执行的顺序，进程执行所用的时间，都是不确定的，这就是异步性。 并发性是异步性的前提。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:5:4","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统基本功能 操作系统的基本功能包括： 处理器管理 存储器管理 设备管理 文件管理 用户接口 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:6:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["操作系统"],"content":"操作系统发展 操作系统经历了以下发展阶段： 手工操作阶段。 单道批处理系统。缓解了人机速度矛盾，资源利用率较低。 多道批处理系统。多道程序并发执行，资源利用率高。不提供人机交互。 分时操作系统。提供了人机交互功能，不能区分紧急任务。 实时操作系统。能优先处理紧急的任务。 ","date":"2020-11-16","objectID":"/os-ji-ben-gai-nian/:7:0","tags":["操作系统"],"title":"【操作系统】基本概念","uri":"/os-ji-ben-gai-nian/"},{"categories":["Linux"],"content":"Linux系统中有多个压缩和归档工具，现在介绍常见的几种。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:0:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"gzip gzip用于压缩一个或多个文件，具体用法为： gzip [options] [file...] ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:1:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"options 常见的选项有： -c：将内容输出到标准输出，不会生成新文件，压缩文件也不会被删除。 -d：解压缩。 -f：即使压缩文件已经存在，也强制压缩。 -h：显示帮助信息。 -l：显示压缩文件列表。 -r：递归压缩或者解压缩包含在目录中的文件。 -t：校验压缩文件完整性。 -v：压缩时显示详细信息。 -k：不删除源文件。 -1：--fast，速度最快的压缩等级。 -2 .. -8：压缩等级，压缩速度从快到慢，压缩比从小到大。 -9：--best，压缩比最高的压缩等级。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:1:1","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"解压缩 gzip生成的压缩文件后缀为.gz。可以使用gzip -d、-gunzip和zcat解压缩。 解压缩时，会自动查找.gz后缀的文件，所以在不引起歧义的情况下，可以省略文件后缀。 zcat命令会将结果输出到标准输出，不会生成新的文件，也不会被删除被解压文件。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:1:2","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"bzip2 bzip2同样可以压缩文件。 除了-r选项，gzip支持的功能bzip2也同样支持。 bzip2生成的压缩文件以.bz2为后缀。 可以使用bzip2 -d、bunzip2和bzcat解压缩，bzcat的作用和zcat也是一样的。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:2:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"gzip 和 bzip2 的使用 已经被压缩过的文件，不应该再次被压缩，即使使用的是不同压缩算法。 因为被压缩文件已经不存在冗余信息，如果进行多次压缩，反而会消耗多余的空间来保存压缩信息。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:3:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"zip zip即可以进行压缩，又可以进行归档。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"命令格式 zip的命令格式为： zip [options] [zipfile [file...]] ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:1","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"options zip的选项参数有很多，现在仅介绍几个常见的： -d：删除归档文件内的指定文件。 -db：显示已经处理的字节，和剩余的字节。 -dc：显示已压缩的条目数，和剩余的条目数。 -e：压缩时使用密码。 -g：向已存在的归档文件追加内容。 -q：不打印任何信息。 -r：递归压缩，如果不指定，则只会压缩一个空目录。 -v：压缩时打印信息，或者显示版本号。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:2","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"解压缩 使用unzip即可对zip归档文件进行解压。 如果使用unzip -l，则只会显示zip归档文件内的包含的文件。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:4:3","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"tar tar是使用最为普遍的归档工具。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:0","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"命令格式 tar的命令格式为： tar function [options] object... ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:1","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"function function参数定义了tar命令应该做什么。常见的命令参数如下： -A：将一个tar归档文件，追加到另一个tar归档文件中。 -c：创建归档文件。 -r：追加文件到归档文件莫问。 -t：列出归档文件的内容。 -x：从已有的归档文件中提取文件。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:2","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"options 常见的options有： -f file：输出到file，或者从file输入。 -j：将输出重定向给bzip2，从而进行压缩。 -p：保留所有文件权限。 -v：处理文件时，显示信息。 -z：将输出重定向到gzip，从而进行压缩。 注意：通常情况下，function参数需要放在options之前。 ","date":"2020-11-11","objectID":"/linux-ya-suo-he-gui-dang/:5:3","tags":["Linux"],"title":"【Linux】压缩和归档","uri":"/linux-ya-suo-he-gui-dang/"},{"categories":["Linux"],"content":"sed编辑器 sed可以用指定命令来编辑数据流，其内部的处理流程大致为： 读取一行数据。 对数据进行匹配。 按照命令修改匹配到的数据。 将新的数据输出到STDOUT。 读取下一行数据，并重复上述过程。 数据流读取完毕后，程序终止。 sed命令格式如下： sed [options] script file 其中，常见的options有： -e script: 将script中的命令，添加到已有的命令列表。 -f file: 将file中指定的命令，添加到已有的命令列表。 -n：不输出每一行的处理结果。 注意，Linux sed和Mac sed，在语法上存在些许差异，需要根据具体使用来调整。本文的测试环境为linux bash4.2。 ","date":"2020-10-05","objectID":"/linux_sed/:1:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"options的使用示例 假设有一个data.txt文件，后续示例都是对该文件进行操作。 文件内容为： This is line 1. This is line 2. ","date":"2020-10-05","objectID":"/linux_sed/:2:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 常规替换命令 $ sed 's/line/number/' data.txt this is number 1. this is number 2. s/line/number/是指将line替换成number。 ","date":"2020-10-05","objectID":"/linux_sed/:2:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 选项-e $ sed -e 's/line/number/' -e 's/this/This/' data.txt This is number 1. This is number 2. ","date":"2020-10-05","objectID":"/linux_sed/:2:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 选项-f $ cat script.sed s/line/number/ s/this/This/ $ sed -f script.sed data.txt This is number 1. This is number 2. ","date":"2020-10-05","objectID":"/linux_sed/:2:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 选项-n 默认情况下，不论数据行是否满足匹配要求，都会将结果输出。使用-n后，将不会产生任何输出。 $ sed -n 's/This/That/' data.txt # 不会有任何输出 ","date":"2020-10-05","objectID":"/linux_sed/:2:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"script的基本语法 ","date":"2020-10-05","objectID":"/linux_sed/:3:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 替换s 可以使用s命令来替换文本： s/pattern/replacement/[flags] 替换命令的分隔符/可以换成其他自定义字符： $ cat data.txt this is line 1. this is line 2. $ sed 's,line,number,' data.txt this is number 1. this is number 2. 替换标记flags是可选的，具体有以下几种： 数字：表明替换第几处匹配的地方，从1开始。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/was/2' data.txt this was line 1. this was line 2. g：替换所有匹配的文本。 $ cat data.txt this is line 1. this is line 2. $ sed 's/is/*/g' data.txt th* * line 1. th* * line 2. p：默认情况下，会输出一次行结果，不管是否匹配。加p后会再次输出被匹配的行（本质上是输出模式空间的内容）。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/p' data.txt this is *. this is *. this is line 2. $ sed -n 's/line 1/*/p' data.txt this is *. w file：将替换的结果输出到file。 $ cat data.txt this is line 1. this is line 2. $ sed 's/line 1/*/w result.txt' data.txt this is *. this is line 2. $ cat result.txt this is *. ","date":"2020-10-05","objectID":"/linux_sed/:3:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 行寻址 sed默认作用于所有行，如果想指定行号，命令格式为： [address]command 寻址方式有两种，数字方式和文本模式。示例如下： 指定单个行号： $ sed '2s/line/number/' data.txt this is line 1. this is number 2. 指定地址区间： $ sed '1,2s/line/number/' data.txt this is number 1. this is number 2. $表示最后一行： $ sed '1,$s/line/number/' data.txt this is number 1. this is number 2. 匹配文本line 2： $ sed '/line 2/s/line/*/' data.txt this is line 1. this is * 2. 文本模式是对模式空间内的文本进行匹配。 并且，文本模式可以使用正则表达式，正则表达式的具体语法此处不做说明。 ","date":"2020-10-05","objectID":"/linux_sed/:3:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 命令组合 如果想执行多条命令，可以使用分号分隔。 $ sed '1s/line/number/; 1s/is/*/' data.txt th* is number 1. this is line 2. 可以将命令写成多行。 $ sed ' \u003e 1,$s/line/number/ \u003e 1,$s/is/*/ \u003e ' data.txt th* is number 1. th* is number 2. 也可以使用花括号{}将多条命令组合在一起。 $ sed '1,${s/line/number/ ; s/is/*/}' data.txt th* is number 1. th* is number 2. ","date":"2020-10-05","objectID":"/linux_sed/:3:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 删除d 可以使用删除命令d删除指定行，删除时也可以使用行寻址。 $ sed '1d' data.txt this is line 2. 使用区间寻址时，第一个匹配处打开删除功能，第二个匹配处关闭删除功能。 ","date":"2020-10-05","objectID":"/linux_sed/:3:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 插入i 插入命令i会在指定行前增加一个新行。 $ sed '[address]i new line' data.txt 如果想添加多行，可以使用\\作为新行结尾。 如果省略address，则是在每行前增加新行。 ","date":"2020-10-05","objectID":"/linux_sed/:3:5","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 追加a 追加命令a会在指定行后增加一个新行。 $ sed '[address]a new line' data.txt 如果想添加多行，可以使用\\作为新行结尾。 如果省略address，则是在每行后增加新行。 ","date":"2020-10-05","objectID":"/linux_sed/:3:6","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 修改c 修改命令c可以修改整行的数据内容。 $ sed '2c this is new line 2' data.txt this is line 1. this is new line 2 如果使用区间寻址，c会对整个区间做替换。 如果省略寻址，则对每行数据做修改。 ","date":"2020-10-05","objectID":"/linux_sed/:3:7","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 转换y 转换命令y可以对单个字符做一对一映射转换。 [address]y/chars1/chars2/ chars1和chars2的长度必须一致，chars1中的字符，会被转换为char2中对应的字符。 $ sed 'y/hijk/HIJK/' data.txt tHIs Is lIne 1. tHIs Is lIne 2. y是一个全局命令，即替换所有匹配的字符结果。 ","date":"2020-10-05","objectID":"/linux_sed/:3:8","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 打印命令p 这是小写p。 打印命令p和替换标记p类似，可以打印匹配到的数据行，即打印当前模式空间的所有数据。 $ sed -n '1p' data.txt this is line 1. ","date":"2020-10-05","objectID":"/linux_sed/:3:9","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"10. 打印行号= 命令=可以打印被匹配数据在文本中的行号。 $ sed '/2/=' data.txt this is line 1. 2 this is line 2. ","date":"2020-10-05","objectID":"/linux_sed/:3:10","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"11. 列出l 列出命令l可以打印匹配数据，包括文本字符和不可打印的转义字符。 $ sed -n '1l' data.txt this is line 1.$ # $是被打印的换行符 ","date":"2020-10-05","objectID":"/linux_sed/:3:11","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"12. 写入命令w w命令可以将匹配数据写入文件。 [address]w filename ","date":"2020-10-05","objectID":"/linux_sed/:3:12","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"13. 读取数据r 读取命令r从文件中读取数据，并将文件的所有数据插入到匹配行后面。 [address]r filename ","date":"2020-10-05","objectID":"/linux_sed/:3:13","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed script进阶语法 假设数据文件data.txt为，如果无特别说明，示例都是对这个文件进行操作。 文件内容为： this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 模式空间和保持空间 sed在执行命令时，会保存待检查的文本。 保存文本时，需要用到两个缓冲区：模式空间和保持空间。 读到的数据保存在模式空间，而保持空间主要起辅助作用。 与缓冲区有关的命令如下： h: 将模式空间复制到保持空间。 H: 将模式空间追加到保持空间。 g: 将保持空间复制到模式空间。 G: 将保持空间追加到模式空间。 x: 交换模式空间和保持空间的内容。 ","date":"2020-10-05","objectID":"/linux_sed/:4:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 单行数据的next命令 单行next命令会将匹配数据的下一行移到sed的模式空间，移动前会清空模式空间。 单行命令是n。 注意，如果不存在下一行数据，则模式空间为空。 $ sed -n '/line 4/{n; p}' data.txt this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 多行数据的next命令 多行next命令，会以追加的方式，将匹配行的下一行添加到模式空间。并且，sed会将模式空间中的数据当成一行处理。 多行命令是N。 注意，如果不存在下一行数据，则模式空间会为空。 $ sed -n '/line 3/{N; p}' data.txt this is line 3. this is line 4. 当要匹配的数据在多行中时，这种语法就能很好的发挥作用。 ","date":"2020-10-05","objectID":"/linux_sed/:4:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 多行删除命令D 多行删除命令D，会删除模式空间中的第一行。 注意，d会删除模式空间中的所有数据。 ","date":"2020-10-05","objectID":"/linux_sed/:4:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 多行打印命令P 多行打印命令（大写P）会打印模式空间中的第一行。 注意，小写的p会打印模式空间中的所有数据。 ","date":"2020-10-05","objectID":"/linux_sed/:4:5","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 排除命令 排除命令!用于将后续命令作用于非匹配行。 $ sed -n '1,2!p' data.txt this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:6","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 分支命令 分支命令b可以用来改变命令的执行流程。 [address]b [label] address用于寻址，label制定了跳转位置，如果省略label，则跳转到命令脚本的结尾。 $ sed '3b ; s/this is line/*/' data.txt * 1. * 2. this is line 3. * 4. * 5. sed ' \u003e 3b start \u003e s/this is line/*/ \u003e :start \u003e s/this is line/jump/ \u003e ' data.txt * 1. * 2. jump 3. * 4. * 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:7","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"8. 测试命令 测试命令t会根据替换命令的结果，来决定是否跳转到某个标签。 如果没有指定标签，则跳转到命令结尾。 sed ' \u003e s/line 3/*/ \u003e t \u003e s/this is line/*/ \u003e ' data.txt * 1. * 2. this is *. * 4. * 5. ","date":"2020-10-05","objectID":"/linux_sed/:4:8","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"9. 匹配模式 \u0026符号代表替换命令中与模式匹配的文本。 $ echo \"The cat sleeps in his hat.\" | sed 's/.at/\"\u0026\"/g' The \"cat\" sleeps in his \"hat\". 也可以提取匹配项组中的某一项。 # 提取第一个匹配项.cat $ echo \"That furry cat is pretty\" | sed 's/furry \\(.at\\)/\\1/' That cat is pretty ","date":"2020-10-05","objectID":"/linux_sed/:4:9","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"sed 示例 ","date":"2020-10-05","objectID":"/linux_sed/:5:0","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"1. 反序输出文本 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. # tac命令可以反序输出 $ tac data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. # sed也可以反序输出 $ sed -n '1!G; h; $p' data.txt this is line 5. this is line 4. this is line 3. this is line 2. this is line 1. ","date":"2020-10-05","objectID":"/linux_sed/:5:1","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"2. 加倍行距 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/^$/d;$!G' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:2","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"3. 给文件的行编号 $ nl data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 this is line 4. 5 this is line 5. $ cat -n data.txt 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. $ sed '=' data.txt | sed 'N; s/\\n/ /' 1 this is line 1. 2 this is line 2. 3 this is line 3. 4 5 this is line 4. 6 this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:3","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"4. 打印末尾行 # 打印最后10行 $ sed ':start; N; 11,$D; b start' data.txt this is line 5. this is line 6. this is line 7. this is line 8. this is line 9. this is line 10. this is line 11. this is line 12. this is line 13. this is line 14. ","date":"2020-10-05","objectID":"/linux_sed/:5:4","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"5. 删除文本中的连续空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,/^$/!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. 注意，/./和/^$/是正则表达式。 ","date":"2020-10-05","objectID":"/linux_sed/:5:5","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"6. 删除开头空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed '/./,$!d' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. 注意，/./是正则表达式。 ","date":"2020-10-05","objectID":"/linux_sed/:5:6","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["Linux"],"content":"7. 删除结尾空白行 $ cat data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. $ sed ':start; /^\\n*$/{$d; N; b start}' data.txt this is line 1. this is line 2. this is line 3. this is line 4. this is line 5. ","date":"2020-10-05","objectID":"/linux_sed/:5:7","tags":["Linux","sed"],"title":"【Linux】sed命令详解","uri":"/linux_sed/"},{"categories":["MySQL"],"content":"information_schema介绍 information_schema库中，存放着多个视图，主要用来统计数据库相关的元数据。常用的有： TABLES。 ","date":"2020-08-06","objectID":"/mysql-information-schema/:1:0","tags":["MySQL"],"title":"【MySQL】information_schema","uri":"/mysql-information-schema/"},{"categories":["MySQL"],"content":"TABLES ","date":"2020-08-06","objectID":"/mysql-information-schema/:2:0","tags":["MySQL"],"title":"【MySQL】information_schema","uri":"/mysql-information-schema/"},{"categories":["MySQL"],"content":"1. 说明 保存了所有表的数据信息。 ","date":"2020-08-06","objectID":"/mysql-information-schema/:2:1","tags":["MySQL"],"title":"【MySQL】information_schema","uri":"/mysql-information-schema/"},{"categories":["MySQL"],"content":"2. 常用字段说明 TABLE_SCHEMA：表所在的库。 TABLE_NAME：表名。 ENGINE：表使用的引擎。 TABLE_ROWS：表的数据行，非实时。 AVG_ROW_LENGTH：表行长度的平均值。 DATA_LENGTH：表的存储空间大小，非实时。 INDEX_LENGTH：索引占用空间大小。 DATA_FREE：表中是否有碎片。 ","date":"2020-08-06","objectID":"/mysql-information-schema/:2:2","tags":["MySQL"],"title":"【MySQL】information_schema","uri":"/mysql-information-schema/"},{"categories":["MySQL"],"content":"3. 示例 统计每个库中，所有表的个数，以及所有表名。 SELECTTABLE_SCHEMA,count(TABLE_NAME),group_concat(TABLE_NAME)FROMinformation_schema.TABLESGROUPBYTABLE_SCHEMA; ","date":"2020-08-06","objectID":"/mysql-information-schema/:2:3","tags":["MySQL"],"title":"【MySQL】information_schema","uri":"/mysql-information-schema/"},{"categories":["MySQL"],"content":"慢查询日志 慢查询日志可以记录响应时间超过阈值的SQL语句，默认阈值为10秒。 该日志默认关闭，建议调优时打开，最终部署时关闭。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"1. 检查是否打开了慢查询日志 SHOWVARIABLESLIKE'%slow_query_log%'; ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:1","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"2. 临时开启 SETGLOBALslow_query_log=1; MySQL服务器重启后会失效。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:2","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"3. 永久开启 #/etc/my.cnf追加 [mysqld] slow_query_log=1 slow_query_log_file=/var/lib/mysql/local-slow.log # 日志文件路径 ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:3","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"4. 查看慢查询阀值 SHOWVARIABLESLIKE\"%long_query_time%\"; 或者： SELECT@@long_query_time; ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:4","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"5. 设置慢查询阀值 SETGLOBALlong_query_time=5; 重新连接数据库后才生效。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:5","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"6. 永久设置阀值 #在/etc/my.cnf追加 [mysqld] long_query_time=3 ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:6","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"7. 查询超过阀值的sql个数 SHOWGLOBALSTATUSLIKE'%slow_queries%'; ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:7","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"8. mysqldumpslow 可以使用mysqldumpslow工具查看慢查询日志，用法为： mysqldumpslow 日志文件 ","date":"2020-08-04","objectID":"/mysql-optimizer/:1:8","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"查看服务器状态 可以使用如下命令查看服务器状态信息： SHOW[SESSION|GLOBAL]STATUS; 如果想查看SQL语句执行频率的统计信息，可以使用： SHOW[SESSION|GLOBAL]STATUSLIKE\"Com_______\"; 如果想查看InnoDB数据行的统计信息，可以使用： SHOW[SESSION|GLOBAL]STATUSLIKE\"InnoDB_rows_%\"; ","date":"2020-08-04","objectID":"/mysql-optimizer/:2:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"排查低效率语句 排查低效率SQL语句，有以下两种方法： 慢查询 show processlist ","date":"2020-08-04","objectID":"/mysql-optimizer/:3:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"执行计划字段分析 获取执行计划的语法为：EXPLAIN SQL语句。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"1. id select查询的序列号，表示查询中执行select子句的顺序。 id相同时，查询顺序从上往下。 id不同时，值越大，越先被执行。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:1","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"2. select_type SELECT的类型。 SIMPLE：简单查询，不包含子查询和UNION。 PRIMARY：包含子查询的SQL语句中的主查询（最外层）。 SUBQUERY：在SELECT子句或者WHERE子句中，包含的子查询。 DERIVED：衍生查询，使用到了临时表。FROM子句中的子查询会被标记为DERIVED，又或者UNION包含在FROM子句的子查询中，外层SELECT将会被标记为DRIVED。 UNION：UNION中的第二个或者之后的查询语句。 UNION RESULT：对UNION结果进行的查询。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:2","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"3. table 查询的表。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:3","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"4. type 表示表的访问类型。 连接类型的性能由好到坏，依次是：NULL、system、const、eq_ref、ref、fulltext、ref_or_null、index_merge、unique_subquery、index_subquery、range、index和all。 system，const很难遇见，最好能达到ref和range级别。 NULL 不访问任何表，直接返回结果。 system（忽略） 只有一条数据的系统表，或衍生表只有一条数据的主查询。 const 仅仅能查到一条数据的SQL，用于primary key或者unique索引。 eq_ref 用于连接查询。 对于每个索引键的查询，返回匹配的唯一行数据，有且只有1个，不能为0。 常见于唯一索引和主键索引。 ref 非唯一性索引查询，返回匹配的所有行。 range 检索指定范围的行，需要使用一个索引。 index 对索引表进行遍历。 all 对数据表进行遍历。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:4","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"5. Possible_keys 可能用到的索引。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:5","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"6. key 实际用到的索引。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:6","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"7. key_len 索引使用的字节数，其值为索引字段最大可能长度，越短越好。 可用于判断复合索引是否被完全使用。 对于utf8，一个字符占3个字节。如果索引字段可以为null，则会使用1个字节用于标识。如果索引字段为varchar，使用2个字节标识可变长度。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:7","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"8. ref 用于指明当前表所参照的字段，注意跟type中的ref值区分开。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:8","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"9. rows 实际通过索引查询到的数据个数。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:9","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"10. extra 执行情况的额外说明。 using filesort 需要额外进行一次排序，而不是使用索引的顺序，性能消耗大。常见于order by语句中。 示例1： explainselect*fromtestwherea1=''orderbya2; 小结：对于单索引，如果排序和查找是同一个字段，则不会出现using filesort；如果排序和查找不是同一个字段，则会出现using filesort。 示例2：（注意存在a1, a2, a3, a4四个字段） altertabletestaddindexidx_a1_a2_a3(a1,a2,a3);explainselect*fromtestwherea1=''orderbya3;#usingfilesortexplainselect*fromtestwherea2=''orderbya3;#usingfilesortexplainselect*fromtestwherea1=''orderbya2; 小结：对于复合索引，where和order by按照复合索引的顺序使用，不要跨列或无序使用。 using temporary 用到了临时表，性能损耗大。一般出现在order by和group by语句中。 示例： explainselect*fromtestwherea1in(1,2,3)groupbya1;explainselect*fromtestwherea1in(1,2,3)groupbya2;#usingtemporary using index 性能较好，常见于索引覆盖。 只要使用到的列，全部都在索引中，就称为”索引覆盖“。 这时只需要从索引文件中获取数据，不需要读取数据文件，即不回表查询。 using where 回表查询时，会出现using where。 impossible where where子句永远为false。 using join buffer mysql引擎使用了连接缓存。 using index condition 索引下推，先进行条件过滤再回表。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:4:10","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"语句分析 ","date":"2020-08-04","objectID":"/mysql-optimizer/:5:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"1. profiles 查看是否支持profiles。 SHOWVARIABLESLIKE\"%have_profiling%\"; 或者： SELECT@@have_profiling; 查看profiles开启状态。 SHOWVARIABLESLIKE\"profiling\"; 或者： SELECT@@profiling; 返回的结果中，OFF或者0表示关闭，ON或者1表示开启。 打开profiles。 SETprofiling=ON; 或者： SETprofiling=1; proflie开启之后，会记录所有查询语句所花的时间，但是不是很精确。 关闭profiles。 SETprofiling=OFF; 或者： SETprofiling=0; 查看profiles统计信息 SHOWprofiles; 查看某个查询的性能 SHOWPROFILE[type...]FROMQUERYquery_id; query_id可以通过上一个命令获取。 type如果省略，则只显示时间消耗。常见的type参数有ALL、BLOCK IO、CPU、IPC等，表示需要进行分析的具体内容。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:5:1","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"2. trace MySQL5.6开始提供了针对SQL语句的TRACE，通过TRACE文件，可以知道执行计划的生成过程。 查看trace的开启情况。 SHOWVARIABLESLIKE\"optimizer_trace\"; 或者： SELECT@@optimizer_trace; 打开trace。 SEToptimizer_trace=\"enabled=on,one_line=off\"; 设置trace能使用的内存大小。 SEToptimizer_trace_max_mem_size=1048576; 查看分析结果 SELECT*FROMinformation_schema.optimizer_trace\\G ","date":"2020-08-04","objectID":"/mysql-optimizer/:5:2","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"3. 记录全局日志 记录开启之后的全部sql语句，建议只在调优和开发过程中打开。 查看状态 SHOWVARIABLESLIKE'%general_log%';SHOWVARIABLESLIKE\"%log_output%\"; 开启，并将sql记录在表里 SETGLOBALgeneral_log=1;SETGLOBALlog_output='table'; 开启，并将sql记录在文件里 SETGLOBALgeneral_log=1;SETGLOBALlog_output='file';SETGLOBALgeneral_log_file='/tmp/general.log'; ","date":"2020-08-04","objectID":"/mysql-optimizer/:5:3","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"批量导入数据的优化 ","date":"2020-08-04","objectID":"/mysql-optimizer/:6:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"1. 批量插入数据的命令 LOADDATALOCALinfile数据文件路径INTOTABLE表名FIELDSTERMINATEDBY','LINESTERMINATEDBY'\\n'; 对于数据文件中的每行数据，以,号来分隔每个字段。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:6:1","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"2. 优化建议 按照主键顺序插入。 关闭对唯一性索引的校验： SETUNIQUE_CHECKS=0; 关闭事务的自动提交： SETAUTOCOMMIT=0; ","date":"2020-08-04","objectID":"/mysql-optimizer/:6:2","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"INSERT优化 如果对一张表插入多条数据，尽量将多条数据放在一个INSERT语句中，能降低客户端和数据库的连接、关闭消耗，效率会比分开执行的INSERT语句快。 将多个插入放在一个事务中。 按照主键的顺序插入。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:7:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"group by优化 group by除了会进行分组外，还会进行排序操作。如果分组时使用了聚合函数，则也会进行聚合函数的计算。 如果想避免排序造成的性能消耗，可以在group by子句之后，使用order by null来取消排序。 除了取消排序，还可以对分组字段建立索引。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:8:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"子查询优化 使用子查询，可以一次性完成需要多个步骤才能完成的工作。 子查询的优化准则为，尽量使用连接查询代替子查询。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:9:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"or优化 对于包含OR的查询语句，如果要使用到索引，则OR两侧的每个条件都必须用到索引。 优化方式除了增加索引外，还可以使用union替代or。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:10:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"分页查询优化 在索引上完成排序分页操作，然后回数据表查询所需的其他字段。 将limit查询转换成对某个位置的查询，适用于主键自增的表，即不能出现主键断层。如id \u003e 10000 limit 10。 如果想优化count()，可以新建一张表，记录总数。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:11:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"人为控制索引 ","date":"2020-08-04","objectID":"/mysql-optimizer/:12:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"1. USE INDEX 使用USE INDEX(索引名)，可以让MySQL只参考指定的索引，但不一定会使用。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:12:1","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"2. IGNORE INDEX 可以使用IGNORE INDEX(索引名)，来让MySQL忽略一个或多个索引。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:12:2","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"3. FORCE INDEX 通过使用FORCE INDEX(索引名)，可以强制要求MySQL使用指定的索引。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:12:3","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"应用层面的优化 ","date":"2020-08-04","objectID":"/mysql-optimizer/:13:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"1. 使用连接池 对于数据库来说，建立连接的代价比较昂贵，因此，如果频繁的建立和关闭连接，会消耗较多资源。建立连接池，可以减少连接次数，提高访问性能。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:13:1","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"2. 避免对数据进行重复查询 尽量一次性获取所需数据，减少无用的重复请求。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:13:2","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"3. 增加缓存 可以在应用层和数据库之间，增加缓存层。查询数据时，直接访问缓存层，即可以提高查询速度，也可以降低数据库的压力。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:13:3","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"4. 对查询进行分流 通过MySQL的主从复制，可以实现读写分离。 增删改操作由主结点执行，查询操作则分发给从结点，从而可以降低单台服务器的读写压力。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:13:4","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"5. 分布式数据库架构 将数据分布在多台服务器，可以很好实现负载均衡，从而解决大数据量和高负载问题。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:13:5","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"MySQL并发参数 ","date":"2020-08-04","objectID":"/mysql-optimizer/:14:0","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"1. max_connections max_connections用于控制MySQL数据库的最大连接数，默认151，查看变量值的命令为： SHOWVARIABLESLIKE\"max_connections\"; 或者： SELECT@@global.max_connections; 注意，max_connections是全局变量。 当连接数达到最大值时，后续的连接请求可能会失败。查看失败的连接请求数的命令为： SHOWSTATUSLIKE\"connection_errors_max_connections\"; 设置最大连接数时，需要考虑多个因素的影响。如操作系统的内存大小、连接的负荷、cpu性能、期望的响应时间等。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:14:1","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"2. back_log 如果MySQL的连接数达到max_connections，新来的请求会被放在堆栈中，back_log参数就是该堆栈能容纳的数量。 如果等待连接的数量超过back_log，新的连接请求就会报错。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:14:2","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"3. thread_cache_size MySQL数据库会缓存一些服务线程，当又客户端请求到来时，会将其中的服务线程分配给连接会话使用。 thread_cache_size用于控制该线程数量。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:14:3","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"4. innodb_lock_wait_timeout 该参数，主要用于控制InnoDB事务等待行锁的时间。 ","date":"2020-08-04","objectID":"/mysql-optimizer/:14:4","tags":["MySQL"],"title":"【MySQL】优化","uri":"/mysql-optimizer/"},{"categories":["MySQL"],"content":"什么是存储引擎 存储引擎，是数据库存储数据、建立索引、更新数据和查询数据等功能的具体实现。 存储引擎是基于表的，即不同的表可以使用不同的存储引擎。 在MySQL中，若想查看数据库支持的存储引擎，语句为： showengines; 若想查看存储引擎相关配置，语句为： showvariableslike\"%engine%\"; ","date":"2020-08-03","objectID":"/mysql-engines/:1:0","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"Innodb ","date":"2020-08-03","objectID":"/mysql-engines/:2:0","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"1. 表空间文件模式 InnoDB包含两种表空间文件模式：共享表空间和独立表空间。 共享表空间，是指所有数据保存在一个表空间里面，而这个表空间可以由多个文件组成，一个表可以跨多个文件。该模式下，使用drop table命令删除表时，会删除整个文件。 独立表空间，是指每张表存放在独立的表空间，每个表空间都有多个数据文件。该模式下，使用drop talbe删除表时不会回收空间。 可以通过参数innodb_file_per_table查看表空间的模式，参数为0表示为共享表空间，参数为1表示为独立表空间。 MySQL5.6.6开始，默认使用的是独立表空间，这样便于管理表数据。 ","date":"2020-08-03","objectID":"/mysql-engines/:2:1","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"2. 文件存储形式 使用共享表空间时，表结构存储在.frm文件中，数据和索引存放在innodb_data_home_dir和innodb_data_file_path定义的表空间中，可以是多个文件。 使用独立表空间时，每张表都有独立的表空间。表结构存放在.frm文件中，数据和索引存放在.ibd中，每个文件的名字就是表的名字。 注意，MySQL8.0之后，不再使用.frm文件，表结构和数据存放在一起。 ","date":"2020-08-03","objectID":"/mysql-engines/:2:2","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"删除数据 在独立表空间中，使用delete删除数据时，会造成空洞。 因为删除记录时，InnoDB引擎只会把该记录标记为删除，但磁盘空间不会被回收。等到插入数据时，可以复用该位置。 如果整个数据页的数据被删除，那么该数据页就可以被复用。 如果相邻数据页的利用率很小，系统会将它们合并到一个数据页上，此时另一个数据页也能被复用。 对记录的位置进行复用时，要求插入的数据符合该位置的范围条件，对数据页的复用则没有该限制。 ","date":"2020-08-03","objectID":"/mysql-engines/:2:3","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"插入数据 在独立表空间中，插入数据时，也可能造成空洞。 如果数据按照索引递增的顺序插入，索引的数据会很紧凑，不会造成分裂。 如果数据是随机插入的，则可能会发生索引数据页的分裂，从而导致空洞。 ","date":"2020-08-03","objectID":"/mysql-engines/:2:4","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"重建表 在独立表空间中，为了消除空洞，可以对数据表进行重建。重建命令为： altertable表名engine=InnoDB; MySQL5.6之前，重建命令的执行流程为： server层创建临时表B，B和A的表结构一致。 按主键递增的顺序，将A的数据复制到B。 用B替换A。 流程执行过程中，A不能有更新，即该流程不是Online的。 MySQL5.6开始，重建命令的执行流程为： InnoDB引擎新建临时文件。 将A的数据页存储到临时文件中。 生成临时文件的过程中，将对A的操作记录到row log。 将row log中的操作应用到临时文件。 用临时文件替换表A的数据文件。 该流程是Online的。alter语句在启动时，会自动获取MDL写锁，然后很快会变成MDL读锁。 重建表还可以使用如下命令： optimizetale表名; 该命令等同于alter table...和analyze table A一起执行。analyze用于对表的索引信息做重新统计。 ","date":"2020-08-03","objectID":"/mysql-engines/:2:5","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"MyISAM ","date":"2020-08-03","objectID":"/mysql-engines/:3:0","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"1. 文件存储形式 对于不同的表，MyISAM会在磁盘上生成三类文件。每个文件的文件名和表名相同，但扩展名分别如下： .frm：存储表定义，MySQL8.0版本开始，不再生成该类文件。 .MYD：MYDATA，存储数据。 .MYI：MYIndex，存储索引。 ","date":"2020-08-03","objectID":"/mysql-engines/:3:1","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"Memory Memory存储引擎有如下特性： 每个Memory表对应一个.frm磁盘文件，该文件只存储表结构。 Memory表的数据都是存放在内存中的，因此数据的处理速度非常快。 默认使用HASH索引。 MySQL服务一旦关闭，数据就会丢失。 ","date":"2020-08-03","objectID":"/mysql-engines/:4:0","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"引擎选择原则 ","date":"2020-08-03","objectID":"/mysql-engines/:5:0","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"1. InnoDB InnoDB是MySQL的默认存储引擎，支持事务和外健。如果数据的更新、删除操作较多，或者在并发条件下要求数据一致性，或者要求确保事务的完整提交和回滚，InnoDB是比较合适的选择。 ","date":"2020-08-03","objectID":"/mysql-engines/:5:1","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"2. MyISAM 如果读数据和插入数据的操作较多，但是更新和删除数据的操作较少，且对事务以及并发性无要求。则可以选择MyISAM。 ","date":"2020-08-03","objectID":"/mysql-engines/:5:2","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"3. Memory 如果数据量不大，并且数据可以恢复，或者可以容忍数据丢失，则可以使用Memory。 ","date":"2020-08-03","objectID":"/mysql-engines/:5:3","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"MyISAM与InnoDB的比较 MyISAM不支持主外键；InnoDB支持主外键。 MyISAM不支持事务；InnoDB支持事务。 MyISAM使用表锁，即使操作一条记录也会锁住整个表，不适合高并发操作；InnoDB使用行锁，操作时只锁一行，不对其他行有影响，适合高并发的操作。 MyISAM只缓存索引，不缓存真实数据；InnoDB不仅缓存索引还缓存真实数据，对内存要求较高，并且内存大小对性能有决定性影响。 MyISAM表空间小；InnoDB表空间大。 ","date":"2020-08-03","objectID":"/mysql-engines/:6:0","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"数据库引擎相关操作 ","date":"2020-08-03","objectID":"/mysql-engines/:6:1","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"1. 查看支持的引擎 SHOWengines; ","date":"2020-08-03","objectID":"/mysql-engines/:6:2","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"2. 查看默认使用的引擎 SHOWVARIABLESLIKE\"default_storage_engin\"; ","date":"2020-08-03","objectID":"/mysql-engines/:6:3","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"3. 手动指定引擎 CREATETABLEtb(...)engine=InnoDBDEFAULTcharset=utf8mb4; ","date":"2020-08-03","objectID":"/mysql-engines/:6:4","tags":["MySQL"],"title":"【MySQL】存储引擎","uri":"/mysql-engines/"},{"categories":["MySQL"],"content":"Mysql的更新流程会涉及到两个重要日志模块：redo log（重做日志）和bin log（归档日志） ","date":"2020-08-02","objectID":"/mysql-log/:0:0","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"Redo log redo log是InnoDB引擎特有的日志，记录的是数据页的修改操作。日志大小固定，并以循环的方式写入.即从头开始写，写到末尾，然后重新回到开头。 ","date":"2020-08-02","objectID":"/mysql-log/:1:0","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"crash-safe 有了redo log，即使数据库异常重启，之前提交的记录也不会丢失，这种能力称为crash-safe。 ","date":"2020-08-02","objectID":"/mysql-log/:1:1","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"WAL技术 WAL全称是Write-Ahead Logging，是指先写日志，再更新磁盘的数据页。 如果每次更新的数据都直接写到磁盘，那么磁盘每次都需要查找对应记录，并且更新，io成本和查找成本太高。因为写入日志时，使用的是顺序写，速度较快，所以先写日志的效率更高。 ","date":"2020-08-02","objectID":"/mysql-log/:1:2","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"执行流程 当有一条记录更新，InnoDB引擎会先把记录写到redo log，并更新内存。 系统比较空闲时，InnoDB引擎会将操作记录更新到磁盘。 如果日志文件写满了，也会将一部分操作更新到磁盘。 ","date":"2020-08-02","objectID":"/mysql-log/:1:3","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"innodb_flush_log_at_trx_commit innodb_flush_log_at_trx_commit参数用于控制redo log的写入策略。 0: 每隔1秒，将redo log buffer中的日志刷新到磁盘。性能最好，会丢日志。 1: 每次提交事务时，将redo log日志全部刷新到磁盘。最慢。 2: 每次提交事务时，先将redo log日志写到操作系统的文件缓存，再每秒刷新到磁盘。操作系统崩溃时会丢日志。 参数为0时，可能会将未提交事务的redo log持久化到磁盘。 redo log buffer占用空间达到innodb_log_buffer_size一半的时候，后台线程会将redo log写入操作系统的文件缓存。 如果参数为1，事务A提交时，也会将事务B的redo log持久化到磁盘，即使事务B未提交。redo log在prepare阶段会持久化到磁盘，在commit阶段只会刷新到操作系统的文件缓存。 ","date":"2020-08-02","objectID":"/mysql-log/:1:4","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"bin log bin log是Server层的日志，主要用于归档。 ","date":"2020-08-02","objectID":"/mysql-log/:2:0","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"bin log日志格式 使用如下SQL语句可以查看bin log的日志格式： SHOWVARIABLESLIKE\"binlog_format\"; 或者： SELECT@@binlog_format; statement 设置为该格式时，日志文件中记录的是SQL语句。 对数据进行增、删、改的SQL语句，都会被记录在日志文件中，可以使用mysqlbinlog查看每条语句的内容。 row 设置为该日志格式时，日志记录的是每一行的数据变更，而不是SQL语句本身。 mixed mixed混合了statement和row两种格式。默认情况采用statement格式，但是在某些情况下，会使用row来记录日志。 ","date":"2020-08-02","objectID":"/mysql-log/:2:1","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"归档流程 以下介绍误删表时，bin log的归档流程： 找到最近的一次全备份，恢复到临时库。 从全备份的时间点开始，将bin log依次取出来，恢复到误删表之前的时刻。 从临时库中取出表数据，按需恢复到线上库。 ","date":"2020-08-02","objectID":"/mysql-log/:2:2","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"binlog的写入机制 写入机制为： 事务执行过程中，先把日志写到binlog cache。 事务提交时，将binlog cache中的完整事务写入到binlog文件中。 清空binlog cache。 每个连接线程都有一个binlog cache，所占内存大小由binlog_cache_size控制。 所有的线程共用一个binlog文件，将内存数据持久化到binlog文件时，需要先写入到操作系统的文件缓存，然后再写入磁盘。 ","date":"2020-08-02","objectID":"/mysql-log/:2:3","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"sync_binlog sync_binlog参数控制着日志写入到磁盘的频率： 0：每次提交事务时，只将日志写到文件缓存。 1：每提交一次事务，就将日志刷新到磁盘。最安全但性能最低。 n：每次提交事务，都将日志写入文件缓存。提交n次事务后，将缓存中的日志刷新到磁盘。 ","date":"2020-08-02","objectID":"/mysql-log/:2:4","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"二者的差异 redo log是InnoDB引擎特有的；bin log是Server层实现的，所有引擎都可用。 redo log是物理日志，记录了在某个数据页上做了什么修改；bin log是逻辑日志，记录的是语句的原始逻辑。 redo log是循环写，bin log是追加写。 redo log用于crash-safe，bin log用于归档。 ","date":"2020-08-02","objectID":"/mysql-log/:3:0","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"二者的联系 在崩溃恢复的场景中，InnoDB如果判断一个数据页丢失了更新，会去读redo log。 如果redo log既有prepare状态，又有commit状态，则直接提交该事务。 如果只有commit状态，就从redo log中获取XID，然后去bin log查找对应事务。 ","date":"2020-08-02","objectID":"/mysql-log/:4:0","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"更新时的日志状态 记录更新时的状态变化如下： 执行器找引擎取指定行数据。如果数据页位于内存，就直接返回给执行器；如果不在内存中，则先从磁盘加载再返回。 执行器拿到数据进行修改，调用引擎接口写入这行新数据。 引擎将新数据记录到内存，将更新操作记录到redo log，将redo log设为prepare状态，告知执行器执行完成。 执行器生成bin log并视情况写入磁盘。 调用引擎接口提交事务，引擎将redo log改为commit状态，流程结束。 ","date":"2020-08-02","objectID":"/mysql-log/:5:0","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"两阶段提交 更新过程中使用的是两阶段提交，即先将redo log设为prepare状态，再生成bin log，最后将redo log设为commit状态。目的是为了让两份日志之间的逻辑一致。 如果不用两阶段提交，可能会导致主从数据库、或者主备数据库逻辑上的不一致： 如果先写redo log再写bin log，写redo log之后、bin log之前，系统crash，用bin log恢复出来的数据会比原库少。 如果先写bin log再写redo log，写bin log之后、redo log之前，系统crash，用bin log恢复出来的数据会比原库多。 ","date":"2020-08-02","objectID":"/mysql-log/:6:0","tags":["MySQL"],"title":"【MySQL】日志","uri":"/mysql-log/"},{"categories":["MySQL"],"content":"锁的概念 锁被用于解决因资源共享，造成的并发问题。 或者说，数据库的锁是为了解决事务的隔离性问题，让事务之间互不影响。 ","date":"2020-08-02","objectID":"/mysql-locks/:1:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"锁的分类 锁的具体分类为： 全局锁 表级锁 行锁 ","date":"2020-08-02","objectID":"/mysql-locks/:2:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"全局锁 全局锁用于对整个数据库实例加锁。命令如下： flushtableswithreadlock; 加锁之后，数据库处于只读状态。使用unlock tables释放锁。 其他线程的以下语句会被阻塞：数据增删改、删表建表、修改表结构、删库建库和更新类事务的提交语句。 ","date":"2020-08-02","objectID":"/mysql-locks/:3:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"全库逻辑备份 全库逻辑备份，是全局锁的典型使用场景。此时使用全局锁会存在如下缺陷： 如果在主库执行备份，会让更新无法执行。 如果在从库执行备份，备库将不能执行主库同步过来的bin log，导致主从延迟。 如果不加锁，会导致得到的备份不在一个逻辑时间点。 ","date":"2020-08-02","objectID":"/mysql-locks/:3:1","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"--single-transaction 如果mysqldump使用了参数--single-transaction，导出数据前将会启动一个事务，确保拿到一致性视图。通过该方式，可以避免加全局锁。 前提是引擎要支持可重复读隔离级别和事务，并且所有表都使用了该引擎，才能使用该参数。MyISAM不支持事务，因此无法使用该参数。 ","date":"2020-08-02","objectID":"/mysql-locks/:3:2","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"readonly 语法为： setglobalreadonly=true readonly也可以让全库进入只读状态，但是全局锁场景下不推荐。原因如下： 有些系统中，readonly会被用来做其他逻辑，如判断主库和备库。 如果客户端发生异常，会自动释放使用FTWRL加的全局锁，使用readonly后数据库会一直保持该状态。 ","date":"2020-08-02","objectID":"/mysql-locks/:3:3","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"表级锁 表级锁会一次性对一张表整体加锁，具体分为表锁和元数据锁两种。 ","date":"2020-08-02","objectID":"/mysql-locks/:4:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"表锁 加锁语法如下： locktables表名...read/write read锁会阻塞本线程和其他线程的写操作，不会阻塞读操作。本线程不能对其他表进行读写操作，其他线程可以对其他表进行读写操作。 write锁会阻塞其他线程的读写操作，不会阻塞本线程的读写操作。本线程不能对其他表进行读写操作，其他线程可以对其他表进行读写操作。 锁的释放时机如下： 客户端断开时会自动释放。 执行unlock tables命令也会主动释放。 再次执行lock tables获取表锁时，会释放之前持有的锁。 执行start trasaction或者begin开启事务时，会释放锁。 ","date":"2020-08-02","objectID":"/mysql-locks/:4:1","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"MDL(meta data lock) MySQL5.5版本引入了MDL。 锁的规则如下： 对一个表做增删改查操作时，会自动对该表加MDL读锁，对表结构做变更操作时，会自动对该表加MDL写锁。 读锁之间不互斥，多个线程可以对一张表增删改查。 读写锁、写写锁之间互斥。 锁的释放时机如下： 事务执行时会申请MDL锁，等到事务提交或回滚后锁才会释放。 会话断开时，会自动释放。 如果程序中有lock tables和unlock tables语法，可以尽量改成begin和commit。 ","date":"2020-08-02","objectID":"/mysql-locks/:4:2","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"修改表结构 给表加字段、或者加索引都需要小心，否则很有可能会出现如下问题： 事务A正在读表数据，会加MDL读锁。 有事务B想修改表结构，会请求MDL写锁，被阻塞。 其他事务想读取表数据，会被MDL写锁阻塞。 线程会爆满。 如果想给表加字段。可以设置语句的等待时间，等待时间内拿不到写锁就放弃，之后再重试。MariaDB和AliSQL已经支持NOWAIT/WAIT n语法。 ","date":"2020-08-02","objectID":"/mysql-locks/:4:3","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"分析表锁状态 查看表锁定的状态 showopentables;#In_use是1代表加了锁 分析表锁的竞争状态 showstatuslike'table%'; table_lock_immediate：立即获取到表锁的次数。 tale_locks_waited：等待表锁的次数，该值越大，锁竞争越大。 当table_locks_immediate / table_locks_waited \u003e 5000，建议采用InnoDB引擎。 ","date":"2020-08-02","objectID":"/mysql-locks/:4:4","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"行锁 行锁是各个引擎自己实现的，MyISAM不支持行锁，而InnoDB支持行锁。 行锁按类型分为：读意向锁、写意向锁、读锁、写锁、自增锁。 行锁按粒度分为：记录锁、间隙锁、next-key lock、插入意向锁。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"意向锁 意向锁是一种不与行级锁冲突的表级锁。 读意向锁：也叫意向共享锁IS，事务有意向对表中的某些行加共享锁（S锁）。 写意向锁：也叫意向排他锁IX，事务有意向对表中的某些行加排他锁（X锁）。 意向锁不需要手动添加，在给数据行加共享锁/排他锁之前，会自动给数据所在表加意向锁。 意向锁存在的意义： 当给整张表加锁时，需要判断表是否持有行锁。有了意向锁，就不需要扫描整张表查找行锁，只需要判断表是否持有意向锁即可。 意向锁的冲突规则为： 意向锁和行锁不冲突。 意向锁和AUTO_INC表锁不冲突。 意向共享锁和表级共享锁兼容。 意向共享锁和表级排他锁冲突。 意向排他锁和表级共享锁冲突。 意向排他锁和表级排他锁冲突。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:1","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"读写锁 读锁：也叫共享锁（S锁）。加了读锁的记录，所有事务都可以读取，但是不能修改。可以有多个事务对记录加读锁。 写锁：也叫排他锁（X锁），或独占锁。加了写锁的记录，只有持有锁的事务才能读写。同一时间只能有一个事务加写锁。 对于增、删、改操作，InnoDB会自动给记录添加排他锁。对于查询操作，InnoDB不会加任何锁。 如果想显式加锁，语法为： 加共享锁： SQL查询语句LOCKINSHAREMODE; 加排他锁： SQL查询语句FORUPDATE; ","date":"2020-08-02","objectID":"/mysql-locks/:5:2","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"自增锁 自增锁也叫AUTO_INC，是一种表锁。当插入的表中有自增列，且数据库需要自动生成自增值时，会为该表加AUTO_INC表锁。 下文会详细叙述自增锁的机制原理。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:3","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"记录锁 记录锁就是给每行记录加上的行锁，又称record锁。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:4","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"间隙锁 间隙锁是一种加在索引之间的锁，又称gap锁，只有在InnoDB的可重复度读隔离级别下才使用。 使用间隙锁，可以防止其他事务在这个范围内插入或者修改记录，从而避免出现幻读现象。 间隙锁和间隙锁之间互不冲突。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:5","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"next-key lock next-key lock是行锁和间隙锁的组合。 对于存储引擎Innodb，如果事务的隔离级别为可重复读，则此时使用的锁就是next-key lock。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:6","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"插入意向锁 插入意向锁，是一种间隙锁，不是意向锁。 只有insert的时候，才会加插入意向锁。 插入意向锁之间互不冲突，不同事务对同一个间隙插入值时，只要索引无冲突，事务之间就不会有冲突。 如果某个间隙已经存在该锁，在该间隙加其他锁不会引起冲突。 如果某个间隙存在间隙锁，则该间隙无法再加插入意向锁。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:7","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"两阶段协议 InnoDB事务中，行锁是在需要的时候加上去的，等到事务结束时释放。这就是两阶段锁协议。 如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后移。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:8","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"查看行锁状态 showstatuslike'%innodb_row_lock%'; Innodb_row_locl_current_waits：当前正在等待锁的数量。 Innodb_row_lock_time：等待总时长，从系统启动到现在，一共等待的时间。 Innodb_row_lock_time_avg：平均等待时长，从系统启动到现在的平均等待间。 Innodb_row_lock_time_max：最大等待时长，从系统启动到现在的最大等待间。 Innodb_row_lock_waits：从系统启动到现在，等待的次数。 ","date":"2020-08-02","objectID":"/mysql-locks/:5:9","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"死锁 并发系统中，不同线程都在等待对方释放资源时，会导致这些线程进入无限等待的状态，称为死锁。 解决死锁的方式有： 等待超时 死锁检测 控制请求的并发度 ","date":"2020-08-02","objectID":"/mysql-locks/:6:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"等待超时 所谓的等待超时，就是一直等待锁释放直到超时。 超时时间由innodb_lock_wait_timeout参数控制，默认为50s。 注意不能将innodb_lock_wait_timeout设置的很小，否则会造成简单的锁等待超时。 ","date":"2020-08-02","objectID":"/mysql-locks/:6:1","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"死锁检测 所谓的死锁检测，是当一个事务出现锁等待时，判断它依赖的资源有没有被别的线程锁住，最后判断是否出现循环等待，即死锁。死锁检测会消耗大量cpu资源。 发现死锁后，数据库会回滚死锁链条中的某一个事务，从而解决死锁。 将参数innodb_deadlock_detect设置为ON可开启死锁检测。 ","date":"2020-08-02","objectID":"/mysql-locks/:6:2","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"控制并发度 通过控制并发度，也可以减少锁等待个数，降低死锁检测成本。如设计中间件进行请求排队，或者将一行数据改成逻辑上的多行。 ","date":"2020-08-02","objectID":"/mysql-locks/:6:3","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"自增锁 自增锁是一种特殊的表级锁，当事务将数据插入到具有自增列的表中，且申请了自增值时，会产生自增锁。 自增锁的出现，是为了解决高并发场景下自增值的竞争问题。 ","date":"2020-08-02","objectID":"/mysql-locks/:7:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"insert种类 自增锁和insert有关，所以需要先讨论insert的种类。 insert like 任何会产生新记录的插入操作，都叫insert like。 如insert，insert ... select，replace，replace ... select和load data。 simple insert 插入的记录的行数是确定的。 如insert into和replace，但是不包括insert ... on duplicate key update...。 bulk inserts 插入的记录数不能马上确定。 如insert ... select，replace ... select，load data。 mixed-mode inserts 有一部分自增值值是给定的，有一部分自增值是未指定的。 如insert ... on duplicate key update...。 ","date":"2020-08-02","objectID":"/mysql-locks/:7:1","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"innodb_autoinc_lock_mode MySQL5.1.22版本之后，引入了innodb_autoinc_lock_mode参数，用来控制自增锁，默认值1。 参数为0时，自增锁是语句级别，等到语句执行结束，自增锁才会释放。 参数为1时，分两种情况讨论。对于simple insert，自增锁在申请之后就马上释放；对于bulk inserts，自增锁需要等待语句执行结束。 参数为2时，所有的自增锁，都是在申请自增值之后马上释放，并发性能最好。 对于bulk inserts，使用语句级别的自增锁，是为了保证主从复制时的数据一致性。 建议配置innodb_autoinc_lock_mode为2，并且配置binlog_format为row，这样，既能提升并发性，又不会出现数据一致性问题。 ","date":"2020-08-02","objectID":"/mysql-locks/:7:2","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"bulk inserts申请自增id 第一次申请时，分配1个。 同一语句去申请自增id，每次申请到的个数，都是上一次的两倍。 ","date":"2020-08-02","objectID":"/mysql-locks/:7:3","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"mixed-mode inserts申请自增id 每次申请的自增id个数，等于插入的记录个数。 特别需要注意的是insert ... on duplicate key update...语句，申请的自增id个数，等于插入记录数和更新记录数之和。 ","date":"2020-08-02","objectID":"/mysql-locks/:7:4","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"锁的优化建议 尽可能使用索引来完成检索，避免无索引时导致行锁升级为表锁。 合理设计索引，尽量缩小锁的范围。 尽量减少索引条件，缩小索引范围，从而避免间隙锁。 控制事务大小，减少锁定的资源量。 尽可能使用较低的事务隔离级别。 ","date":"2020-08-02","objectID":"/mysql-locks/:8:0","tags":["MySQL"],"title":"【MySQL】锁机制","uri":"/mysql-locks/"},{"categories":["MySQL"],"content":"事务 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:1:0","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"1. 事务的概念 事务是数据库并发操作中，最小的控制单元，由一条或者多条sql语句构成，这些sql语句要么全部执行成功，要么全部执行失败。 事务在引擎层实现。有的引擎支持事务，如InnoDB，有的引擎不支持，如MyISAM和Memory。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:1:1","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"2. 事务的特性 事务具备ACID特性。 原子性 (atomicity)： 事务中所有操作是不可再分割的原子单位。事务的所有操作要么全部执行成功，要么全部执行失败。 一致性 (consistency)： 事务执行后，数据库的状态仍与业务规则保持一致。 如转账业务，无论事务执行成功与否，参与转账的两个账号余额之和应该是不变的。 隔离性 (isolation)： 在并发操作中，不同事务之间保持隔离，不会相互干扰。 持久性 (durability)： 事务一旦提交成功，所有数据操作都会被持久化到数据库。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:1:2","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"3. 事务的分类 事务分为隐式事务和显式事务。 隐式事务没有开启和结束标记，一条SQL语句就是一个事务。使用隐式事务可能导致意外的长事务。 显式事务可以有开启标记，也可以没有开启标记，但是一定要有结束标记。 显式事务的执行步骤为： 取消隐式事务自动开启的功能。 开启事务，开启语句为BEGIN、START TRANSACTION或者什么也不写。 编写事务语句。 结束事务。 对于显式事务，如果不想每次都执行begin，可以使用commit work and chain，表示提交本事务后，自动开启下一个事务。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:1:3","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"4. 使用示例 #取消事务自动开启SETautocommit=0;#开启事务STARTTRANSACTION;#更新数据UPDATEuserinfoSETbalance=balance-5000WHEREuid=1;UPDATEuserinfoSETbalance=balabce+5000WHEREuid=2;#提交COMMIT;#或者回滚#ROLLBACK; ","date":"2020-08-01","objectID":"/mysql-shi-wu/:1:4","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"隔离级别 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:2:0","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"1. 什么是隔离级别 一个事务与其他事务隔离的程度称为隔离级别。 隔离级别越高，数据一致性就越好，但并发性越弱。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:2:1","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"2. 并发问题 当多个事务并发访问数据库中的相同数据时，如果没有使用合适的隔离级别，就会产生各种问题： 脏读。 对于两个事务T1和T2，T1读取了已经被T2更新但还没有被提交的字段，若之后T2回滚，T1读取的内容就是临时且无效的。 不可重复读。 对于两个事务T1和T2，T1读取了一个字段，然后T2更新了该字段，之后T1再次读取同一个字段，获得的值就不同了。 幻读。 对于两个事务T1和T2，T1从一个表中根据某些条件读取出一些记录，然后T2向该表插入了符合条件的新记录。T1再次读取时，就会把新记录也读出来。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:2:2","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"数据库的隔离级别 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:3:0","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"1. 隔离级别说明 读未提交数据（READ UNCOMMITTED） 允许事务读取未被其他事务提交的变更。 会出现脏读，不可重复读和幻读的问题。 读已提交数据（READ COMMITTED） 简称RC。只允许事务读取已经被其他事务提交的变更。 可以避免脏读，但不可重复读和幻读问题仍然会出现。 可重复读（REPEATABLE READ） 简称RR。一个事务执行过程中看到的数据，总是跟它启动时看到的数据一致。 可以避免脏读和不可重复读，但幻读的问题仍然存在。 串行化（SERIALIZABLE） 在事务持续期间，禁止其他事务对该表执行插入、更新和删除操作。对一行记录，”写“会加”写锁“，读会加”读锁“。 所有并发问题都可以避免，但性能十分低下。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:3:1","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"2. Oracle支持的事务隔离级别： READ COMMITED（默认） SERIALIZABLE ","date":"2020-08-01","objectID":"/mysql-shi-wu/:3:2","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"3. Mysql支持的事务隔离级别 READ UNCOMMITTED READ COMMITTED REPEATABLE READ（默认） SERIALIZABLE ","date":"2020-08-01","objectID":"/mysql-shi-wu/:3:3","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"MySql设置隔离级别 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:4:0","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"1. 说明 每启动一个MySQL客户端程序，就会建立一个连接会话，每个连接会话都有一个变量tx_isolation表示当前的事务隔离级别。 注意，新版MySQL使用的是transaction_isolation变量。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:4:1","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"2. 查看当前连接的隔离级别 SELECT@@tx_isolation; ","date":"2020-08-01","objectID":"/mysql-shi-wu/:4:2","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"3. 设置当前连接的隔离级别 当前连接的隔离级别不会影响到其他连接。设置语法如下： setsessiontransactionisolationlevelreaduncommitted; ","date":"2020-08-01","objectID":"/mysql-shi-wu/:4:3","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"4. 设置全局的隔离级别 需要重新建立MySQL连接，全局设置才会生效。语法如下： setglobaltransactionisolationlevelreadcommitted; ","date":"2020-08-01","objectID":"/mysql-shi-wu/:4:4","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"SAVEPOINT ","date":"2020-08-01","objectID":"/mysql-shi-wu/:5:0","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"1. 什么是SAVEPOINT SAVEPOINT是在事务中搭配ROLLBACK一起使用的某种机制，可以控制事务回滚的进度。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:5:1","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"2. 示例 SETautocommit=0;DELETEFROMaccountWHEREid=25;SAVEPOINTa;DELETEFROMaccountWHEREid=28;ROLLBACKTOa; ","date":"2020-08-01","objectID":"/mysql-shi-wu/:5:2","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"长事务弊端 长事务提交前，它可能用到的回滚日志都必须保留，会占用大量存储空间。 MySQL5.5及以前的版本，回滚日志跟数据字典一起放在ibdata文件里，即使回滚段被清除，文件也不会变小。 长事务还会占用锁资源，从而拖垮整个库。 因此，尽量不要使用长事务。 ","date":"2020-08-01","objectID":"/mysql-shi-wu/:6:0","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"查询长事务 如果查询持续时间超过60s的长事务，可以使用如下语句： select * from information_schema.innodb_trx where TIME_TO_SEC(TIMEDIFF(now(), trx_started)) \u003e 60; ","date":"2020-08-01","objectID":"/mysql-shi-wu/:6:1","tags":["MySQL"],"title":"【MySQL】事务","uri":"/mysql-shi-wu/"},{"categories":["MySQL"],"content":"什么是触发器 触发器是与数据表有关的数据库对象。在执行INSERT、UPDATE、DELETE之前或者之后，可以执行触发器中定义的SQL语句。 在触发器中，分别使用OLD和NEW来表示发生变化的记录。 ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:1:0","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"触发器分类 INSERT型触发器： NEW表示将要或者已经新增的数据。 UPDATE型触发器： OLD表示修改之前的数据，NEW表示将要或已经修改的数据。 DELETE型触发器： OLD表示将要或者已经删除的数据。 ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:2:0","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"触发器语法 ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:3:0","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"1. 创建触发器 CREATETRIGGERtrigger_nameBEFORE/AFTERINSERT/UPDATE/DELETEON表名[FOREACHROW]BEGIN语句;END 说明： FOR EACH ROW表示行级触发器，MySQL只支持行级触发器。 需要使用DELIMITER来设置触发器语句的结束标记。 BEGIN/END中的SQL语句不予许返回结果集。 如果语句只有一行，可以省略BEGIN/END关键字。 ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:3:1","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"2. 查看触发器 SHOWTRIGGERS; ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:3:2","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"3. 删除触发器 DROPTRIGGER库名.触发器名; ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:3:3","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"示例 ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:4:0","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"1. 记录数据的新增 DELIMITER$CREATETRIGGERtrigger_test_insertAFTERINSERTONt1FOREACHROWBEGInINSERTINTOt2VALUES(\"新增一行数据\",NEW.Id,now());END$ ","date":"2020-07-29","objectID":"/mysql-chu-fa-qi/:4:1","tags":["MySQL"],"title":"【MySQL】触发器","uri":"/mysql-chu-fa-qi/"},{"categories":["MySQL"],"content":"什么是索引 索引，就是帮助MySQL高效获取数据的数据结构。 ","date":"2020-07-27","objectID":"/mysql-index/:1:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引的优势和劣势 ","date":"2020-07-27","objectID":"/mysql-index/:2:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"1. 优势 可以提高数据的检索效率，降低数据库的IO成本。 可以降低数据排序的成本，降低CPU消耗。 ","date":"2020-07-27","objectID":"/mysql-index/:2:1","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"2. 劣势 索引也是一张表，存储了主键和索引字段，因此，索引也占用空间。 索引虽然提高了查询效率，但是降低了更新的速度。因为进行增、删、改时，不但需要更新数据，还需要更新索引。 索引不是所有情况均适用。如表中数据较少，字段频繁更新，字段很少使用，或者字段大量重复等，都不适合建立索引。 ","date":"2020-07-27","objectID":"/mysql-index/:2:2","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引结构 索引是在MySQL的存储引擎层实现的，目前支持的索引结构如下： BTree索引：是一类统称，包含B+树等数据结构。InnoDB、MyISAM、Memory都支持。 HASH索引：Memory支持。 R-tree索引：空间索引，MyISAM支持，主要用于地理空间数据类型。 Full-text索引：全文索引，MyISAM支持，InnoDB从MySQL5.6版本开始支持。 聚集索引、符合索引、前缀索引、唯一索引默认使用B+tree树结构组织的索引。 ","date":"2020-07-27","objectID":"/mysql-index/:3:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"B-树 B-树又叫多路平衡搜索树，一颗m叉B-树的性质如下： 每个结点最多有m个分支。 非叶子结点的根结点，至少有2个分支。非根非叶子结点，至少有ceil(m/2)个分支。 有n个分支的结点，具有n-1个关键字，这些关键字按递增或者递减顺序排列。 结点内的关键字互不相等。 叶子结点都处于同一层，可以用空指针表示。 B-树的阶数m，是人为规定的，不会因为结点关键字的最大个数变化而变化。 结点中的每个关键字，都对应着一个记录的存储地址。 ","date":"2020-07-27","objectID":"/mysql-index/:4:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"B+树 一颗m叉B+树，具备如下性质： 具有n个关键字的结点，含有n个分支。 每个结点最多有m个分支。 非根非叶子结点，至少有ceil(m/2)个关键字。非叶子结点的根结点，至少有2个关键字。 叶子结点包含了全部关键字，关键字按序排列。并且叶子结点引出的指针，指向了具体的记录。 所有非叶子结点中，存储着子树的最大关键字和指向该子树的指针，不存储关键字对应记录的存储地址。即非叶子结点仅仅发挥着索引作用。 有一个指针指向关键字最小的叶子结点，所有叶子结点组成一个线性链表。 ","date":"2020-07-27","objectID":"/mysql-index/:5:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引组织表 InnoDB中，表是根据主键的顺序，以索引形式存放，这种存储方式称为索引组织表。 每个索引在InnoDB中对应了一颗B+树，而每棵B+树的叶子结点是双向循环链表。 ","date":"2020-07-27","objectID":"/mysql-index/:6:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"使用B+树的好处 数据以数据块的形式存放在磁盘中，如果想从磁盘随机读取一个数据块，需要消耗较长的寻址时间。 如果使用二叉树，树高太高，意味着访问磁盘的次数变多，查询会很慢。 而N叉树可以减少磁盘访问次数。 ","date":"2020-07-27","objectID":"/mysql-index/:7:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引分类 单值索引 一个单值索引只包含单个列。单值索引不存在数量限制。 唯一索引 索引列的值必须唯一，但是允许存在多个NULL。 复合索引 一个f复合索引包含多个列。 ","date":"2020-07-27","objectID":"/mysql-index/:8:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引管理 ","date":"2020-07-27","objectID":"/mysql-index/:9:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"1. 索引创建 可以在创建表结构时创建索引，也可以建完表后再增加。 创建语法为： CREATE[UNIQUE|FULLTEXT|SPATIAL]INDEXindex_nameONtable_name(index_col_name...); index_col_name可以指定字段的长度，并指明字段的排序规则，格式如下： column_name[(length)][ASC|DESC] ","date":"2020-07-27","objectID":"/mysql-index/:9:1","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"2. 查看索引 SHOWINDEXFROM表名; ","date":"2020-07-27","objectID":"/mysql-index/:9:2","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"3. 删除索引 DROPINDEX索引名ON表名; ","date":"2020-07-27","objectID":"/mysql-index/:9:3","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"4. ALTER更新索引 创建主键索引： ALTERTABLEtable_nameADDPRIMARYKEY(column_list); 创建唯一索引 ALTERTABLEtable_naameADDUNIQUE[KEY|INDEX]index_name(column_list); 创建普通索引 ALTERTABLEtable_nameADDKEY|INDEXindex_name(column_list); 创建全文索引 ALTERTABLEtable_nameADDFULLTEXT[KEY|INDEX]index_name(column_list); ","date":"2020-07-27","objectID":"/mysql-index/:9:4","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"5. CREATE TABLE创建索引 在使用CREATE TABLE语句创建表时，添加下列语句即可建立索引。 创建主键索引 PRIMARYKEY(column_list) 创建普通索引 KEY|INDEX[index_name](column_list) 创建唯一索引 UNIQUE[INDEX|KEY][index_name](column_list) ","date":"2020-07-27","objectID":"/mysql-index/:9:5","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"主键索引 主键索引树的叶子节点存放的是整行数据。 如果无主键，使用第一个定义的非Null唯一索引，作为主键。如果该列不存在，则生成rowid作为主键。 在InnoDB里，主键索引也称为聚簇索引。 聚簇索引是指和整行数据存储在一起的索引，找到索引就可以找到整行数据。 非聚簇索引是指和数据分开存储的索引，找到索引之后，通常还得回表查询。 ","date":"2020-07-27","objectID":"/mysql-index/:10:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"非主键索引 索引树的叶子节点存的是主键值。 在InnoDB中，非主键索引也称为二级索引。 使用非主键索引进行查询时，通常还需要回表。即先搜索普通索引树，得到主键，再到主键树搜索。 ","date":"2020-07-27","objectID":"/mysql-index/:11:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引维护 在更新数据时，数据库会对索引进行必要维护： 插入一个新值，可能会导致旧值挪动位置。如果数据页满了，还会导致页分裂，页分裂会使空间利用率降低。 删除数据则可能会导致数据页合并。 自增主键的插入模式是追加插入，不会挪动其它记录。使用自增主键，还能降低非主键索引叶子节点占用的空间，因为数值型主键值占用内存更小。 ","date":"2020-07-27","objectID":"/mysql-index/:12:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"覆盖索引 覆盖索引是指，非主键索引已经覆盖了查询需求，不再需要回表。 使用覆盖索引可以减少树的搜索次数，提升查询性能。 但是如果通过联合索引来支持覆盖索引，会产生维护代价。 ","date":"2020-07-27","objectID":"/mysql-index/:13:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"最左前缀原则 定义索引(a, b, c)就相当于定义了索引(a), (a, b), (a, b, c)。 最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。 ","date":"2020-07-27","objectID":"/mysql-index/:14:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"联合索引建立原则 联合索引有如下建立原则： 通过调整索引顺序，尽量少的维护多余索引。 如果既要建立联合索引，也要建立一个单字索引，则尽量少的使用空间。 ","date":"2020-07-27","objectID":"/mysql-index/:14:1","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引下推 MySQL5.6之后，引入了索引下推优化。 在索引遍历过程中，可以对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。 ","date":"2020-07-27","objectID":"/mysql-index/:15:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"自增主键原理 自增主键是指将主键索引列定义为auto_increment，且主键索引是单值索引，类型为数值型。 申请到的自增值是不能保证连续性的，使用命令show create 表名\\G，输出结果AUTO_INCREMENT=后面的值，就是当前将会使用的自增值。 ","date":"2020-07-27","objectID":"/mysql-index/:16:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"自增值保存方式 表的结构定义存放在.frm文件中，该文件不保存自增值。 MyISAM的自增值，保存在数据文件中； MySQL5.7以及之前版本，自增值保存在内存中。重启之后，会从记录中读取自增值的最大值max(id)，并且将max(id)+1作为这个表的自增值； MySQL8.0之后，自增值的变更记录存在了redo log，重启时依靠redo log日志恢复重启之前的值。 ","date":"2020-07-27","objectID":"/mysql-index/:16:1","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"自增值修改机制 假设id字段被定义为auto_increment。 插入一行数据时的变化情况。 如果id字段为0、null或者未指定值，就将自增值填入这个字段； 如果指定了id字段值，就直接使用指定的值。 自增值变化原理。 如果插入id值小于自增值，则自增值不变； 如果插入id值大于等于自增值，就需要根据算法生成新的自增值。 ","date":"2020-07-27","objectID":"/mysql-index/:16:2","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"自增值生成算法 自增值受两个系统参数影响： auto_increment_offset：自增的初始值，默认1 auto_increment_increment：自增的步长，默认1 在双M的主备结构中，通常会将auto_increment_increment设置为2，让一个库的自增id是奇数，另一个库的自增id是偶数，避免两个库生成的主键冲突。 如果auto_increment_offset和auto_increment_increment都是1，则新的自增值就是准备插入的值 + 1。 否则，从auto_increment_offset开始，以auto_increment_increment为步长，持续累加，直到找到第一个大于插入值的值。 ","date":"2020-07-27","objectID":"/mysql-index/:16:3","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"自增值修改时机 存储引擎在接受插入命令之后，执行插入操作之前，会获取并更新自增值。 ","date":"2020-07-27","objectID":"/mysql-index/:16:4","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"自增主键ID不连续的情况 唯一键冲突会造成自增主键不连续。 事务回滚会造成自增主键不连续。 批量插入时，申请到的自增id会不连续。 注意：自增主键是不能回退的。 ","date":"2020-07-27","objectID":"/mysql-index/:16:5","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引设计原则 对于查询频率高、且数据量大的表，可以建立索引。 索引字段，应该选择最常用、过滤效果最好的组合。 尽量使用唯一索引，区分度越高，索引的效果越好。 不应该创建太多索引。索引越多，更新、插入、删除操作的效率越低。索引太多，MySQL生成执行计划时选项也会过多，代价太高。 尽量使用短索引。索引也是存储在磁盘中，如果索引长度较短，既能节约存储空间，也能提升访问索引的IO效率。 充分利用最左前缀原则。 如果某个数据列包含许多重复内容，建立索引则没有什么实际效果。索引的选择性是指索引列中不同值的数据与表中记录数的比。一个索引的选择性越接近1，这个索引的效率就越高。 ","date":"2020-07-27","objectID":"/mysql-index/:17:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["MySQL"],"content":"索引的使用 尽量使用复合索引，少使用单列索引。 如果建立了多个索引，数据库会选择一个最优的索引，不会使用全部索引。 尽量使用覆盖索引。 复合索引不要跨列或无序使用。 不要在索引上进行任何操作，如计算，函数操作，类型转换等，否则索引会失效。 like尽量以“常量”开头，不要以\"%“开头，否则索引会失效。 一般而言，范围查询之后的索引会失效。 尽量不要使用or，否则索引可能会失效。 ","date":"2020-07-27","objectID":"/mysql-index/:18:0","tags":["MySQL"],"title":"【MySQL】索引","uri":"/mysql-index/"},{"categories":["Linux"],"content":"在Linux系统中，可以使用date命令来显示和设定时间。 ","date":"2020-07-13","objectID":"/linux-date/:0:0","tags":["Linux"],"title":"【Linux】date命令详解","uri":"/linux-date/"},{"categories":["Linux"],"content":"命令格式 date [options] [+format] ","date":"2020-07-13","objectID":"/linux-date/:1:0","tags":["Linux"],"title":"【Linux】date命令详解","uri":"/linux-date/"},{"categories":["Linux"],"content":"options 常见的options如下： -d 打印给定的时间字符串（非系统时间），如： date -d \"00010101 00:00:01\" # 0001年 01月 01日 星期一 00:00:01 LMT -s 设置系统时间，如： date -s \"2001-01-01\" # 或者 date -s \"01:01:01\" # 或者 date -s \"2001-01-01 01:01:01\" -u 以UTC的格式打印当前时间。 --help 显示帮助信息。 --version 显示版本信息。 ","date":"2020-07-13","objectID":"/linux-date/:2:0","tags":["Linux"],"title":"【Linux】date命令详解","uri":"/linux-date/"},{"categories":["Linux"],"content":"format 使用format时，需要在前面加一个+号。 常见的format如下所示： %%：显示百分号% %n：换行 %t：打印制表符 %H：小时，00～23 %I：小时，01～12 %k：小时，0～23 %M：分钟，00～59 %p：显示AM或者PM %r：显示12小时制的时间 %s：显示秒级时间戳 %S：秒，00～61 %T：显示24小时制的时间 %X：相当于%H:%M:%S %Z：显示时区 %a：星期几，简写 %A：星期几，全称 %b：月份，简写 %B：月份，全称 %c：完整显示日期和时间 %C：显示世纪 %d：日，01～31 %D：完整显示日期 %j：一年中的第几天 %m：月份 %U：一年中的第几周，周日为第一天 %w：一周中的第几天，0～6 %W：一年中的第几周，周一为第一天 %x：完整显示日期 %y：年份的最后两位数字 %Y：完整年份 ","date":"2020-07-13","objectID":"/linux-date/:3:0","tags":["Linux"],"title":"【Linux】date命令详解","uri":"/linux-date/"},{"categories":["Linux"],"content":"在Linux环境中，查看目录或文件的磁盘空间大小是很常见的需求，使用du命令即可帮助我们达到该目的。 ","date":"2020-07-09","objectID":"/linux-du/:0:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"命令格式 du [选项] [文件或者目录] ","date":"2020-07-09","objectID":"/linux-du/:1:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"选项 常用的可选参数为： -a: --all，列出所有文件和目录的容量大小（默认只列出目录容量的大小）。 -h: 以已读的形式显示。 -B：--block-size=SIZE，指定容量的单位值，size可以是1，k，或者m，如-B1。 -k：--block-size=1k，以KB为单位。 -m：--block-size=1m，以MB为单位。 -c：--total，额外显示总的容量大小。 -s：仅显示总量大小。 --max-depth：显示指定层级的目录。 --exclude=\u003c文件或目录\u003e：忽略指定目录或文件。 ","date":"2020-07-09","objectID":"/linux-du/:2:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"示例 显示当前目录及子目录大小 du 显示指定文件所占空间 du filename 仅显示当前目录所占空间大小 du --max-depth=1 仅显示当前目录总的容量大小 # 使用 -s du -sh # 使用--max-depth du -h --max-depth=0 ","date":"2020-07-09","objectID":"/linux-du/:3:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["Linux"],"content":"du和ls -l 除了可以使用du查看目录或文件大小外，还可以使用ls -l查看文件或目录的大小，但是二者获得的结果有所差异。 ls -l的结果小于du的结果 du是文件占用block的大小，在linux中，一个block的大小为4k。而ls -l是文件的实际大小，所以即使文件只有1bytes，du获得的结果也会是4k。 ls -l的结果大于du的结果 当文件出现空洞的时候会出现这种结果，即磁盘空间被占用，但是里面没有数据。 ","date":"2020-07-09","objectID":"/linux-du/:4:0","tags":["Linux"],"title":"【Linux】du命令详解","uri":"/linux-du/"},{"categories":["MySQL"],"content":"什么是视图 视图是一种虚拟表，不在数据库中实际存在。 视图行和列的数据，是在使用视图时动态生成的。 ","date":"2020-07-08","objectID":"/mysql-views/:1:0","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"视图操作 ","date":"2020-07-08","objectID":"/mysql-views/:2:0","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"1. 创建视图 CREATEview视图名称AS查询语句; ","date":"2020-07-08","objectID":"/mysql-views/:2:1","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"2. 修改视图 ALTERview视图名AS查询语句; 或者： CREATEORREPLACEview视图名AS查询语句; ","date":"2020-07-08","objectID":"/mysql-views/:2:2","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"3. 查看视图列表 使用SHOW TABLES不仅可以看到数据表，还可以看到被定义的视图。 ","date":"2020-07-08","objectID":"/mysql-views/:2:3","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"4. 查看视图结构 DESC视图名; 或者： SHOWCREATEview视图名; ","date":"2020-07-08","objectID":"/mysql-views/:2:4","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"4. 删除视图 DROPview视图名...; ","date":"2020-07-08","objectID":"/mysql-views/:2:5","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"视图内容的更新 ","date":"2020-07-08","objectID":"/mysql-views/:3:0","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"1. 插入 同表的插入语法一致。 会更新原始表。 ","date":"2020-07-08","objectID":"/mysql-views/:3:1","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"2. 修改 同表的修改语法一致。 会更新原始表。 ","date":"2020-07-08","objectID":"/mysql-views/:3:2","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"3. 删除 使用表的delete语法。 会更新原始表。 ","date":"2020-07-08","objectID":"/mysql-views/:3:3","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"4. 说明 视图的可更新性和视图查询的定义有关系，以下类型的视图不能更新： 包含关键字：分组函数、distinct、group by、having、union、union all。 常量视图。 select子句中包含子查询。 join（某些条件下可更新）。 from一个不能更新的视图。 where子句的子查询引用了from子句中的表。 ","date":"2020-07-08","objectID":"/mysql-views/:3:4","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"使用示例 查询邮箱中包含a字符的员工名、部门名和工种信息： 创建视图： CREATEviewtest_v1ASSELECTname,department,titleFROMemployeeseJOINdepartmentsdONe.department_id=d.department_idJOINjobsjONj.job_id=e.job_id; 使用视图： SELECT*FROMtest_v1WHEREnameLIKE\"%a%\"; 查询各部门的平均工资级别： 创建视图： CREATEviewtest_v2ASSELECTAVG(salary)ag,department_idFROMemployeesGROUPBYdepartment_id; 使用： SELECT*FROMtest_v2; ","date":"2020-07-08","objectID":"/mysql-views/:4:0","tags":["MySQL"],"title":"【MySQL】视图","uri":"/mysql-views/"},{"categories":["MySQL"],"content":"结构分类 流程控制的结构，可分为如下几类： 顺序结构：程序从上往下依次执行。 分支结构：从多条路径中选择一条去执行。 循环结构：在满足一定条件的基础上，重复执行一段代码。 ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:1:0","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"顺序结构 SQL语句默认就是从上往下依次执行。 ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:2:0","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"分支结构 分支结构主要有以下几种语法： IF函数 CASE结构 IF结构 ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:3:0","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"1. IF函数 IF(表达式1，表达式2，表达式3) 如果表达式1成立，则IF函数返回表达式2的值，否则返回表达式3的值。 ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:3:1","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"2. CASE结构 CASE变量|表达式|字段WHEN要判断的值THEN返回的值1或语句;WHEN要判断的值THEN返回的值2或语句;...ELSE返回的值或语句;ENDCASE; 或者 CASEWHEN要判断的条件1THEN返回的值1或语句;WHEN要判断的条件2THEN返回的值2或语句;...ELSE要返回的值;ENDCASE; 以上两种写法主要用于BEGIN/END语句块中。其他情况下，可以使用如下语句： CASE变量|表达式|字段WHEN要判断的值THEN返回的值1或语句WHEN要判断的值THEN返回的值2或语句...ELSE返回的值或语句END 或者： CASEWHEN要判断的条件1THEN返回的值1或语句WHEN要判断的条件2THEN返回的值2或语句...ELSE要返回的值END ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:3:2","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"3. IF结构 IF条件1THEN语句1;ELSEIF条件2THEN语句2;...ELSE语句n;ENDIF; IF结构主要应用于BEGIN/END语句块中。 ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:3:3","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"4. 示例 CASE结构 DELIMITER$CREATEPROCEDUREtest_case(INscoreint)BEGINCASEWHENscore\u003e=90ANDscore\u003c=100THENSELECT'A';WHENscore\u003e=80THENSELECT'B';WHENscore\u003e=60THENSELECT'C';ELSESELECT'D';ENDCASE;END$ IF结构 DELIMITER$CREATEFUNCTIONtest_if(scoreINT)RETURNSCHARBEGINIFscore\u003e=90ANDscore\u003c=100THENRETURN'A';ELSEIFscore\u003e=80THENRETURN'B';ELSERETURN'D';ENDIF;END$ ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:3:4","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"循环结构 循环结构主要有以下几种语法： WHILE LOOP REPEAT 控制循环流程的语法如下： ITERATE：类似于continue。 LEAVE：类似于break。 ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:4:0","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"1. 循环结构语法 [标签:]WHILE循环条件DO循环体;ENDWHILE[标签]; [标签:]LOOP循环体;ENDLOOP[标签]; [标签:]REPEAT循环体;UNTIL结束循环的条件ENDREPEAT[标签]; 注意LOOP需要搭配标签使用，否则会变成死循环。 标签主要用于搭配iterate和leave跳出循环。 ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:4:1","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"2. 示例 WHILE DELIMITER$CREATEPROCEDUREtest_while(nint)BEGINdeclaresumintdefault0;WHILEn\u003e0DOSETsum=sum+n;SETn=n-1;ENDWHILE;SELECTsumASresult;END$ REPEAT DEMILITER$CREATEPROCEDUREtest_repeat(nint)BEGINdeclaresumintdefault0;REPEATSETsum=sum+n;SETn=n-1;UNTILn=0ENDREPEAT;SELECTsumASresult;END$ LOOP DEMILITER$CREATEPROCEDUREtest_loop(nint)BEGINdeclaresumintdefault0;L:LOOPSETsum=sum+n;SETn=n-1;IFn=0THENleaveL;ENDIF;ENDLOOPL;SELECTsum;END$ ","date":"2020-06-29","objectID":"/mysql-liu-cheng-kong-zhi/:4:2","tags":["MySQL"],"title":"【MySQL】流程控制","uri":"/mysql-liu-cheng-kong-zhi/"},{"categories":["MySQL"],"content":"什么是存储过程 存储过程，是经过编译并存储在数据库中的一段SQL语句集合。 存储过程和函数的区别，在于存储过程无返回值，而函数有返回值。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:1:0","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"存储过程的好处 提高了代码的重用性。 减少了SQL语句的编译次数，提高了效率。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:2:0","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"存储过程的语法 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:3:0","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"1. 创建 CREATEPROCEDURE过程名(参数列表)BEGIN存储过程体END 说明： 参数列表包含三部分：参数模式、参数名、参数类型 参数模式有三种：IN输入，OUT输出，INOUT输入和输出。 如果存储过程体只有一句话，BEGIN和END可以省略。 存储过程体中，每句SQL语句以分号表示结束。 在存储过程的结尾END处，需要使用DELIMITER设置的结束标记。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:3:1","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"2. 调用 CALL存储过程名(实参列表); ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:3:2","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"3. 删除 DROPPROCEDURE[IFEXISTS]过程名; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:3:3","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"4. 查看存储过程 SHOWCREATEPROCEDURE过程名; 或者： SHOWPROCEDURESTATUS; 还可以从mysql.proc中获取存储过程的信息，但是有的版本不支持该方法。 SELECT*FROMmysql.proc; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:3:4","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"5. 修改 存储过程无法修改。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:3:5","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"示例 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:4:0","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"1. 无参 定义： DELIMITER$CREATEPROCEDUREtest_pro1()BEGININSERTINTOadmin(username,password)VALUES('a','1234'),('b','1234');END$ 调用： CALLtest_pro1()$ ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:4:1","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"2. IN 定义： DELIMITER$CREATEPROCEDUREtest_pro2(INusernameVARCHAR(20),INpasswordVARCHAR(20))BEGINDECLAREresultINTDEFAULT0;SELECTCOUNT(*)INTOresultFROMadminWHEREadmin.username=usernameANDadmin.password=password;SELECTIF(result\u003e0,'成功','失败');END$ 调用： CALLtest_pro2('abc','1234')$ ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:4:2","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"3. OUT 定义： DELIMITER$CREATEPROCEDUREtest_pro3(INaint,INbint)BEGINSETb=a*2;END$ 调用： CALLtest_pro3(10,@res)$SELECT@res$ ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:4:3","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"5. INOUT 定义： DELIMITER$CREATEPROCEDUREtest_pro4(INOUTaINT)BEGINSETa=a*2END$ 调用： SET@m=10$CALLtest_pro4(@m)$ ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:4:4","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"什么是函数 函数和存储过程类似，都是经过编译并存储在数据库中的一段SQL语句集合。但是函数有且仅有一个返回值，而存储过程没有返回值。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:5:0","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"函数的语法 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:6:0","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"1. 创建函数 CREATEFUNCTION函数名(参数列表)RETURNS返回类型BEGIN函数体END 说明： 参数列表包含两部分：参数名和参数类型。 函数体中必须包含RETURN。 如果函数体仅有一句话，可以省略BEGIN和END。 使用DELIMITER语句设置函数结束标记。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:6:1","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"2. 调用 SELECT函数名（参数列表） ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:6:2","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"3. 查看函数 SHOWCREATEFUNCTION函数名; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:6:3","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"4. 删除函数 DROPFUNCTION函数名; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:6:4","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"5. 示例 无参有返回 定义： DELIMITER$CREATEFUNCTIONtest_func1()RETURNSintBEGINDECLAREaintDEFAULT10;RETURNa;END$ 调用： SELECTtest_func1()$ 有参有返回 定义： DELIMITER$CREATEFUNCTIONtest_func2(aint)RETURNSintBEGINSETa=a*2;RETURNa;END$ 调用： SELECTtest_func2(10)$ ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:6:5","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"游标 游标用于存储查询的结果集，主要应用于存储过程和函数。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:7:0","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"1. 声明 DECLAREcursor_nameCURSORFOR查询语句; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:7:1","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"2. OPEN OPENcursor_name; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:7:2","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"3. FETCH FETCHcursor_nameINTO变量...; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:7:3","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"4. CLOSE CLOSEcursor_name; ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:7:4","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"5. DECLARE EXIT HANDLER FOR NOT FOUND 在存储过程中，当游标配合循环语句一起使用时，需要知道循环何时结束，此时就需要使用如下机制： DECLAREEXIT|COUTINUEHANDLERFORNOTFOUND语句; 该语句的含义是，当游标无法获取下一条数据时，就执行FOR NOT FOUND后面的语句。 ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:7:5","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"6. 示例 DELIMITER$CREATEPROCEDUREtest_cursor()BEGINDECLAREaint(11);DECLAREbint(11);DECLAREcvarchar(10);DECLAREoverintdefault0;DECLAREcursor_tCURSORFORselect*fromt1;DECLAREEXITHANDLERFORNOTFOUNDSETover=1;OPENcursor_t;WHILEover=0DOFETCHcursor_tINTOa,b,c;SELECTa,b,c;ENDWHILE;CLOSEcursor_t;END$ ","date":"2020-06-28","objectID":"/mysql-cun-chu-guo-cheng-han-shu/:7:6","tags":["MySQL"],"title":"【MySQL】存储过程和函数","uri":"/mysql-cun-chu-guo-cheng-han-shu/"},{"categories":["MySQL"],"content":"变量分类 变量分为系统变量和自定义变量。 系统变量： 全局变量 会话变量 自定义变量： 用户变量 局部变量 ","date":"2020-06-25","objectID":"/mysql-bian-liang/:1:0","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"系统变量 ","date":"2020-06-25","objectID":"/mysql-bian-liang/:2:0","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"1. 什么是系统变量 系统变量是由系统提供的，属于服务器层面。 ","date":"2020-06-25","objectID":"/mysql-bian-liang/:2:1","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"2. 语法 查看所有的系统变量 SHOWGLOBAL|[SESSION]variables; 查看满足条件的部分系统变量 SHOWGLOBAL|[SESSION]variableslike'%char%'; 查看指定的某个系统变量的值 SELECT@@GLOBAL.|[SESSION.]系统变量名; 为某个系统变量赋值 SETGLOBAL|[SESSION]系统变量名=值; 或者 SET@@GLOBAL.|[SESSION.]系统变量名=值; ","date":"2020-06-25","objectID":"/mysql-bian-liang/:2:2","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"3. 注意 如果是全局级别，需要使用global。 如果是会话级别，需要加session或者什么都不加。 全局变量被修改后，服务器重启变量值会恢复默认。 ","date":"2020-06-25","objectID":"/mysql-bian-liang/:2:3","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"自定义变量 ","date":"2020-06-25","objectID":"/mysql-bian-liang/:3:0","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"1. 什么是自定义变量 自定义变量由用户自定义，不由系统提供。 ","date":"2020-06-25","objectID":"/mysql-bian-liang/:3:1","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"2. 用户变量 作用域： 当前会话（连接）有效。 声明并初始化： SET @变量名=值; 或者： SET @变量名:=值; 或者： SELECT @变量名:=值; 或者： SELECT 字段 INTO @变量名 FROM 表; 赋值： SET@变量名=值;SET@变量名:=值;SELECT@变量名:=值;SELECT字段INTO@变量名FROM表; 使用 SELECT@变量名; ","date":"2020-06-25","objectID":"/mysql-bian-liang/:3:2","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"3. 局部变量 作用域： 仅仅在定义它的BEGIN ... END语句块中有效。 BEGIN...END主要在函数和存储过程中使用。 声明： DECLARE变量名类型; 或者 DECLARE变量名类型DEFAULT值; 赋值： SET变量名=值;SET变量名:=值; 或者 SELECT字段INTO变量名FROM表; 使用： SELECT变量名; ","date":"2020-06-25","objectID":"/mysql-bian-liang/:3:3","tags":["MySQL"],"title":"【MySQL】变量","uri":"/mysql-bian-liang/"},{"categories":["MySQL"],"content":"DQL解释 DQL：数据查询语言(Data Query Language)，用来查询记录。 ","date":"2020-06-22","objectID":"/mysql-dql/:1:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"查询语法 查询语句的基本语法如下： SELECT查询列表FROM表名; 常见的查询列表内容如下： 字段 SELECTidFROMtest; 表达式 SELECT100%3; 常量 SELECT100; 函数 SELECTDATABASE();SELECTVERSION();SELECTUSER(); ","date":"2020-06-22","objectID":"/mysql-dql/:2:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"查询说明 ","date":"2020-06-22","objectID":"/mysql-dql/:3:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 别名 可以对查询的结果起别名，或者对被查询的表起别名。 使用as关键字 SELECTUSER()AS\"username\"; 使用空格 SELECTuser()username; ","date":"2020-06-22","objectID":"/mysql-dql/:3:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. +号 在MySQL中，使用+号时需注意如下规则： 如果两个数都是数值型，则直接相加。 如果其中一个操作数为字符型，则将字符型转换成数值型。如果无法转换，则当作0处理。 其中一个操作数为null，结果为null。 ","date":"2020-06-22","objectID":"/mysql-dql/:3:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. DISTINCT去重 DISINCT子句可以消除重复字段。语法如下： SELECTDISTINCTfieldFROMtablename ","date":"2020-06-22","objectID":"/mysql-dql/:3:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"4. IFNULL函数 语法： IFNULL(表达式1,表达式2) 功能： 如果表达式1为null，则显示表达式2，否则显示表达式1。 ","date":"2020-06-22","objectID":"/mysql-dql/:3:4","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"5. 正则表达式 SQL语句可以使用正则表达式进行查询： SELECT*FROM表名WHERE字段REGEXP正则表达式; ","date":"2020-06-22","objectID":"/mysql-dql/:3:5","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"常见函数 常见函数有如下几类： 字符函数 数学函数 日期函数 流程控制函数 聚合函数 ","date":"2020-06-22","objectID":"/mysql-dql/:4:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 字符函数 CONCAT拼接字符 SELECTCONCAT(\"hello\",name)FROMuser; LENGTH获取字节长度 SELECTLENGTH(\"hello,少年\"); CHAR_LENGTH获取字符长度 SELECTCHAR_LENGTH(\"hello,少年\"); SUBSTR截取子串 SUBSTR(string,start,end) 截取从start到end（包含end）的所有字符，字符串从1开始计数。 start可以为负数，表示从最后一个字符开始往前数。 end可以省略，表示一直到结尾。 LEFT从左边截取字符 SELECTLEFT('洪世贤',1); RIGHT从右边截取字符 SELECTRIGHT('少奶奶',2); INSTR获取字符第一次出现的索引 SELECTINSTR('孙悟空三打白骨精','白骨精'); TRIM去除前后指定字符，默认去空格 TRIM的语法为： TRIM([BOTH|LEADING|TRAILING][removed][FROM]str) BOTH表示删除首尾字符，LEADING表示删除前导字符，TRAILING表示删除尾随字符。 BOTH、LEADING和TRAILING都可以省略，省略后默认使用BOTH。 removed是被删除的字符，可以省略，省略时默认删除空格。 FROM可以省略，但是如果BOTH | LEADING | TRAILING存在，或者removed存在，则FROM不可省略。 使用示例： SELECTTRIM(' 空 格 ')asresult; SELECTTRIM('x'FROM'xxx空xxx格xxx')asresult; LPAD左填充 左填充满10个字符： SELECTLPAD('木婉清',10,'a'); RPAD右填充 右填充满10个字符： SELECTRPAD('木婉清',10,'a'); UPPER字符转大写 LOWER字符转小写 STRCMP比较两个字符串的字符大小 SELECTSTRCMP('abc','acb') ","date":"2020-06-22","objectID":"/mysql-dql/:4:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. 数学函数 ABS绝对值 SELECTABS(-1.1); CEIL向上取整，返回大于等于该参数的最小整数 SELECTCEIL(1.09); FLOOR向下取整，返回小于等于该参数的最大整数 SELECTFLOOR(-1.09); ROUND四舍五入 SELECTROUND(1.8765); TRUNCATE截断小数位 SELECTTRUNCATE(1.8765,1);#1.8 MOD取余 实质上：a % b = a - a/b*b。 SELECTMOD(-10,3);#-1 SELECTMOD(10,3);#1 SELECTMOD(-10,-3);#-1 SELECTMOD(10,-3);#1 ","date":"2020-06-22","objectID":"/mysql-dql/:4:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"4. 日期函数 NOW获取当前日期和时间 SELECTNOW(); CURDATE/CURRENT_DATE获取当前日期 SELECTCURDATE(); CURTIME/CURRENT_TIME获取当前时间 SELECTCURTIME(); DATEDIFF比较两个日期相差几天 SELECTDATEDIFF('1998-7-16','2019-7-13'); SELECTDATEDIFF('19980716','20190713'); TIMESTAMPDIFF比较两个日期时间的差距 语法： TIMESTAMPDIFF(时间类型,时间1,时间2) 时间类型可以是天day、小时hour、分钟minute、秒second等。 示例： SELECTTIMESTAMPDIFF(second,\"1999-01-01 18:00:00\",\"1999-01-01 19:00:00\"); YEAR从给定时间中获取年份 SELECTYEAR(\"2001-1-12\"); MONTH从给定时间中获取月份 SELECTMONTH(\"2001-01-12\"); DAY从给定时间中获取日数 SELECTDAY(\"2001-1-12\"); HOUR从给定时间中获取小时数 SELECTHOUR(\"2001-1-12 15:04:05\") MINUTE从给定时间中获取分钟数 SELECTMINUTE(\"2001-1-12 15:04:05\") SECOND从给定时间中获取秒钟数 SELECTSECOND(\"2001-1-12 15:04:05\") DATE_FORMAT SELECTDATE_FORMAT('1998-7-16','%Y年%m月%d日 %H小时%i分钟%s秒'); STR_TO_DATE SELECTSTR_TO_DATE('3/15 1998','%m/%d %Y'); ","date":"2020-06-22","objectID":"/mysql-dql/:4:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"5. 流程控制函数 IF函数 SELECTIF(100\u003e9,\"好\",\"坏\"); ","date":"2020-06-22","objectID":"/mysql-dql/:4:4","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"6. 聚合函数 聚合函数用于对一组数据进行统计分析，并得到一个值。 sum(字段名)：求和。 avg(字段名)：求平均数。 max(字段名)：求最大值。 min(字段名)：求最小值。 count(字段名)：计算非空字段值的个数。 count(*)用于查询总行数。 count(1)作用类似于count(*)，但是效率较低。 count()搭配distinct做去重统计，如： SELECTcount(distinctdepartment)FROMemployees; ","date":"2020-06-22","objectID":"/mysql-dql/:4:5","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"其他查询命令 除了常见的函数外，还有一些偶尔会用到的查询命令。 查询版本 SELECTVERSION(); 查询当前数据库 SELECTDATABASE(); 查询当前用户 SELECTUSER(); 查看警告信息 SHOWWARNINGS; ","date":"2020-06-22","objectID":"/mysql-dql/:5:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"条件查询 ","date":"2020-06-22","objectID":"/mysql-dql/:6:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 语法 SELECT查询列表FROM表名WHERE筛选条件； ","date":"2020-06-22","objectID":"/mysql-dql/:6:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 筛选条件 按关系表达式筛选：\u003c、\u003e、\u003e=、\u003c=、=、\u003c\u003e、!=。 按逻辑表达式筛选：and、or、not，也可以使用 \u0026\u0026、||、!。 模糊查询：like、in、not in、is null、is not null、between ... and ...、not between ... and ... 。 ","date":"2020-06-22","objectID":"/mysql-dql/:6:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. 示例 查询部门编号不是 50 ~ 100 之间员工的姓名: SELECTnameFROMemployeesWHEREdepartment_id\u003c50ordepartment_id\u003e100; 查询姓名中包含字符a的员工。 SELECT*FROMemployeesWHEREnameLIKE'%a%'; 查询姓名最后一个字符为a的员工。 SELECT*FROMemployeesWHEREnameLIKE'%a'; 查询姓名第一个字符为a的员工。 SELECT*FROMemployeesWHEREnameLIKE'a%'; 查询姓名中第三个字符为a的员工。 SELECT*FROMemployeesWHEREnameLIKE'___a%';#有三个下划线_ 查询姓名中第二个字符为_的员工信息。 SELECT*FROMemployeesWHEREnameLIKE'_\\_%'; 或者： SELECT*FROMemployeesWHEREnameLIKE'_$_%'escape'$'; 查询部门编号是30/50/90的员工名 SELECTnameFROMemployeesWHEREdepartmentIN(30,50,90); 查询部门编号是30～90之间的员工姓名 SELECTnameFROMemployeesWHEREdepartmentBETWEEN30AND90; 查询部门编号不是30～90之间的员工姓名 SELECTnameFROMemployeesWHEREdepartmentNOTBETWEEN30AND90; ","date":"2020-06-22","objectID":"/mysql-dql/:6:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"排序查询 ","date":"2020-06-22","objectID":"/mysql-dql/:7:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 语法 SELECT查询列表FROM表名WHERE筛选条件ORDERBY排序列表; ","date":"2020-06-22","objectID":"/mysql-dql/:7:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 说明 排序列表可以是单个字段、多个字段、表达式、函数、字符序号、以及以上的组合。 升序使用关键字asc，降序使用关键字desc。如果省略关键字，则默认升序。 ","date":"2020-06-22","objectID":"/mysql-dql/:7:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. 示例 将员工按照工资降序 SELECT*FROMemployeesORDERBYsalaryDESC; 按姓名长度进行升序 SELECTnameFROMemployeesORDERBYlength(name); 查询员工信息，先按工资升序、再按部门将序 SELECT*FROMemployeesORDERBYsalaryASC,departmentDESC; 按照第2列降序排列 SELECT*FROMemployeesORDERBY2DESC; ","date":"2020-06-22","objectID":"/mysql-dql/:7:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"分组查询 需要使用group by子句。 ","date":"2020-06-22","objectID":"/mysql-dql/:8:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 语法 SELECT查询列表FROM表名WHERE筛选条件GROUPBY分组列表HAVING分组后筛选ORDERBY排序列表; ","date":"2020-06-22","objectID":"/mysql-dql/:8:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 说明 查询列表往往是聚合函数和被分组的字段。 分组前的筛选，是基于原始表，使用where，位于group by前面。 分组后的筛选，是基于分组后的结果集，使用having，位于group by后面。 ","date":"2020-06-22","objectID":"/mysql-dql/:8:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. 示例 查询每个工种员工平均工资 SELECTavg(salary),job_idFROMemployeesGROUPBYjob_id; ","date":"2020-06-22","objectID":"/mysql-dql/:8:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"分页查询 ","date":"2020-06-22","objectID":"/mysql-dql/:9:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 语法 SELECT查询列表FROM表WHERE筛选条件GROUPBY分组HAVING分组后筛选ORDERBY排序列表LIMIT起始条目索引，条目数; ","date":"2020-06-22","objectID":"/mysql-dql/:9:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 说明 起始条目索引从0开始，缺省则默认为0。 ","date":"2020-06-22","objectID":"/mysql-dql/:9:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. 示例 查询员工信息表的前5条 SEELCT*FROMemployeesLIMIT5; 等价于： SELECT*FROMemployeesLIMIT0,5; ","date":"2020-06-22","objectID":"/mysql-dql/:9:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"子查询 ","date":"2020-06-22","objectID":"/mysql-dql/:10:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 定义 在一个查询语句中，又嵌套了另一个select语句，则被嵌套的语句称为子查询或内查询，外面的语句称为主查询或外查询。 ","date":"2020-06-22","objectID":"/mysql-dql/:10:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 说明 子查询一般放在小括号中。 单行子查询对应了单行操作符：\u003e, \u003c, \u003e=, \u003c=, =, \u003c\u003e, !=。 多行子查询对应了多行操作符：any, some, all, in。 select后面子查询的结果必须单行单列，from后面子查询的结果可以多行多列。 ","date":"2020-06-22","objectID":"/mysql-dql/:10:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. any, some, all any, some, all是用于将子查询返回的单列结果与指定值做比较，使用时，需要在前面加\u003e, \u003c, \u003e=, \u003c=, \u003c\u003e, !=中的某个操作符。 some的含义是，指定值大于、小于、大于等于、小于等于、不等于单列结果集的所有值。 any, some的含义是，指定值大于、小于、大于等于、小于等于、不等于单列结果集的某个值。 ","date":"2020-06-22","objectID":"/mysql-dql/:10:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"4. 示例 查询和Tom同部门的员工姓名和工资 SELECTname,salaryFROMemployeesWHEREdepartment_id=(SELECTdepartment_idFROMemployeesWHEREname='Tome'); 查询部门编号是50的员工个数 SELECT(SELECTCOUNT(*)FROMemployeesWHEREdepartment_id=50)个数; 查询有无名字叫\"TOM\"的员工信息 SELECTEXISTS(SELECT*FROMemployeesWHEREname=\"TOM\")有无; ","date":"2020-06-22","objectID":"/mysql-dql/:10:4","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"连接查询 ","date":"2020-06-22","objectID":"/mysql-dql/:11:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 说明 又称多表查询，当查询的字段来自于多个表时，就会用到连接查询。 ","date":"2020-06-22","objectID":"/mysql-dql/:11:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. sql连接查询分类 按年代分类： sql92标准：mysql仅仅支持内连接。 sql99标准：mysql支持内连接+外连接（左外和右外）+交叉连接。 按功能分类： 内连接：等值连接、非等值连接、自连接 外连接：左外连接、右外连接、全外连接（MySQL不支持） 交叉连接 ","date":"2020-06-22","objectID":"/mysql-dql/:11:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"sql92内连接 ","date":"2020-06-22","objectID":"/mysql-dql/:12:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 语法 SELECT查询列表FROM表名1别名1,表名2别名2...WHERE连接条件 ","date":"2020-06-22","objectID":"/mysql-dql/:12:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 说明 为了解决多表字段重名，可以为表起别名。 表的顺序无要求。 n表连接，至少需要n-1个连接条件。 ","date":"2020-06-22","objectID":"/mysql-dql/:12:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. 示例 等值连接：查询部门编号\u003e100的部门名和所在的城市名。 SELECTd.department_name,l.cityFROMdepartmentsd,locationslWHEREd.location_id=l.location_idANDd.department_id\u003e100; 非等值连接：查询员工的工资和工资级别。 SELECTe.salary,g.grade_levelFROMemployeese,job_gradesgWHEREe.salaryBETWEENg.lowest_salANDg.highest_sal; 自连接：查询员工名和上级的名称。 SELECTe.employee_id,e.last_name,m.employee_id,m.last_nameFROMemployeese,employeesmWHEREe.manager_id=m.employee_id; ","date":"2020-06-22","objectID":"/mysql-dql/:12:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"sql99内连接 ","date":"2020-06-22","objectID":"/mysql-dql/:13:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 语法 SELECT查询列表FROM表明1别名[INNER]JOIN表明2别名ON连接条件WHERE筛选条件GROUPBY分组列表HAVING分组后筛选ORDERBY排序列表; ","date":"2020-06-22","objectID":"/mysql-dql/:13:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 说明 使用关键字JOIN代替了逗号，连接条件和筛选条件进行了分离。 ","date":"2020-06-22","objectID":"/mysql-dql/:13:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. straight_join straight_join与内连接类似，不同的地方在于，straight_join会强制使用左边的表作为驱动表，使用右边的表作为被驱动的表。 上述特性，在某些特定情况下可用于调优。 ","date":"2020-06-22","objectID":"/mysql-dql/:13:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"4. 示例 查询员工名和部门名 SELECTe.last_name,d.department_nameFROMemployeeseJOINdepartmentsdONe.department_id=d.department_id; 查询部门编号\u003e100的部门名和所在的城市名 SELECTd.department_name,e.cityFROMdepartmentsdJOINlocationslONd.location_id=l.location_idWHEREd.department_id\u003e100; 查询部门中员工个数\u003c10的部门名，并按照员工个数降序 SELECTCOUNT(*)员工个数,d.department_nameFROMemployeeseJOINdepartmentsdONe.department_id=d.department_idGROUPBYd.department_idHAVING员工个数\u003c10ORDERBY员工个数DESC; 查询员工名和对应的领导名 SELECTe.name,m.nameFROMemployeeseJOINemployeesmONe.manager_id=m.employee_id; ","date":"2020-06-22","objectID":"/mysql-dql/:13:4","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"sql99外连接 ","date":"2020-06-22","objectID":"/mysql-dql/:14:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 说明 查询结果为主表中所有的记录，如果从表有匹配项，则显示匹配项；如果从表没有匹配项，则显示null。 外连接主从表的顺序不可随意改变。 左连接的主表在左边，右连接的主表在右边。 MySQL不支持全外连接。 ","date":"2020-06-22","objectID":"/mysql-dql/:14:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 语法 SELECT查询列表FROM表1别名LEFT|RIGHT|FULL[OUTER]JOIN表2别名ON连接条件WHERE筛选条件; ","date":"2020-06-22","objectID":"/mysql-dql/:14:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"sql99交叉连接 交叉连接用于返回多个表的笛卡尔积。 ","date":"2020-06-22","objectID":"/mysql-dql/:15:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 语法 SELECT查询列表FROM表1别名1CROSSJOIN表2别名2WHERE筛选条件; 或者 SELECT查询列表FROM表1别名,表2别名,...WHERE筛选条件; ","date":"2020-06-22","objectID":"/mysql-dql/:15:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"联合查询 ","date":"2020-06-22","objectID":"/mysql-dql/:16:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"1. 说明 当查询结果来自于多张表，但多张表之间没有关联，这时可用联合查询，也称union查询。 union自动去重 union all可以支持重复项 多条待联合的查询语句，查询列数必须一致，类型、字段最好一致 ","date":"2020-06-22","objectID":"/mysql-dql/:16:1","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"2. 语法 SELECT查询列表FROM表1WHERE筛选条件UNIONSELECT查询列表FROM表2WHERE筛选条件 ","date":"2020-06-22","objectID":"/mysql-dql/:16:2","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"3. 示例 查询所有国家的年龄\u003e20的用户信息 SELECT*FROMchineseWHEREage\u003e20UNIONSELECT*FROMusaWHEREuage\u003e20; 查询所有国家的用户姓名和年龄 SELECTuname,uageFROMusaUNIONSELECTname,ageFROMchinese; ","date":"2020-06-22","objectID":"/mysql-dql/:16:3","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"MySQL语句处理顺序 MySQL完整的查询语句如下： SELECTDISTINCT字段FROMtable1[LEFT|RIGHT|INNER]JOINtable2ON连接条件WHERE筛选条件GROUPBY分组字段HAVING过滤条件ORDERBY排序字段LIMIT偏移量; 执行顺序如下： FROM\u003cleft_table\u003eON\u003cjoin_condition\u003e\u003cjoin_type\u003eJOIN\u003cright_table\u003eWHERE\u003cwhere_condition\u003eGROUPBY\u003cgroup_by_list\u003eHAVING\u003chaving_condition\u003eSELECTDISTINCT\u003cselect_list\u003eORDERBY\u003corder_by_condition\u003eLIMIT\u003climit_number\u003e ","date":"2020-06-22","objectID":"/mysql-dql/:17:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"JOIN语句汇总 INNER JOIN SELECT\u003cselect_list\u003eFROMtableAINNERJOINtableBONA.key=b.key; LEFT JOIN SELECT\u003cselect_list\u003eFROMtableALEFTJOINtableBONA.key=B.key; RIGHT JOIN SELECT\u003cselect_list\u003eFROMtableARIGHTJOINtableBONA.key=B.key; LEFT JOIN SELECT\u003cselect_list\u003eFROMtableALEFTJOINtableBONA.key=B.keyWHEREB.keyISNULL; RIGHT JOIN SELECT\u003cselect_list\u003eFROMtableARIGHTJOINtableBONA.key=B.keyWHEREA.keyISNULL; FULL OUTER JOIN SELECT\u003cselect_list\u003eFROMtableAFULLOUTERJOINtableBONA.key=B.key; FULL OUTER JOIN SELECT\u003cselect_list\u003eFROMtableAFULLOUTERJOINtableBONA.key=B.keyWHEREA.keyISNULLorB.keyISNULL; ","date":"2020-06-22","objectID":"/mysql-dql/:18:0","tags":["MySQL"],"title":"【MySQL】DQL数据查询","uri":"/mysql-dql/"},{"categories":["MySQL"],"content":"DML解释 DML: 数据操作语言(Data Manipulation Language)。 主要操作有： 插入数据 修改数据 删除数据 ","date":"2020-06-20","objectID":"/mysql-dml/:1:0","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"插入数据 ","date":"2020-06-20","objectID":"/mysql-dml/:2:0","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"1. 语法 插入单行 INSERTINTO表名(字段名1，字段名2，......)VALUES(值1，值2，......); 插入多行 INSERTINTO表名(字段名1，字段名2，......)VALUES(值1，值2，......),(值1，值2，......)...; ","date":"2020-06-20","objectID":"/mysql-dml/:2:1","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"2. 说明 字段名列表和字段值列表一一对应。 数值型值不用引号，非数值型值必须使用引号。 字段名列表可以省略不写，此时字段列表的顺序和定义时一样。 ","date":"2020-06-20","objectID":"/mysql-dml/:2:2","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"3. 示例 INSERTINTOstuinfo(stuid,stuname,stugender,email,age,majorid)VALUES(1,'TOm','男','tom@gmail.com',12,1); ","date":"2020-06-20","objectID":"/mysql-dml/:2:3","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"修改数据 ","date":"2020-06-20","objectID":"/mysql-dml/:3:0","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"1. 语法 修改单表： UPDATE表名SET列=新值,列=新值,...WHERE筛选条件; 修改多表，sql92语法： UPDATE表名1别名，表名2别名SET列=值,...WHERE连接条件AND筛选条件; 修改多表，sql99语法： UPDATE表1别名INNER|LEFT|RIGHTJOIN表2别名ON连接条件SET列=值,...WHERE筛选条件; ","date":"2020-06-20","objectID":"/mysql-dml/:3:1","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"删除数据 ","date":"2020-06-20","objectID":"/mysql-dml/:4:0","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"1. 语法 DELETE语句： DELETEFROM表名WHERE筛选条件; TRUNCATE语句: TRUNCATETABLE表名; ","date":"2020-06-20","objectID":"/mysql-dml/:4:1","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"2. DELETE 和 TRUNCATE 的比较 DELETE可以添加WHERE条件，TRUNCATE不能添加WHERE条件，一次性清除所有数据。 TRUNCATE的效率较高。 对于带自增长列的表，使用DELETE删除后，重新插入数据时，记录从断点处开始。使用TRUNCATE删除后，重新插入数据时，记录从1开始。 DELETE删除数据时，会返回受影响的行数，TRUNCATE删除数据时，不会返回受影响的行数。 DELETE删除数据时，可以支持事务回滚，TRUNCATE删除数据时，不支持事务回滚。 ","date":"2020-06-20","objectID":"/mysql-dml/:4:2","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"导入数据 ","date":"2020-06-20","objectID":"/mysql-dml/:5:0","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"1. 命令行导入 mysql -h ip -P port -u username -p 数据库名 \u003c data.sql data.sql是包含表结构的备份文件。 ","date":"2020-06-20","objectID":"/mysql-dml/:5:1","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"2. source 在MySQL客户端中使用source，也可以导入数据： sourcedata.sql; data.sql是包含表结构的数据文件。 ","date":"2020-06-20","objectID":"/mysql-dml/:5:2","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"3. LOAD DATA 在MySQL客户端，可以使用LOAD DATA语句插入数据： LOADDATALOCALINFILE'数据文件'INTOTABLE表名FIELDSTERMINATEDBY'列分隔符'LINESTERMINATEDBY'行分隔符'; LOCAL表示从客户端主机读取文件，如果省略该关键字，表示从服务器读取文件。 默认情况下，数据文件列的顺序和表字段的顺序是一一对应的，如果想指定字段的顺序，则语法为： LOADDATALOCALINFILE'数据文件'INTOTABLE表名(字段列表...)FIELDSTERMINATEDBY'列分隔符'LINESTERMINATEDBY'行分隔符'; ","date":"2020-06-20","objectID":"/mysql-dml/:5:3","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"4. mysqlimport 在命令行使用mysqlimport工具，也可以将数据插入数据库。 mysqlimport -h ip -P port -u username -p \\ --local \\ --fields-terminated-by='列分隔符' \\ --lines-terminated-by='字符分隔符' \\ --columns=字段列表 \\ 库名 文件名 注意，表名必须和文件名保持一致。 mysqlimport选项的含义与LOAD DATA语句类似。 ","date":"2020-06-20","objectID":"/mysql-dml/:5:4","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"导出数据 ","date":"2020-06-20","objectID":"/mysql-dml/:6:0","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"1. SELECT … INRO OUTFILE SELECT*FROM表名INTOOUTFILE'路径'FIELDSTERMINATEDBY','OPTIONALLYENCLOSEDBY'\"'LINESTERMINATEDBY'\\n'; 说明： FIELDS TERMINATED BY：指定生成的字段分隔符。 ENCLOSED BY：将每个字段用指定符号包围。 LINES TERMINATED BY：指定生成的行分隔符。 执行上述语句时，需要注意MySQL的secure_file_priv变量，该变量有三个值： NULL：不允许生成文件。 具体的路径：生成的文件只能放在该路径下。 空值：对文件的生成不做限制。 ","date":"2020-06-20","objectID":"/mysql-dml/:6:1","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"2. mysqldump 在命令行下使用mysqldump，可以实现数据导出备份。用法为： mysqldump [options] 库名 [表名] # 或者 mysqldump [options] --database/-B 库名... # 或者 mysqldump [options] --all-databases/-A 连接选项： -u：用户名。 -p：密码。 -h：数据库IP。 -P：连接端口。 输出内容选项： --add-drop-database：在数据库的创建语句前，添加DROP DATABASE语句。 --add-drop-table：在表的创建语句前，添加DROP TABLE语句，默认开启。 --skip-add-drop-table：表的创建语句前，不添加DROP TABLE语句。 -n：不包含数据库的创建语句。 -t：不包含数据表的创建语句。 -d：不包含数据。 ","date":"2020-06-20","objectID":"/mysql-dml/:6:2","tags":["MySQL"],"title":"【MySQL】DML数据操作","uri":"/mysql-dml/"},{"categories":["MySQL"],"content":"DDL解释 DDL: 数据定义语言(Data Define Language)，用于对数据库和表进行管理和操作。 ","date":"2020-06-19","objectID":"/mysql-ddl/:1:0","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"库管理 ","date":"2020-06-19","objectID":"/mysql-ddl/:2:0","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"1. 查看所有的数据库列表 SHOWDATABASES; ","date":"2020-06-19","objectID":"/mysql-ddl/:2:1","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"2. 创建数据库 详细语法为： CREATE{DATABASE|SCHEMA}[IFNOTEXISTS]库名[[DEFAULT]CHARACTERSET[=]字符集编码]; 常见的字符集编码方式有utf8和utf8mb4。 utf8是utf8mb3的别名，使用该编码时，一个字符最多占3个字节。如果使用utf8mb4，一个字符最多占4个字节。推荐使用utf8mb4，方便存储emoji。 CREATEDATABASE库名; CREATEDATABASEIFNOTEXISTS库名;#如果不存在则创建 CREATESCHEMA库名CHARACTERSETutf8mb4; ","date":"2020-06-19","objectID":"/mysql-ddl/:2:2","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"3. 查看建库语句 SHOWCREATE{DATABASE|SCHEMA}库名; ","date":"2020-06-19","objectID":"/mysql-ddl/:2:3","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"4. 修改数据库 ALTER{DATABASE|SCHEMA}库名[[DEFAULT]CHARACTERSET[=]字符编码] ","date":"2020-06-19","objectID":"/mysql-ddl/:2:4","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"5. 删除数据库 DROP{DATABASE|SCHEMA}[IFEXISTS]库名; 如： DROPDATABASE库名; DROPDATABASEIFEXISTS库名;#如果存在则删除 ","date":"2020-06-19","objectID":"/mysql-ddl/:2:5","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"6. 打开数据库 USE库名; ","date":"2020-06-19","objectID":"/mysql-ddl/:2:6","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"7. 查看所处数据库 SELECTDATABASE(); ","date":"2020-06-19","objectID":"/mysql-ddl/:2:7","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"表管理 ","date":"2020-06-19","objectID":"/mysql-ddl/:3:0","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"1. 创建表 语法： CREATETABLE[IFNOTEXISTS]表名(字段名字段类型[字段约束],......字段名字段类型[字段约束],字段名字段类型[字段约束])[ENGINE=引擎[DEFAULT]CHARSET=字符编码]; 示例： CREATETABLEtest(idint,aint,bvarchar(20))ENGINE=InnoDBDEFAULTCHARSET=utf8mb4; ","date":"2020-06-19","objectID":"/mysql-ddl/:3:1","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"2. 查看数据库的所有数据表 SHOWTABLES[FROM数据库名]; 除了数据表，该命令也会显示视图。 ","date":"2020-06-19","objectID":"/mysql-ddl/:3:2","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"3. 查看数据表结构 DESC表名; 或者： SHOWCOLUMNSFROM表名; 或者： SHOWCREATETABLE表名; ","date":"2020-06-19","objectID":"/mysql-ddl/:3:3","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"4. 修改表 修改表的属性： ALTERTABLE表名属性名=属性值; 修改表名： ALTERTABLE原表名RENAMETO新表名; 修改表字段： ALTERTABLE表名ADD|MODIFY|CHANGE|DROP[COLUMN]字段名字段类型字段约束; 示例： ALTERTABLEtestengine=InnoDB; ALTERTABLEstuinfoRENAMETOstudents; ALTERTABLEstudentsADDCOLUMNborndateTIMESTAMPNOTNULL; ALTERTABLEstudentsCHANGECOLUMNborndatebirthdayDATETIMENULL; ALTERTABLEstudentsMODIFYCOLUMNbirthdayTIMESTAMP; ALTERTABLEstudentsDROPCOLUMNbirthday; ","date":"2020-06-19","objectID":"/mysql-ddl/:3:4","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"5. 删除表 DROPTABLEIFEXISTStablename; ","date":"2020-06-19","objectID":"/mysql-ddl/:3:5","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"6. 复制表 CREATETABLEtablename1LIKEtablename2;#仅复制表结构 CREATETABLEtablename1SELECT*FROMtablename2;#复制结构和数据 示例： CREATETABLEempSELECTnameFROMemployeesWHERE1=2; ","date":"2020-06-19","objectID":"/mysql-ddl/:3:6","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"建表规范 表名不能小写，不能太长，不能使用关键字，要和业务有关。 必须设置存储引擎和字符集。 数据类型在满足需求的基础上，要足够简短。 必须有主键。 每个列尽量设置为not null，并设定默认值。 每个列需要加注释。 列名规范同表名。 ","date":"2020-06-19","objectID":"/mysql-ddl/:4:0","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"常用字段类型 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:0","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"1. 整数 tinyint：1字节，有符号的范围是-128～127，无符号的范围是0~255。 smallint：2字节，有符号的范围是-32768~32767，无符号的范围是0~65535。 mediumint：3字节，有符号的范围是-8388608~8388607，无符号的范围是0~16777215。 int：4字节，有符号的范围是-2147483648~2147483647，无符号的范围是0~4294967295。 bigint：8字节。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:1","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"2. 浮点数 float: 4字节单精度浮点数 double: 8字节双精度浮点数 例如：double(5, 2)表示最多5位，其中有且仅有2位小数，即最大值为999.99。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:2","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"3. decimal 浮点型，不会出现精度问题。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:3","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"4. char 固定长度字符串类型；内容范围是0~255字符； char(n)：n参数默认为1，不管实际存储，开辟空间都是n个字节，效率高。mysql5之后，n指的是字符个数。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:4","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"5. varchar 可变长度字符串类型；内容范围为0~65535字节； varchar(n)最大字节个数n必选，根据实际存储空间决定开辟空间，效率低。varchar会消耗额外1到2个字节，存储字符长度。mysql5之后，n指的是字符。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:5","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"6. text 字符串类型，通常存储较长文本。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:6","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"7. blob 字节类型；常用于jpg, mp3, avi。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:7","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"8. date 日期类型；格式为yyyy-MM-dd。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:8","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"9. time 时间类型；格式为hh:mm:ss。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:9","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"10. timestamp 用于保存日期和时间，保存格式为时间戳，共占用4个字节。 timestamp值的范围是1970-01-01 00:00:01 UTC到2038-01-19 03:14:07 UTC。 用命令行工具更新该值时，数据格式为“年月日时分秒”，“时分秒可以省略”。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:10","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"10. datetime 用于保存日期和时间，格式为时间戳，占用5个字节。 datetime精度可以到微秒，如果需要保存毫秒和微秒，则需要消耗额外空间，最大可扩展到8字节。 注意，上述规则不适用于MySQL5.6.4之前版本。在该版本之前，datetime固定占用8字节。 取值范围是0000-01-01 00:00:00到9999-12-31 23:59:59。显示具体值时，只会精确到秒。 ","date":"2020-06-19","objectID":"/mysql-ddl/:5:11","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"常见字段约束 ","date":"2020-06-19","objectID":"/mysql-ddl/:6:0","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"1. 说明 用于限制表中字段的数据。 ","date":"2020-06-19","objectID":"/mysql-ddl/:6:1","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"2. 列表 NOT NULL 非空。用于限制该字段为必填项。 DEFAULT 默认值。如果该字段没有插入值，则显示默认值。 PRIMARY KEY 主键。被设为主键的列值不能重复，并且不能为空。 ALTERTABLEtbl_nameADDPRIMARYKEY(column_list); UNIQUE 唯一键。限制字段不能重复，但是可以为空。 CHECK 检查。限制该字段值必须满足指定条件，MySQL不支持。 FOREIGN KEY 外键，用于限制两个表的关系。 外键列的值必须来自主表的关联列。主表关联列和从表关联列必须类型一致，意思一致，但是名称无要求。主表的关联列要求必须是主键。 定义外键： ALTERTABLEteblenameADDCONSTRAINT外键名FOREIGNKEY(列名)REFERENCES表名（关联列）; 或者： CREATETABLEteblename(...CONSTRAINT外键名FOREIGNKEY(列名)REFERENCES表名(关联列)); 删除外键： ALTERTABLEtablenameDROPFOREIGNKEY键名 AUTO_INCREMENT 自增长列必须设置在一个键上，比如主键或唯一键。 自增长列要求数据类型为数值型。 一个表至多有一个自增长列。 ","date":"2020-06-19","objectID":"/mysql-ddl/:6:2","tags":["MySQL"],"title":"【MySQL】DDL数据定义","uri":"/mysql-ddl/"},{"categories":["MySQL"],"content":"DCL含义 DCL：数据控制语言(Data Control Language)，用来定义访问权限和安全级别。 ","date":"2020-06-18","objectID":"/mysql-dcl/:1:0","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"MySQL的用户定义 MySQL的用户格式为：username@'白名单'。 白名单表示允许登陆MySQL的ip地址。如果省略白名单，则等同于username@'%'，即对ip地址不做限制。 如下表示4个不同用户： root@'localhost'#root可以本地登陆MySQLroot@'10.0.0.1'#root可以通过10.0.0.1登陆MySQLroot@'10.0.0.%'#root可以通过10.0.0.x登陆MySQLroot@'%'#任何ip都能登陆MySQL ","date":"2020-06-18","objectID":"/mysql-dcl/:2:0","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"用户管理 ","date":"2020-06-18","objectID":"/mysql-dcl/:3:0","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"1. 查看用户列表 用户信息存放在mysq【l.user表中。通常情况下，查看host, user, authentication_string即可。 SELECTuser,host,authentication_stringFROMmysql.user; ","date":"2020-06-18","objectID":"/mysql-dcl/:3:1","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"2. 创建用户 CREATEmysql.userusername@'ip地址'[IDENTIFIEDBYpassword]; 如果省略IDENTIFIED BY password部分，则默认该用户无密码。 ","date":"2020-06-18","objectID":"/mysql-dcl/:3:2","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"3. 修改密码 ALTERmysql.userusername@'ip地址'IDENTIFIEDBY'password'; ","date":"2020-06-18","objectID":"/mysql-dcl/:3:3","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"4. 删除用户 DROPmysql.userusername@'ip地址'; ","date":"2020-06-18","objectID":"/mysql-dcl/:3:4","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"5. 忘记密码 如果遇到忘记密码的情况，用如下两个参数重启MySQL，可以跳过密码验证。 --skip-grant-tables: 跳过授权表。 --skip-networking: 跳过TCP/IP连接，避免远程连接（不安全）。 具体处理过程为： 关闭MySQL。 重启MySQL。 mysqld_safe --skip-grant-tables --skip-networking 或者： service mysqld start --skip-grant-tales --skip-networking 手工加载授权表。 flushprivileges; 修改密码。 正常模式重启MySQL。 servicemysqldrestart ","date":"2020-06-18","objectID":"/mysql-dcl/:3:5","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"6. 说明 MySQL8.0之前，可以使用grant命令同时完成建立用户和授权的操作，但是8.0之后不行。 ","date":"2020-06-18","objectID":"/mysql-dcl/:3:6","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"权限管理 ","date":"2020-06-18","objectID":"/mysql-dcl/:4:0","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"1. 查看可授予的权限 SHOWprivileges; ","date":"2020-06-18","objectID":"/mysql-dcl/:4:1","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"2. 授权 8.0版本之前，使用如下语法： GRANT权限ON对象TO用户IDENTIFIEDBY'密码'; 8.0版本之后，需要先建立用户才能授权。 GRANT权限ON对象TO用户; 权限ALL表示除GRANT之外的所有权限，如果想授予GRANT权限，8.0语法如下，8.0之前版本同理。 GRANT权限ON对象TO用户WITHGRANTOPTION; “对象”是指库和表，如*.*表示所有库中的所有表。也可以只授予某几个列的权限，用法是： GRANT权限(列字段...)... ","date":"2020-06-18","objectID":"/mysql-dcl/:4:2","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"3. 回收权限 REVOKE权限ON对象FROM用户; 如： REVOKEselectONtest.t1FROMtest_user@'localhost'; ","date":"2020-06-18","objectID":"/mysql-dcl/:4:3","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"4. 查看单个用户权限 查看自己： SHOWGRANTS; 查看他人： SHOWGRANTSFOR用户; ","date":"2020-06-18","objectID":"/mysql-dcl/:4:4","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"5. 查看所有用户的权限 查看表相关的权限： SELECT*FROMmysql.tables_priv; 查看库相关的权限： SELECT*FROMmysql.db; 查看所有用户的权限： SELECT*FROMmysql.user; 查看列相关权限： SELECT*FROMmysql.columns_priv; 其他权限详情可以在mysql库中查看。 ","date":"2020-06-18","objectID":"/mysql-dcl/:4:5","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["MySQL"],"content":"总结 DCL主要作用是对用户进行管理，保证数据库的数据安全。用户管理和权限管理属于DCL的范畴，上述内容即为相关语法的说明。 ","date":"2020-06-18","objectID":"/mysql-dcl/:5:0","tags":["MySQL"],"title":"【MySQL】DCL用户管理","uri":"/mysql-dcl/"},{"categories":["Linux"],"content":"说明 在进行软件开发的过程中，避免不了要经常和Linux系统打交道。这里总结了一些Linux常见的命令和快捷键。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:1:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"常见快捷键 Linux中有如下常见快捷键： Ctrl+c：终止前台运行的程序 Ctrl+z：将前台运行的程序挂起到后台 Ctrl+d：退出 等价于exit Ctrl+l：清屏 Ctrl+a | Ctrl+home：光标移到命令行的最前端 Ctrl+e | Ctrl+end：光标移到命令行的后端 Ctrl+u：删除光标前的所有字符 Ctrl+k：删除光标后的所有字符 Ctrl+r：搜索历史命令 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:2:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"grep ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:3:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"语法 grep 选项 '关键字' 文件名 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:3:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"常见选项 -i: 不区分大小写。 -v: 查找不包含指定内容的行。 -w: 按单词搜索 -o: 打印匹配关键字 -c: 统计匹配到的次数 -n: 显示行号 -r: 逐层遍历目录查找 -A: 显示匹配行及后面多少行 -B: 显示匹配行及前方多少行 -C: 显示匹配行及前后多少行 -l: 只列出匹配的文件名 -L: 列出不匹配的文件名 -e: 使用正则表达式 -E: 使用扩展正则表达式 ^key: 以关键字开头 key$: 以关键字结尾 ^$: 匹配空行 --color=auto: 将找到的内容，加上颜色显示 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:3:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"举例 去除空行: grep -v '^$' [files...] ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:3:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"wc 统计文本的行数、单词数、字符数、字节数。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:4:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"语法 wc 选项 文件 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:4:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"常用选项 -c：统计字节数 -w：统计单词数 -l：统计行数 -m：统计字符数 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:4:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"输出结果 输出结果不受选项顺序的影响。 如果选项全选，输出顺序为： 行数 单词数 字符数 字节数 文件名 如果选项缺省，输出顺序为： 行数 单词数 字节数 文件名 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:4:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"示例 统计文件内容行数： wc -l filename ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:4:4","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"cut 列截取工具，用于文本列的截取。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:5:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"语法 cut 选项 文件名 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:5:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"常用选项 -b：以字节为单位，进行分割，然后输出指定范围的内容 -c：以字符为单位，进行分割、然后输出指定范围的内容 -d：自定义分割符，默认为制表符\\t，需要和-f同时使用 -f：可与-d同时使用，指定截取的区域(列) 指定范围： N：指定第N个字节、字符或者字段 N-：从N开始到结束 N-M：从N到M，包含M -M：从开始到M，包含M ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:5:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"示例 以空格为分隔符，获取第2，第3，第4和第6个字段 cut -d \" \" -f 2-4,6 filename 以字节为分割单位，获取第2，第3，第4和第6个字段 cut -b 2-4,6 filename 以字符为分割单位，获取第2，第3，第4和第6个字段 cut -c 2-4,6 filename ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:5:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"sort 将文件的每一行作为一个单位，从首字符向后，依次按照unicode码值进行比较，最后将结果升序输出。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:6:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"语法 sort 选项 源文件 [-o 输出文件] ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:6:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"选项 -u：去除重复行 -r：降序排列，默认升序 -o：将排序结果输出到文件中，类似于重定向符号\u003e -n：以数字排序，默认是按字符排序 -t：分隔符 -k：第n列 -b：忽略前导空格 -R：随机排序，每次运行结果均不同 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:6:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"示例： 去除排序结果的重复行： # apple =\u003e apple # orange =\u003e banana # apple =\u003e orange # banana =\u003e sort -u filename 根据第2列的数值，进行排序 # apple:12 =\u003e orange:2 # orange:2 =\u003e apple:12 # apple:12 =\u003e apple:12 # banana:23 =\u003e banana:23 sort -t \":\" -k 2 -n filename ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:6:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"uniq 去除并删除文中出现的连续行，一般与sort命令结合使用。即为了使uniq起作用，所有的重复行必须是相邻的。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:7:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"选项 -u：--unique仅显示出现一次的行。 -i：忽略大小写。 -c：统计重复行次数 -d：只显示重复行 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:7:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"示例 统计各行出现的次数 sort filename | uniq -c 在文中找出重复行 sort filename | uniq -d ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:7:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"tee 从标准输入读取，并且写入到标准输出和文件。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:8:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"选项 -a：追加重定向，默认是覆盖。 -i：忽略中断信号。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:8:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"示例 将输入同时保存到file1和file2 tee file1 file2 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:8:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"diff 用于逐行比较文件的不同。 diff描述两个文件不同的方式，是告诉我们怎么改变第一个文件之后，与第二个文件匹配。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:9:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"语法 diff [选项] 文件1 文件2 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:9:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"选项 -b：不检查空格 -B：不检查空白行 -i：不检查大小写 -w：忽略所有的空格 --normal：正常格式显示（默认） -c：上下文格式显示 -u：合并格式显示 -N：将不存在的文件当作空文件 -q：比较两个目录不同时，默认情况下，会显示同名文件具体的差异内容。如果使用了-q参数，则只会显示文件的差异。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:9:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"显示格式 正常模式显示 diff f1.txt f2.txt 5c5 # 第一个文件的第5行需要改变(c=change)才能和第二个文件的第5行匹配(a, addition; d, deletion) ... 3d3 # 第一个文件的第3行删除(d=delete)后才能和第二个文件的第3行匹配 ... 6a6,7 # 第一个文件的第6行增加(a=add)内容后，才能和第二个文件的第6到7行匹配 ... 上下文模式显示 diff -c f1.txt f2.txt *** f1.txt 2020-09-15 11:17:10.636634400 +0800 # 第一个文件信息 --- f2.txt 2020-09-15 11:20:17.862629200 +0800 # 第二个文件信息 *************** # 分隔符 *** 1,6 *** # 以***开头表示file1文件，1，6表示1到6行 ! aaa # !表示改行需要修改才与第二个文件匹配 - hello world # -表示需要删除改行才与第二个文件匹配 ... --- 1,7 --- # 以---开头表示file2文件，1，7表示1到7行 ! aaa # 表示第一个文件需要修改才能与第二个文件匹配 ! hello # 表示第一个文件需要修改才能与第二个文件匹配 ... + 333 # 表示第一个文件需要加上该行才能与第二个文件匹配 + world # 表示第一个文件需要加上该行才能与第二个文件匹配 ... 合并格式显示 diff -u f1.txt f2.txt --- f1.txt 2020-09-15 11:17:10.636634400 +0800 # 变动前文件 +++ f2.txt 2020-09-15 11:20:17.862629200 +0800 # 变动后文件 @@ -2,9 +2,9 @@ # 第一个文件的2到9行 第二个文件的2到9行 two three four -five # 删除第一个文件的行 +fifteen # 第二个文件新增的行 six seven eight nine -ten +TEN ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:9:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"sshpass 非交互式密码验证工具。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:10:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"安装 RedHat/Centos安装： yum install sshpass Debian/Ubuntu安装： sudo apt-get install sshpass 源码安装： -\u003e wget http://sourceforge.net/projects/sshpass/files/latest/download -O sshpass.tar.gz -\u003e tar -xvf sshpass.tar.gz -\u003e cd sshpass-1.06 -\u003e ./configure -\u003e sudo make install ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:10:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"常用参数 -f：使用文件内容作为密码 -p：通过参数提供密码 -e：通过环境变量SSHPASS提供密码 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:10:2","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"示例 登录服务器，并且查看文件系统磁盘使用情况： sshpass -p 'my_pass_here' ssh username@host 'df -h' ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:10:3","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"paste 用于合并文件行。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:11:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"选项 -d：自定义分隔符，默认是tab。 -s：文件内容按行排布，默认按列排布。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:11:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"tr 用于字符替换和删除。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:12:0","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"用法 用法一：命令的执行结果交给tr处理。 commands | tr \"string1\" \"string2\" string1和string2的字符一一对应替换。 如果string1比string2长，则string2的最后一个字符会对应多个string1中的字符。 如果string1比string2短，则string2多余部分被丢弃。 用法二：tr处理的内容来自文件，需要使用标准输入符号 tr \"string1\" \"string2\" \u003c filename string1和string2的具体用法同上。 用法三：匹配string进行相应操作，如删除操作 tr options \"string\" \u003c filename 常用选项： -d：删除字符串中所有输入的字符。 -s：删除所有重复出现的字符，只保留第一个，即将重复出现的字符压缩为一个字符。 ","date":"2020-04-30","objectID":"/linux-chang-jian-ming-ling/:12:1","tags":["Linux"],"title":"【Linux】常见命令","uri":"/linux-chang-jian-ming-ling/"},{"categories":["Linux"],"content":"df说明 df命令可以查看整个磁盘空间的占用情况，但是不能查看某个目录的大小。 ","date":"2020-03-09","objectID":"/linux-df/:1:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Linux"],"content":"命令格式 df [options] ","date":"2020-03-09","objectID":"/linux-df/:2:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Linux"],"content":"options options是可选的，常见的参数如下： -h：以容易理解的格式输出文件系统的分区情况，如1kB、1MB、1GB。 -H：和-h很像，但是以1000为单位，而不是1024。 -k：以kB为单位输出。 -m：以MB为单位输出。 -a：列出所有文件系统分区，包括大小为0的分区。 -T：显示文件系统类型。 对于-hm或者-hk，h后面的m和k不会生效。 对于-mh或者-kh，h不会生效。 -H同理。 ","date":"2020-03-09","objectID":"/linux-df/:3:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Linux"],"content":"使用示例 查看系统分区 df -h 查看文件系统类型 df -T ","date":"2020-03-09","objectID":"/linux-df/:4:0","tags":["Linux"],"title":"【Linux】df命令详解","uri":"/linux-df/"},{"categories":["Golang"],"content":"定义 Buffer是一个可变长的字节缓冲区，具备读写的方法。Buffer的零值是一个空的缓冲区。 type Buffer struct { buf []byte // contents are the bytes buf[off : len(buf)] off int // read at \u0026buf[off], write at \u0026buf[len(buf)] lastRead readOp // last read operation, so that Unread* can work correctly. } ","date":"2020-03-08","objectID":"/golang-buffer-pkg/:1:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang-buffer-pkg/"},{"categories":["Golang"],"content":"声明 有四种声明方法。 直接定义一个Buffer变量。 var b bytes.Buffer 使用New返回Buffer变量指针。 b := new(bytes.Buffer) 使用[]byte切片初始化。 b := bytes.NewBuffer([]byte(\"hello\")) 使用string初始化。 b := bytes.NewBufferString(\"hello\") ","date":"2020-03-08","objectID":"/golang-buffer-pkg/:2:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang-buffer-pkg/"},{"categories":["Golang"],"content":"写数据 Buffer提供了5种写数据的方法。 将[]byte切片写入尾部。 func (b *Buffer) Write(p []byte) (n int, err error) 将string写入尾部。 func (b *Buffer) WriteString(s string) (n int, err error) 将字符写入尾部。 func (b *Buffer) WriteByte(c byte) error 将rune写入尾部。 func (b *Buffer) WriteRune(r rune) (n int, err error) 将接口对象写入尾部。 func (b *Buffer) ReadFrom(r io.Reader) (n int64, err error) ","date":"2020-03-08","objectID":"/golang-buffer-pkg/:3:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang-buffer-pkg/"},{"categories":["Golang"],"content":"读数据 Buffer提供了7种读数据的方法。 读取n个字符。 func (b *Buffer) Next(n int) []byte 将数据读入[]byte。 func (b *Buffer) Read(p []byte) (n int, err error) 读取第一个byte。 func (b *Buffer) ReadByte() (byte, error) 读取第一个UTF8编码字符。 func (b *Buffer) ReadRune() (r rune, size int, err error) 读取分隔符前的内容，并且返回切片。 func (b *Buffer) ReadBytes(delim byte) (line []byte, err error) 读取分隔符前的内容，并且返回字符串。 func (b *Buffer) ReadString(delim byte) (line string, err error) 将内容输出到接口对象。 func (b *Buffer) WriteTo(w io.Writer) (n int64, err error) ","date":"2020-03-08","objectID":"/golang-buffer-pkg/:4:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang-buffer-pkg/"},{"categories":["Golang"],"content":"其他方法 返回字节切片。 func (b *Buffer) Bytes() []byte 返回字节切片容量。 func (b *Buffer) Cap() int 为容量增加n个字节。 func (b *Buffer) Grow(n int) 返回缓冲区长度。 func (b *Buffer) Len() int 清空数据。 func (b *Buffer) Reset() 字符串化。 func (b *Buffer) String() string 丢弃前n个未读字节以外的数据。 func (b *Buffer) Truncate(n int) 将最后一次成功读取的字节，设为未读取状态。 func (b *Buffer) UnreadByte() error 将最后一次读取的rune字符，设为未读取状态。 func (b *Buffer) UnreadRune() error ","date":"2020-03-08","objectID":"/golang-buffer-pkg/:5:0","tags":["Golang","buffer"],"title":"【Golang】buffer包的使用","uri":"/golang-buffer-pkg/"},{"categories":["Golang"],"content":"bufio包介绍 bufio包可以从文件或标准输入读取数据，还可以向文件写入数据。 读取数据时，先将数据读入缓冲区，然后再从缓冲区中读取。写入数据时，先把数据写入缓冲区，然后在某个时间节点，一次性地将数据写入文件。 通过缓冲区，能有效减少读写磁盘的次数。 注意，此处的缓冲区是指Golang为应用程序分配的一块内存空间。 ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:1:0","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"使用 下面仅介绍一些常见用法。 ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:2:0","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"1. 读取数据 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) b := make([]byte, 64) n, err := buf.Read(b) if err != nil { log.Fatal(err) } fmt.Println(buf.Buffered()) fmt.Println(string(b[:n])) } ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:2:1","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"2. 按行读取 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 按行读取 for { bs1, _, err := buf.ReadLine() if err == io.EOF { break } fmt.Println(string(bs1)) } } ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:2:2","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"3. 读取多个字节 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) // 指定每次读取的分割符 for { bs2, err := buf.ReadBytes('\\n') if err == io.EOF { break } fmt.Print(string(bs2)) } } ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:2:3","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"4. 读取字符串 func main() { file1, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } defer file1.Close() // 创建缓冲区，默认大小是4096 buf := bufio.NewReader(file1) for { str, err := buf.ReadString('\\n') if err != nil { break } fmt.Print(str) } } ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:2:4","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"5. 从标准输入读取 func main() { // 读取输入 buf := bufio.NewReader(os.Stdin) for { s2, _, err := buf.ReadLine() fmt.Println(string(s2)) fmt.Println(err) if string(s2) == \"q\" { break } } } ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:2:5","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"6. 写入数据到文件 func main() { // 写入数据 file, err := os.OpenFile(\"./data1.txt\", os.O_CREATE|os.O_RDWR, os.ModePerm) if err != nil { log.Fatal(err) } buf2 := bufio.NewWriter(file) n, err := buf2.WriteString(\"今夜特别漫长\\n\") if err != nil { log.Fatal(err) } // 将缓冲区数据刷入磁盘文件 buf2.Flush() fmt.Println(n) } ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:2:6","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"源码解析 ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:3:0","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"1. bufio.NewReader 用于生成一个读缓冲区。 方法的具体定义为： func NewReader(rd io.Reader) *Reader { return NewReaderSize(rd, defaultBufSize) } 传入的参数rd需要实现io.Reader接口，通过os.Open或者os.OpenFile返回的*File对象就实现了这个接口。 *Reader结构体中包含buf字段，这是一个字节切片，用做缓冲区来存放数据。 defaultBufSize用于定义buf的长度和容量，默认4096个字节。 ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:3:1","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"2. bufio.Read 方法的声明为： func (b *Reader) Read(p []byte) (n int, err error) 当p的长度为0时，不读取数据。 当缓冲区为空，且p的长度大于等于缓冲区长度时，不经过缓冲区，直接从文件中读取数据。 当缓冲区为空，且p的长度小于缓冲区长度时，先将数据读入缓冲区，再从缓冲区读取需要的字节。 如果缓冲不为空，直接从缓冲区读取，当p读满了，或者缓冲区读空了，就返回结果。 ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:3:2","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"3. bufio.NewWriter func NewWriter(w io.Writer) *Writer { return NewWriterSize(w, defaultBufSize) } 用于生成一个写缓冲区。逻辑类似于bufio.NewReader，返回一个*Writer结构体地址。 Writer中含有buf字段，用做缓冲区来存放数据，默认长度为4096个字节。 ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:3:3","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"4. bufio.Write func (b *Writer) Write(p []byte) (nn int, err error) 如果写入的数据大于缓冲区可用长度，当缓冲区内无数据时，直接写入文件。 如果写入数据大于缓冲区可用长度，且缓冲区有数据，则先将数据写入缓冲区，再将缓冲区写入文件并清空缓冲区。不断重复该过程，直到剩余数据不大于缓冲区可用长度，然后仅将数据写入缓冲区，结束。 如果写入数据小于等于缓冲区可用长度，则仅仅写入缓冲区。 ","date":"2020-03-06","objectID":"/golang-bufio-pkg/:3:4","tags":["Golang","bufio"],"title":"【Golang】bufio包的使用","uri":"/golang-bufio-pkg/"},{"categories":["Golang"],"content":"介绍 golang提供了文件相关的各种操作，包括创建、删除、和读写等。 ","date":"2020-03-01","objectID":"/golang-files/:1:0","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"文件基本操作方法 ","date":"2020-03-01","objectID":"/golang-files/:2:0","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"1. 查看文件信息 func main() { // 查看文件信息 fileInfo, err := os.Stat(\"./data.txt\") if err != nil { fmt.Println(err) return } fmt.Println(\"Stat:\", fileInfo.Name()) fmt.Println(\"Stat:\", fileInfo.IsDir()) fmt.Println(\"Stat:\", fileInfo.Size()) fmt.Println(\"Stat:\", fileInfo.Mode()) fmt.Println(\"Stat:\", fileInfo.ModTime()) } ","date":"2020-03-01","objectID":"/golang-files/:2:1","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"2. 路径操作 func main() { // 路径操作 filename1 := \"./file.txt\" fmt.Println(\"IsAbs:\", filepath.IsAbs(filename1)) // 获取绝对路径 fileabs, err := filepath.Abs(filename1) if err != nil { log.Fatal(err) } fmt.Println(fileabs) // 绝对路径的父级目录 fmt.Println(\"Join:\", path.Join(fileabs, \"..\")) } ","date":"2020-03-01","objectID":"/golang-files/:2:2","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"3. 创建一级文件夹 func main() { // 创建一级文件夹 err := os.Mkdir(\"./aa\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2020-03-01","objectID":"/golang-files/:2:3","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"4. 创建多级文件夹 func main() { // 创建多级文件夹 err := os.MkdirAll(\"./bb/cc\", os.ModePerm) if err != nil { fmt.Println(err) } } ","date":"2020-03-01","objectID":"/golang-files/:2:4","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"5. 创建文件 func main() { // 创建文件，权限默认为0666，如果文件存在，会清空数据 file, err := os.Create(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2020-03-01","objectID":"/golang-files/:2:5","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"5. 只读模式打开文件 func main() { // 只读模式打开文件 file, err := os.Open(\"./file.txt\") if err != nil { fmt.Println(err) return } file.Close() } ","date":"2020-03-01","objectID":"/golang-files/:2:6","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"6. 以指定模式打开文件 func main() { // 以指定模式打开文件，如果文件不存在，则以指定权限0666创建文件 file, err := os.OpenFile(\"./file.txt\", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0666) if err != nil { fmt.Println(err) return } file.Close() } ","date":"2020-03-01","objectID":"/golang-files/:2:7","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"7. 删除空目录或文件 func main() { // 删除空目录 err := os.Remove(\"./aa\") if err != nil { fmt.Println(\"remove:\", err) return } // 删除文件 err = os.Remove(\"./file.txt\") if err != nil { fmt.Println(\"remove:\", err) return } } ","date":"2020-03-01","objectID":"/golang-files/:2:8","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"8. 删除指定目录或文件，即使目录非空 func main() { // 删除所有目录，包括非空目录 err := os.RemoveAll(\"./aa.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } err = os.RemoveAll(\"./data.txt\") if err != nil { fmt.Println(\"RemoveAll:\", err) return } } ","date":"2020-03-01","objectID":"/golang-files/:2:9","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"读取文件内容 除了上述的文件基本操作外，golang还为读文件提供了多种方式。 ","date":"2020-03-01","objectID":"/golang-files/:3:0","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"file.Read func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() b := make([]byte, 128) for { n, err := file.Read(b) if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } } ","date":"2020-03-01","objectID":"/golang-files/:3:1","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"io.ReadFull 1 package main 2 3 import ( 4 \"fmt\" 5 \"io\" 6 \"log\" 7 \"os\" 8 ) 9 10 func main() { 11 file, err := os.Open(\"./data.txt\") 12 if err != nil { 13 log.Fatal(err) 14 } 15 defer file.Close() 16 17 // 读取正好1024个字节，内容不够会报错 18 b := make([]byte, 1024) 19 n, err := io.ReadFull(file, b) 20 if err != nil { 21 log.Fatal(err) 22 } 23 24 fmt.Printf(\"%s\", string(b[:n])) 25 } ","date":"2020-03-01","objectID":"/golang-files/:3:2","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"io.ReadAtLeast func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() // 至少读取8个字节，不够的话会报错 b := make([]byte, 1024) n, err := io.ReadAtLeast(file, b, 8) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(b[:n])) } ","date":"2020-03-01","objectID":"/golang-files/:3:3","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"bufio.NewReader bufio提供了多种读取文件的方法，但方法名都是以Read开头。 func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() reader := bufio.NewReader(file) for { str, err := reader.ReadString('\\n') if err == io.EOF { break } if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", str) } } ","date":"2020-03-01","objectID":"/golang-files/:3:4","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"ioutil.ReadAll func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() data, err := ioutil.ReadAll(file) if err != nil { log.Fatal(err) } fmt.Printf(\"%s\", string(data)) } ","date":"2020-03-01","objectID":"/golang-files/:3:5","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"ioutil.ReadFile func main() { b, err := ioutil.ReadFile(\"./data.txt\") if err != nil { log.Fatal(err) } fmt.Println(string(b)) } ","date":"2020-03-01","objectID":"/golang-files/:3:6","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"bufio.NewScanner func main() { file, err := os.Open(\"./data.txt\") if err != nil { log.Fatal(err) } defer file.Close() scanner := bufio.NewScanner(file) for scanner.Scan() { fmt.Println(scanner.Text()) } err = scanner.Err() if err != nil { log.Fatal(err) } } ","date":"2020-03-01","objectID":"/golang-files/:3:7","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"写入文件 golang为写文件提供了以下方式。 ","date":"2020-03-01","objectID":"/golang-files/:4:0","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"file.Write func main() { file, err := os.OpenFile(\"./data.txt\", os.O_WRONLY|os.O_CREATE, 0644) if err != nil { log.Fatal(err) } defer file.Close() b := []byte(\"Hello\") n, err := file.Write(b) if err != nil { log.Fatal(err) } fmt.Printf(\"Wrote %d bytes.\\n\", n) } ","date":"2020-03-01","objectID":"/golang-files/:4:1","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"ioutil.WriteFile func main() { err := ioutil.WriteFile(\"./data.txt\", []byte(\"Hello\"), 0644) if err != nil { log.Fatal(err) } } ","date":"2020-03-01","objectID":"/golang-files/:4:2","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"},{"categories":["Golang"],"content":"bufio.NewWriter bufio包中，写入文件的方法较多，但都是以Write开头。 func main() { file, err := os.OpenFile(\"./data.txt\", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644) if err != nil { log.Fatal(err) } defer file.Close() writer := bufio.NewWriter(file) writer.WriteString(\"Hello world\") writer.Flush() } ","date":"2020-03-01","objectID":"/golang-files/:4:3","tags":["Golang","file"],"title":"【Golang】文件操作","uri":"/golang-files/"}]